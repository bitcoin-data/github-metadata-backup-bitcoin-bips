{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/1458",
    "id": 1379306069,
    "node_id": "PR_kwDOAN28mc5SNopV",
    "html_url": "https://github.com/bitcoin/bips/pull/1458",
    "diff_url": "https://github.com/bitcoin/bips/pull/1458.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/1458.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1458/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/c55f80c53c98642357712c1839cfdc0551d531c4",
    "number": 1458,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "BIP 352: Silent Payments",
    "user": {
      "login": "josibake",
      "id": 7444140,
      "node_id": "MDQ6VXNlcjc0NDQxNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/josibake",
      "html_url": "https://github.com/josibake",
      "followers_url": "https://api.github.com/users/josibake/followers",
      "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
      "organizations_url": "https://api.github.com/users/josibake/orgs",
      "repos_url": "https://api.github.com/users/josibake/repos",
      "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/josibake/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Silent payments is a static address protocol for Bitcoin, originally proposed on the mailing list here: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-March/020180.html \r\n\r\nSince then, the proposal has received several rounds of review and has a WIP implementation here: https://github.com/bitcoin/bitcoin/pull/27827 . The proposal has also been sent to the mailing list for review here: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-June/021750.html\r\n\r\nProposing this as an informational BIP to ensure wallets across the ecosystem can standardize and correctly implement the protocol.",
    "labels": [
      {
        "id": 275845989,
        "node_id": "MDU6TGFiZWwyNzU4NDU5ODk=",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/New%20BIP",
        "name": "New BIP",
        "color": "5319e7",
        "default": false
      }
    ],
    "created_at": "2023-06-05T16:16:42Z",
    "updated_at": "2023-09-12T15:47:17Z",
    "mergeable": true,
    "mergeable_state": "clean",
    "merge_commit_sha": "f9867948f6e5e018f9778d7e7716a35b34593e81",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "josibake:silent-payments-bip",
      "ref": "silent-payments-bip",
      "sha": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 611369584,
        "node_id": "R_kgDOJHDCcA",
        "name": "bips",
        "full_name": "josibake/bips",
        "owner": {
          "login": "josibake",
          "id": 7444140,
          "node_id": "MDQ6VXNlcjc0NDQxNDA=",
          "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/josibake",
          "html_url": "https://github.com/josibake",
          "followers_url": "https://api.github.com/users/josibake/followers",
          "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
          "organizations_url": "https://api.github.com/users/josibake/orgs",
          "repos_url": "https://api.github.com/users/josibake/repos",
          "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/josibake/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/josibake/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/josibake/bips",
        "archive_url": "https://api.github.com/repos/josibake/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/josibake/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/josibake/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/josibake/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/josibake/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/josibake/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/josibake/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/josibake/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/josibake/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/josibake/bips/contributors",
        "deployments_url": "https://api.github.com/repos/josibake/bips/deployments",
        "downloads_url": "https://api.github.com/repos/josibake/bips/downloads",
        "events_url": "https://api.github.com/repos/josibake/bips/events",
        "forks_url": "https://api.github.com/repos/josibake/bips/forks",
        "git_commits_url": "https://api.github.com/repos/josibake/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/josibake/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/josibake/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/josibake/bips.git",
        "issue_comment_url": "https://api.github.com/repos/josibake/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/josibake/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/josibake/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/josibake/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/josibake/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/josibake/bips/languages",
        "merges_url": "https://api.github.com/repos/josibake/bips/merges",
        "milestones_url": "https://api.github.com/repos/josibake/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/josibake/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/josibake/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/josibake/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:josibake/bips.git",
        "stargazers_url": "https://api.github.com/repos/josibake/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/josibake/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/josibake/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/josibake/bips/subscription",
        "tags_url": "https://api.github.com/repos/josibake/bips/tags",
        "teams_url": "https://api.github.com/repos/josibake/bips/teams",
        "trees_url": "https://api.github.com/repos/josibake/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/josibake/bips.git",
        "hooks_url": "https://api.github.com/repos/josibake/bips/hooks",
        "svn_url": "https://github.com/josibake/bips",
        "homepage": "",
        "forks_count": 3,
        "stargazers_count": 2,
        "watchers_count": 2,
        "size": 13534,
        "default_branch": "master",
        "open_issues_count": 3,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-09-12T14:54:56Z",
        "created_at": "2023-03-08T17:26:09Z",
        "updated_at": "2023-06-05T22:15:31Z"
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "55566a73f9ddf77b4512aca8e628650c913067bf",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5563,
        "stargazers_count": 8312,
        "watchers_count": 8312,
        "size": 13660,
        "default_branch": "master",
        "open_issues_count": 117,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-09-12T09:49:15Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2023-09-12T04:56:28Z"
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
      }
    },
    "author_association": "NONE",
    "draft": false,
    "additions": 3255,
    "deletions": 0,
    "changed_files": 6,
    "commits": 1,
    "review_comments": 149,
    "comments": 17
  },
  "events": [
    {
      "event": "closed",
      "id": 9435798173,
      "node_id": "CE_lADOAN28mc5n1phizwAAAAIyatqd",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9435798173",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-05T16:25:23Z"
    },
    {
      "event": "reopened",
      "id": 9435800608,
      "node_id": "REE_lADOAN28mc5n1phizwAAAAIyauQg",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9435800608",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-05T16:25:37Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-05T16:26:32Z",
      "updated_at": "2023-06-05T16:26:32Z",
      "source": {
        "issue": {
          "id": 1627211995,
          "node_id": "PR_kwDOJHDCcM5MMha8",
          "url": "https://api.github.com/repos/josibake/bips/issues/1",
          "repository_url": "https://api.github.com/repos/josibake/bips",
          "labels_url": "https://api.github.com/repos/josibake/bips/issues/1/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/josibake/bips/issues/1/comments",
          "events_url": "https://api.github.com/repos/josibake/bips/issues/1/events",
          "html_url": "https://github.com/josibake/bips/pull/1",
          "number": 1,
          "state": "closed",
          "state_reason": null,
          "title": "Silent payments BIP",
          "body": null,
          "user": {
            "login": "josibake",
            "id": 7444140,
            "node_id": "MDQ6VXNlcjc0NDQxNDA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/josibake",
            "html_url": "https://github.com/josibake",
            "followers_url": "https://api.github.com/users/josibake/followers",
            "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
            "organizations_url": "https://api.github.com/users/josibake/orgs",
            "repos_url": "https://api.github.com/users/josibake/repos",
            "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/josibake/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "OWNER",
          "locked": false,
          "comments": 3,
          "pull_request": {
            "url": "https://api.github.com/repos/josibake/bips/pulls/1",
            "html_url": "https://github.com/josibake/bips/pull/1",
            "diff_url": "https://github.com/josibake/bips/pull/1.diff",
            "patch_url": "https://github.com/josibake/bips/pull/1.patch"
          },
          "closed_at": "2023-06-05T16:26:37Z",
          "created_at": "2023-03-16T10:50:03Z",
          "updated_at": "2023-06-14T00:54:51Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-05T16:37:00Z",
      "updated_at": "2023-06-05T16:37:00Z",
      "source": {
        "issue": {
          "id": 1741647494,
          "node_id": "PR_kwDOABII585SMBHD",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27827",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27827/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27827/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27827/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/27827",
          "number": 27827,
          "state": "open",
          "state_reason": null,
          "title": "Silent Payments: send and receive",
          "body": "## For reviewers\r\n\r\nIn an attempt to make reviewing a bit more sane, I'm breaking this up into a few smaller PRs, but will keep this one open as the parent PR and keep it rebased on the child PRs. The main purpose of having this PR is to track progress on child PRs and also have an easy way to compile `bitcoind` with both send and receive support for testing. Additionally, I'll be adding more functional tests to this PR since it's much easier to test when `bitcoind` can both send and receive.\r\n\r\n## PRs\r\n\r\n- [ ] https://github.com/bitcoin/bitcoin/pull/28122\r\n  - Implements the logic from BIP352 without any wallet code. This PR adds the necessary cryptographic functions and implements the logic needed for sending and scanning. This PR also includes the test vectors from the BIP as unit tests. Both the send and receive PRs have this as a dependency. In terms of priority, this PR should be reviewed first\r\n- [ ] https://github.com/bitcoin/bitcoin/pull/28201\r\n  - Implements sending in the Bitcoin Core wallet. This PR allows a wallet to send to a silent payment address, regardless of whether or not the wallet can receive silent payments\r\n  - Ready for review, but marked as a draft until dependencies are merged\r\n- [ ] https://github.com/bitcoin/bitcoin/pull/28202\r\n  - Implements receiving in the Bitcoin Core wallet. This PR allows a wallet to generate silent payment addresses and scan for silent payments, regardless of whether or not the wallet can send to a silent payment address\r\n  - Ready for review but marked as a draft until dependencies are merged\r\n\r\nFor the silent payments specification, see https://github.com/bitcoin/bips/pull/1458\r\n\r\n## Overall\r\n\r\nThis PR implements the full silent payments scheme: sending and receiving. The following items are not covered in this PR and are intended for follow-up PRs:\r\n\r\n* Adding labels for the receiver wallet\r\n* Full RPC coverage (only `sendtoaddress` and `sendmany` are covered in this PR)\r\n* Light client support (vending the tweak data per block, either in an index or to serve to indexer, such as electrum server)\r\n* Add benchmarks to validate that there are no DoS concerns for doing silent payment verification for transactions in the mempool\r\n* External signer support (dependent on hardware wallets supporting silent payments)\r\n* More unit / functional test coverage\r\n\r\n## Major changes\r\n\r\nThis PR is a continuation of the work done in https://github.com/bitcoin/bitcoin/pull/24897. Below is a summary of the major changes:\r\n\r\n* Remove labels\r\n  * The original draft included labels, but this has been deferred for a later PR. Labels are not necessary for sending and receiving and there are still some open questions on how best to implement them in Bitcoin Core. Labels can also be added at any point by the receiver without requiring any changes from the sender\r\n* Remove indexes\r\n  * In the original draft, indexes were used when scanning for silent payments and when doing wallet rescans. This has been removed in favor of using `rev*.dat` files for rescanning. It may make sense to add an index in the future, but for the purpose of vending tweak data to light clients, which is still an open question\r\n* Update to implement the most current version of BIP352\r\n  * Since the original draft, there have been a few changes in the BIP which are reflected in the current PR. Most notably, using 33-byte compressed keys for the silent payment address (as opposed to X-only keys in the original draft) \r\n\r\nIt may be helpful for context to read through the discussions on #24897 , but ongoing review should happen in the relevant child PRs listed above.",
          "user": {
            "login": "josibake",
            "id": 7444140,
            "node_id": "MDQ6VXNlcjc0NDQxNDA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/josibake",
            "html_url": "https://github.com/josibake",
            "followers_url": "https://api.github.com/users/josibake/followers",
            "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
            "organizations_url": "https://api.github.com/users/josibake/orgs",
            "repos_url": "https://api.github.com/users/josibake/repos",
            "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/josibake/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 5,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27827",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/27827",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/27827.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/27827.patch"
          },
          "created_at": "2023-06-05T12:12:23Z",
          "updated_at": "2023-09-11T22:27:09Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1463200093,
      "node_id": "PRR_kwDOAN28mc5XNqld",
      "url": null,
      "actor": null,
      "commit_id": "f0ccab189ef1481c36c11908d6f675086c183283",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1463200093",
      "submitted_at": "2023-06-05T19:00:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9446210040,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAIzCbn4",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9446210040",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-06T13:15:53Z"
    },
    {
      "event": "reviewed",
      "id": 1466163601,
      "node_id": "PRR_kwDOAN28mc5XY-GR",
      "url": null,
      "actor": null,
      "commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Glad to see this proposal advancing! I think with some minor changes it can be compatible with MuSig2 Taproot Keypaths (and potentially other off chain key aggregation schemes), which make it a powerful way of transacting privately even between users with advanced keys and scripts on Taproot.",
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1466163601",
      "submitted_at": "2023-06-06T21:49:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "reviewed",
      "id": 1468505256,
      "node_id": "PRR_kwDOAN28mc5Xh5yo",
      "url": null,
      "actor": null,
      "commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Some light review so far, but I'm really liking the proposal. Being able to easily implement just the sending part will no doubt greatly accelerate adoption by wallets.\r\n\r\nApart from the inline comments I also have a few style nits:\r\n* \"e.g\" is used instead of \"e.g.\" in a few places.\r\n* Mixed usage of curly (`’`) and straight (`'`) single quotes.\r\n* Some footnotes (\"Rationale and References\") are missing a period at the end.\r\n* In Creating outputs, \"Let _a_ = _a<sub>0</sub>_ + _a<sub>1</sub>_ + … _a<sub>i</sub>_, where each _a<sub>i</sub>_\" should have _a<sub>n</sub>_ be the last member of the sum, like in the rest of the document. Same goes for the sum in Scanning where the last member should be _A<sub>n</sub>_.",
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1468505256",
      "submitted_at": "2023-06-07T20:38:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9469889707,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAI0cwyr",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9469889707",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-08T09:21:06Z"
    },
    {
      "event": "commented",
      "id": 1582210838,
      "node_id": "IC_kwDOAN28mc5eTp8W",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1582210838",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-08T09:25:01Z",
      "updated_at": "2023-06-08T09:25:01Z",
      "author_association": "NONE",
      "body": "Thanks for the review, @vostrnad !\r\n\r\n> Apart from the inline comments I also have a few style nits:\r\n\r\nThese should all be fixed now in https://github.com/bitcoin/bips/pull/1458/commits/1ae1b4bf80bc21911fbd90033edd8006d5e6b592",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1582210838",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "mentioned",
      "id": 9469927695,
      "node_id": "MEE_lADOAN28mc5n1phizwAAAAI0c6EP",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9469927695",
      "actor": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-08T09:25:01Z"
    },
    {
      "event": "subscribed",
      "id": 9469927710,
      "node_id": "SE_lADOAN28mc5n1phizwAAAAI0c6Ee",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9469927710",
      "actor": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-08T09:25:01Z"
    },
    {
      "event": "reviewed",
      "id": 1473991698,
      "node_id": "PRR_kwDOAN28mc5X21QS",
      "url": null,
      "actor": null,
      "commit_id": "1ae1b4bf80bc21911fbd90033edd8006d5e6b592",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1473991698",
      "submitted_at": "2023-06-12T03:47:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "reviewed",
      "id": 1478071840,
      "node_id": "PRR_kwDOAN28mc5YGZYg",
      "url": null,
      "actor": null,
      "commit_id": "1ae1b4bf80bc21911fbd90033edd8006d5e6b592",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1478071840",
      "submitted_at": "2023-06-13T21:21:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9526738478,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAI31n4u",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9526738478",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-14T10:36:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9527985664,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAI36YYA",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9527985664",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-14T12:35:30Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9528007008,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAI36dlg",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9528007008",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-14T12:37:31Z"
    },
    {
      "event": "reviewed",
      "id": 1480480680,
      "node_id": "PRR_kwDOAN28mc5YPleo",
      "url": null,
      "actor": null,
      "commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Second round of review. To complement this I wrote a quick and dirty implementation covering most of both sending and receiving. It was quite easy and seems to work, can't wait for test vectors to see how many bugs it has! 😅 \r\n\r\nIn addition to the inline comments I have one general comment and one style nit:\r\n* There are no specifics on how to deal with situations where EC operations fail to produce a valid point. I'm not sure if this is necessary, just mentioning this because my implementation has a lot of assertions.\r\n* Tweak expressions are not consistent in whether the _G_ part comes first or second. For example, in BIP341 it always comes second.",
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1480480680",
      "submitted_at": "2023-06-15T00:25:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "reviewed",
      "id": 1480862636,
      "node_id": "PRR_kwDOAN28mc5YRCus",
      "url": null,
      "actor": null,
      "commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "Khademr7",
        "id": 136660714,
        "node_id": "U_kgDOCCVG6g",
        "avatar_url": "https://avatars.githubusercontent.com/u/136660714?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Khademr7",
        "html_url": "https://github.com/Khademr7",
        "followers_url": "https://api.github.com/users/Khademr7/followers",
        "following_url": "https://api.github.com/users/Khademr7/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Khademr7/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Khademr7/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Khademr7/subscriptions",
        "organizations_url": "https://api.github.com/users/Khademr7/orgs",
        "repos_url": "https://api.github.com/users/Khademr7/repos",
        "events_url": "https://api.github.com/users/Khademr7/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Khademr7/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1480862636",
      "submitted_at": "2023-06-15T07:19:50Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "unsubscribed",
      "id": 9536648231,
      "node_id": "UE_lADOAN28mc5n1phizwAAAAI4bbQn",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9536648231",
      "actor": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-15T07:24:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9538248004,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAI4hh1E",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9538248004",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-15T09:50:02Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9538465448,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAI4iW6o",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9538465448",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-15T10:10:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9538709793,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAI4jSkh",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9538709793",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-15T10:35:32Z"
    },
    {
      "event": "commented",
      "id": 1592803489,
      "node_id": "IC_kwDOAN28mc5e8ECh",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1592803489",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-15T10:44:19Z",
      "updated_at": "2023-06-15T10:44:19Z",
      "author_association": "NONE",
      "body": "Thanks for the continued review, @vostrnad ! \r\n\r\n> There are no specifics on how to deal with situations where EC operations fail to produce a valid point. I'm not sure if this is necessary, just mentioning this because my implementation has a lot of assertions.\r\n\r\nDo you have a specific scenario in mind? I'm certainly not an expert in this area, but I don't think we should get a failure by doing additions and multiplications (summing priv keys, pub keys, ecdh). If we _can_ have a failure when summing up the private keys, public keys, or during the ECDH step, our only recourse would be to restart the coin selection process and ensure we get different inputs.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1592803489",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "mentioned",
      "id": 9538791737,
      "node_id": "MEE_lADOAN28mc5n1phizwAAAAI4jmk5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9538791737",
      "actor": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-15T10:44:19Z"
    },
    {
      "event": "subscribed",
      "id": 9538791752,
      "node_id": "SE_lADOAN28mc5n1phizwAAAAI4jmlI",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9538791752",
      "actor": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-15T10:44:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9539932665,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAI4n9H5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9539932665",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-15T12:37:41Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9539970391,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAI4oGVX",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9539970391",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-15T12:41:21Z"
    },
    {
      "event": "commented",
      "id": 1593429977,
      "node_id": "IC_kwDOAN28mc5e-c_Z",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1593429977",
      "actor": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-15T17:00:11Z",
      "updated_at": "2023-06-15T17:00:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "> I don't think we should get a failure by doing additions and multiplications (summing priv keys, pub keys, ecdh)\r\n\r\nOne reason EC operations can fail is when a pseudorandom scalar value exceeds the curve order, which should only happen with negligible probability but other BIPs still have special cases for when it happens (e.g. BIP32, BIP340 and BIP341). I suppose it could be fine to ignore this, but I'm certainly no expert either.\r\n\r\n",
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1593429977",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "reviewed",
      "id": 1482062692,
      "node_id": "PRR_kwDOAN28mc5YVntk",
      "url": null,
      "actor": null,
      "commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1482062692",
      "submitted_at": "2023-06-15T17:11:54Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9550140779,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAI5O5Vr",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9550140779",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-16T11:07:16Z"
    },
    {
      "event": "commented",
      "id": 1594509862,
      "node_id": "IC_kwDOAN28mc5fCkom",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1594509862",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-16T11:09:36Z",
      "updated_at": "2023-06-16T11:09:36Z",
      "author_association": "NONE",
      "body": "> > I don't think we should get a failure by doing additions and multiplications (summing priv keys, pub keys, ecdh)\r\n> \r\n> One reason EC operations can fail is when a pseudorandom scalar value exceeds the curve order, which should only happen with negligible probability but other BIPs still have special cases for when it happens (e.g. BIP32, BIP340 and BIP341). I suppose it could be fine to ignore this, but I'm certainly no expert either.\r\n\r\nI'll take a look to see how it's being handled in those BIPs. Ideally, we can reuse the same solution here. The main thing is ensuring both the sender and receiver can deterministically handle these low-probability events.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1594509862",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "reviewed",
      "id": 1484526159,
      "node_id": "PRR_kwDOAN28mc5YfBJP",
      "url": null,
      "actor": null,
      "commit_id": "d920133138dc587238f58dc266409f7f7fe0fe7b",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1484526159",
      "submitted_at": "2023-06-16T22:47:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "commented",
      "id": 1597917780,
      "node_id": "IC_kwDOAN28mc5fPkpU",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1597917780",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T00:49:31Z",
      "updated_at": "2023-06-20T00:49:31Z",
      "author_association": "MEMBER",
      "body": "@luke-jr Unless you see anything objectionable, please assign BIP number.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1597917780",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "mentioned",
      "id": 9573545524,
      "node_id": "MEE_lADOAN28mc5n1phizwAAAAI6oLY0",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9573545524",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T00:49:31Z"
    },
    {
      "event": "subscribed",
      "id": 9573545533,
      "node_id": "SE_lADOAN28mc5n1phizwAAAAI6oLY9",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9573545533",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T00:49:31Z"
    },
    {
      "event": "commented",
      "id": 1598832940,
      "node_id": "IC_kwDOAN28mc5fTEEs",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1598832940",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T13:51:03Z",
      "updated_at": "2023-06-20T13:51:03Z",
      "author_association": "NONE",
      "body": "@vostrnad \r\n\r\n> One reason EC operations can fail is when a pseudorandom scalar value exceeds the curve order, which should only happen with negligible probability but other BIPs still have special cases for when it happens (e.g. BIP32, BIP340 and BIP341). I suppose it could be fine to ignore this, but I'm certainly no expert either.\r\n\r\nI did some more reading on this and from what I can tell this applies to choosing a scalar which results in a valid point on the curve, which is not true for every scalar. In our case, we are already using existing valid private keys or, in the case of the silent payment address, are using BIP32 to generate them. Adding these keys together (using the elliptic curve group operation) or multiplying a valid scalar with a point (ECDH) gives us a result that is guaranteed to be a valid point on the curve.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1598832940",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "mentioned",
      "id": 9579980240,
      "node_id": "MEE_lADOAN28mc5n1phizwAAAAI7AuXQ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9579980240",
      "actor": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T13:51:03Z"
    },
    {
      "event": "subscribed",
      "id": 9579980264,
      "node_id": "SE_lADOAN28mc5n1phizwAAAAI7AuXo",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9579980264",
      "actor": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-20T13:51:04Z"
    },
    {
      "event": "commented",
      "id": 1602734050,
      "node_id": "IC_kwDOAN28mc5fh8fi",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1602734050",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-22T14:23:42Z",
      "updated_at": "2023-06-22T14:23:42Z",
      "author_association": "NONE",
      "body": "> we are already using existing valid private keys\r\n\r\n@vostrnad Actually, what I said above is not true and  your point stands. When we do _t<sub>n</sub> = hash(ecdh_shared_secret || n)_ and then multiply by _G_, we might get an invalid point, so we should include a step on how to handle this. Will update.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1602734050",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "mentioned",
      "id": 9607346435,
      "node_id": "MEE_lADOAN28mc5n1phizwAAAAI8pHkD",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9607346435",
      "actor": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-22T14:23:42Z"
    },
    {
      "event": "subscribed",
      "id": 9607346449,
      "node_id": "SE_lADOAN28mc5n1phizwAAAAI8pHkR",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9607346449",
      "actor": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-22T14:23:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9650596494,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAI_OGqO",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9650596494",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-27T11:06:12Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9650643154,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAI_OSDS",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9650643154",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-27T11:09:46Z"
    },
    {
      "event": "renamed",
      "id": 9679342043,
      "node_id": "RTE_lADOAN28mc5n1phizwAAAAJA7wnb",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9679342043",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-29T16:36:57Z",
      "rename": {
        "from": "BIP for Silent Payments",
        "to": "BIP 352: Silent Payments"
      }
    },
    {
      "event": "commented",
      "id": 1613507274,
      "node_id": "IC_kwDOAN28mc5gLCrK",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1613507274",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-29T16:37:08Z",
      "updated_at": "2023-06-29T16:37:08Z",
      "author_association": "MEMBER",
      "body": "Assigned BIP number 352",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1613507274",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "labeled",
      "id": 9680077227,
      "node_id": "LE_lADOAN28mc5n1phizwAAAAJA-kGr",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9680077227",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-29T18:16:49Z",
      "label": {
        "name": "New BIP",
        "color": "5319e7"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9711819458,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJC3prC",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9711819458",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-03T17:14:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9711849131,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJC3w6r",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9711849131",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-03T17:17:36Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9711869269,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJC311V",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9711869269",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-03T17:19:44Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9711891447,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJC37P3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9711891447",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-03T17:22:08Z"
    },
    {
      "event": "commented",
      "id": 1618920413,
      "node_id": "IC_kwDOAN28mc5gfsPd",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1618920413",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-03T17:28:54Z",
      "updated_at": "2023-07-03T17:28:54Z",
      "author_association": "NONE",
      "body": "I've added a reference Python implementation along with test vectors for sending and receiving. I'll be updating the \"Appendix B: Test Vectors\" section shortly.",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1618920413",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9717495524,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJDNTbk",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9717495524",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-04T06:29:58Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9718038021,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJDPX4F",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9718038021",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-04T07:22:53Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9718340757,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJDQhyV",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9718340757",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-04T07:50:46Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9718449073,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJDQ8Ox",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9718449073",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-04T08:00:03Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9740847254,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJEmYiW",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9740847254",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-06T08:17:30Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9740914044,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJEmo18",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9740914044",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-06T08:24:18Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9740949029,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJEmxYl",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9740949029",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-06T08:27:44Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9741016000,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJEnBvA",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9741016000",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-06T08:34:29Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9741034368,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJEnGOA",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9741034368",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-06T08:36:24Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9741082474,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJEnR9q",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9741082474",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-06T08:41:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9742933589,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJEuV5V",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9742933589",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-06T11:52:36Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9743017631,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJEuqaf",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9743017631",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-06T12:01:18Z"
    },
    {
      "event": "reviewed",
      "id": 1516397718,
      "node_id": "PRR_kwDOAN28mc5aYmSW",
      "url": null,
      "actor": null,
      "commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "We've been polishing this like crazy, but still noticed one important issue: we'll need to be more explicit about when a tx isn't SP eligible with regards to soft forks and actively take this into account during transaction creation.",
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1516397718",
      "submitted_at": "2023-07-06T14:00:26Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9770666766,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJGYIsO",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9770666766",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-10T06:41:34Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9770796349,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJGYoU9",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9770796349",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-10T06:53:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9775902065,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJGsG1x",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9775902065",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-10T14:46:47Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9775927392,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJGsNBg",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9775927392",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-10T14:48:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9776438376,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJGuJxo",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9776438376",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-10T15:29:22Z"
    },
    {
      "event": "commented",
      "id": 1630498315,
      "node_id": "IC_kwDOAN28mc5hL24L",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1630498315",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-11T09:41:30Z",
      "updated_at": "2023-07-11T09:41:30Z",
      "author_association": "NONE",
      "body": "There was a suggestion to use [BIP21](https://github.com/bitcoin/bips/blob/master/bip-0021.mediawiki) for silent payments instead of introducing a new address format, the reasoning being introducing yet another address format is a burden on wallet developers. I looked into this a bit, and here's my thinking:\r\n\r\n#### Case 1:  `bitcoin:bc1pspendpublickey?sp=0x02scanpublickey`\r\n\r\n The \"address\" is the spend public key encoded as a taproot address and an `sp=` extension is added which contains the scan public key. Wallets that understand the `sp=` extension make a silent payment using both keys, wallets that don't skip the extension and send the funds to the spend public key. You can argue that this is no worse than people posting a static address today, with the option to receive funds more privately if the sender understands silent payments. I disagree for the following reasons:\r\n\r\n* **Encourages address reuse**: a receiver who did not previously have a static address posted will now post a static address as a fallback to receive silent payments. Encouraging users to post a static address is an anti-pattern, as *increases* the amount of address reuse, which is exactly what we want to avoid\r\n* **Damages the privacy of users who do support sending silent payments**: Bob receives a payment from Alice, where Alice's wallet doesn't understand the `sp=` extension, so she sends it to his spend public key. Everyone can see that Bob received a payment to his silent payment address. Carol sends a payment to Bob as a silent payment. Bob then spends the UTXO from Alice and the UTXO from Carol together, effectively linking Carol's transaction to Bob's silent payment address. \r\n\r\n#### Case 2:  `bitcoin:bc1pxxx?sp=0x02spendpublickey0x03scanpublickey`\r\n\r\nThe address is a static bitcoin address and the `sp=` param contains the spend and scan public key. The same critiques of case 1 apply in this case, as well.\r\n\r\n#### Case 3: bitcoin:bc1pxxx?r-sp=0x02spendpublickey0x03scanpublickey\r\n\r\nBy adding `r-` to the param, we make the extension required. This is the same as introducing a new address format: either wallets support sending to it, or the payment fails. I don't see any benefits of using BIP21 over introducing a new address in this case.\r\n\r\n#### Proposed solution\r\n\r\nKeep the `sp1qxxx` bech32m encoding and add it to BIP21 once there is widespread support for sending to silent payment addresses and something like BOLT12. This would allow us to construct a static payment code URI like `bitcoin:sp1qxxx?lightning=lno1pg257enxv4ezqcneype82um50ynhxgrwdajx283qfwdpl28qqmc78ymlvhmxcsywdk5wrjnj36jryg488qwlrnzyjczs`, where the wallet first uses the bolt12 offer and falls back to a silent payment address. While I agree that introducing a new address format isn't ideal, I don't see a way to introduce a reusable payment code protocol without specifying a new address type. This was also mentioned in the design of [BIP173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#cite_note-6). Reusing bech32m does a lot to alleviate the address format fatigue in that any wallet wanting to send to a silent payment address needs to be able to create taproot outputs, so they will already have bech32m encoding and decoding logic. We've also made the silent payment address forward compatible with new silent payment versions, so ideally this format is the one-and-done reusable payment code format.\r\n\r\ncc @TheBlueMatt, in case I've missed something or misrepresented the arguments.\r\n\r\n\r\n",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1630498315",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "mentioned",
      "id": 9785096329,
      "node_id": "MEE_lADOAN28mc5n1phizwAAAAJHPLiJ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9785096329",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-11T09:41:31Z"
    },
    {
      "event": "subscribed",
      "id": 9785096349,
      "node_id": "SE_lADOAN28mc5n1phizwAAAAJHPLid",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9785096349",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-11T09:41:31Z"
    },
    {
      "event": "reviewed",
      "id": 1533812027,
      "node_id": "PRR_kwDOAN28mc5bbB07",
      "url": null,
      "actor": null,
      "commit_id": "3530d9837b08935d26dd99f38d1981d47227fadb",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1533812027",
      "submitted_at": "2023-07-17T22:49:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-21T18:36:38Z",
      "updated_at": "2023-07-21T18:36:38Z",
      "source": {
        "issue": {
          "id": 1816230792,
          "node_id": "PR_kwDOABII585WHu-Q",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28122",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28122/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28122/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28122/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/28122",
          "number": 28122,
          "state": "open",
          "state_reason": null,
          "title": "Silent Payments: Implement BIP352",
          "body": "UPDATE: Rather than having a special encoder and decoder for silent payments, it makes more sense to have `CTxDestination` include a `V0SilentPaymentDestination` type. Some pre-work to make this easier is done in https://github.com/bitcoin/bitcoin/pull/28246 , which this PR now depends on. If you want to review this PR, please review these two first.\r\n\r\n<hr/>\r\n\r\nThis PR is a child of https://github.com/bitcoin/bitcoin/pull/27827 and only implements the BIP logic without the wallet code. For the wallet implementations:\r\n* #28201 - implements sending\r\n* #28202 - implements receiving\r\n* #27827 - all three PRs together - this PR is meant for tracking progress and is useful for reviewers who want to compile all three PRs at once for testing\r\n\r\n## BIP352\r\n\r\nThis PR focuses strictly on the BIP logic and attempts to separate it from the wallet and transaction implementation details. This is accomplished by working directly with public and private keys, instead of needing a wallet backend and transactions for testing. Labels for the receiver are optional and thus deferred for a later PR.\r\n\r\nTest vectors from the BIP are included as unit tests.\r\n\r\nBefore reviewing, it is strongly recommended you read https://github.com/bitcoin/bips/pull/1458 and take a look at the reference python implementation on the BIP.\r\n",
          "user": {
            "login": "josibake",
            "id": 7444140,
            "node_id": "MDQ6VXNlcjc0NDQxNDA=",
            "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/josibake",
            "html_url": "https://github.com/josibake",
            "followers_url": "https://api.github.com/users/josibake/followers",
            "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
            "organizations_url": "https://api.github.com/users/josibake/orgs",
            "repos_url": "https://api.github.com/users/josibake/repos",
            "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/josibake/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 18,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28122",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/28122",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/28122.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/28122.patch"
          },
          "created_at": "2023-07-21T18:36:37Z",
          "updated_at": "2023-09-12T10:50:39Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1542112568,
      "node_id": "PRR_kwDOAN28mc5b6sU4",
      "url": null,
      "actor": null,
      "commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1542112568",
      "submitted_at": "2023-07-22T15:59:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "reviewed",
      "id": 1544991408,
      "node_id": "PRR_kwDOAN28mc5cFrKw",
      "url": null,
      "actor": null,
      "commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1544991408",
      "submitted_at": "2023-07-25T09:08:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "PulpCattel",
        "id": 51127079,
        "node_id": "MDQ6VXNlcjUxMTI3MDc5",
        "avatar_url": "https://avatars.githubusercontent.com/u/51127079?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/PulpCattel",
        "html_url": "https://github.com/PulpCattel",
        "followers_url": "https://api.github.com/users/PulpCattel/followers",
        "following_url": "https://api.github.com/users/PulpCattel/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/PulpCattel/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/PulpCattel/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/PulpCattel/subscriptions",
        "organizations_url": "https://api.github.com/users/PulpCattel/orgs",
        "repos_url": "https://api.github.com/users/PulpCattel/repos",
        "events_url": "https://api.github.com/users/PulpCattel/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/PulpCattel/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-26T10:17:44Z",
      "updated_at": "2023-07-26T10:17:44Z",
      "source": {
        "issue": {
          "id": 1822073779,
          "node_id": "I_kwDOBHDNDc5smqOz",
          "url": "https://api.github.com/repos/JoinMarket-Org/joinmarket-clientserver/issues/1511",
          "repository_url": "https://api.github.com/repos/JoinMarket-Org/joinmarket-clientserver",
          "labels_url": "https://api.github.com/repos/JoinMarket-Org/joinmarket-clientserver/issues/1511/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/JoinMarket-Org/joinmarket-clientserver/issues/1511/comments",
          "events_url": "https://api.github.com/repos/JoinMarket-Org/joinmarket-clientserver/issues/1511/events",
          "html_url": "https://github.com/JoinMarket-Org/joinmarket-clientserver/issues/1511",
          "number": 1511,
          "state": "open",
          "state_reason": null,
          "title": "Feature: Silent Payments",
          "body": "To keep track of [BIP 352: Silent Payments](https://github.com/bitcoin/bips/pull/1458). It seems a natural fit for JoinMarket.\r\n\r\nBitcoin Core PR: https://github.com/bitcoin/bitcoin/pull/27827",
          "user": {
            "login": "PulpCattel",
            "id": 51127079,
            "node_id": "MDQ6VXNlcjUxMTI3MDc5",
            "avatar_url": "https://avatars.githubusercontent.com/u/51127079?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/PulpCattel",
            "html_url": "https://github.com/PulpCattel",
            "followers_url": "https://api.github.com/users/PulpCattel/followers",
            "following_url": "https://api.github.com/users/PulpCattel/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/PulpCattel/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/PulpCattel/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/PulpCattel/subscriptions",
            "organizations_url": "https://api.github.com/users/PulpCattel/orgs",
            "repos_url": "https://api.github.com/users/PulpCattel/repos",
            "events_url": "https://api.github.com/users/PulpCattel/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/PulpCattel/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 486873887,
              "node_id": "MDU6TGFiZWw0ODY4NzM4ODc=",
              "url": "https://api.github.com/repos/JoinMarket-Org/joinmarket-clientserver/labels/enhancement",
              "name": "enhancement",
              "color": "84b6eb",
              "default": true
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 0,
          "created_at": "2023-07-26T10:17:44Z",
          "updated_at": "2023-07-26T10:17:44Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1548288232,
      "node_id": "PRR_kwDOAN28mc5cSQDo",
      "url": null,
      "actor": null,
      "commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1548288232",
      "submitted_at": "2023-07-26T17:45:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "subscribed",
      "id": 9947373285,
      "node_id": "SE_lADOAN28mc5n1phizwAAAAJQ6N7l",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9947373285",
      "actor": {
        "login": "ubbabeck",
        "id": 36157890,
        "node_id": "MDQ6VXNlcjM2MTU3ODkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/36157890?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ubbabeck",
        "html_url": "https://github.com/ubbabeck",
        "followers_url": "https://api.github.com/users/ubbabeck/followers",
        "following_url": "https://api.github.com/users/ubbabeck/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ubbabeck/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ubbabeck/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ubbabeck/subscriptions",
        "organizations_url": "https://api.github.com/users/ubbabeck/orgs",
        "repos_url": "https://api.github.com/users/ubbabeck/repos",
        "events_url": "https://api.github.com/users/ubbabeck/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ubbabeck/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-28T12:05:24Z"
    },
    {
      "event": "reviewed",
      "id": 1554517375,
      "node_id": "PRR_kwDOAN28mc5cqA1_",
      "url": null,
      "actor": null,
      "commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1554517375",
      "submitted_at": "2023-07-31T11:02:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9967321299,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJSGUDT",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9967321299",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-31T18:11:26Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9973572186,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJSeKJa",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9973572186",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T08:39:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9973940731,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJSfkH7",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9973940731",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T09:12:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9974027359,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJSf5Rf",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9974027359",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T09:20:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9975749668,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJSmdwk",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9975749668",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-01T12:09:14Z"
    },
    {
      "event": "reviewed",
      "id": 1559199327,
      "node_id": "PRR_kwDOAN28mc5c735f",
      "url": null,
      "actor": null,
      "commit_id": "64da95202f79e470f22571953622a7ea90a5fdf8",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1559199327",
      "submitted_at": "2023-08-02T15:26:31Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9998324534,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJT8lM2",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9998324534",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-03T12:15:40Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9998353632,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJT8sTg",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9998353632",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-03T12:18:18Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9998416501,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJT87p1",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9998416501",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-03T12:24:29Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9998445000,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJT9CnI",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9998445000",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-03T12:27:31Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9998453589,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJT9EtV",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9998453589",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-03T12:28:27Z"
    },
    {
      "event": "reviewed",
      "id": 1561906506,
      "node_id": "PRR_kwDOAN28mc5dGM1K",
      "url": null,
      "actor": null,
      "commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Doing another pass of review. This time it's mostly nits which I take to be a good sign.\r\n\r\nSome general style nits:\r\n* Mixed usage of `…` and `...`.\r\n* Declarations that use `…` with a repeated operation should have the operation symbol appear [on both sides of the ellipsis](https://en.wikipedia.org/wiki/Ellipsis#In_mathematical_notation), but one of them is sometimes missing. (e.g. _a<sub>1</sub> … + a<sub>n</sub>_ should be changed to _a<sub>1</sub> + … + a<sub>n</sub>_)\r\n",
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1561906506",
      "submitted_at": "2023-08-03T21:55:36Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10006689709,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJUcfet",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10006689709",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-04T08:11:55Z"
    },
    {
      "event": "commented",
      "id": 1665978555,
      "node_id": "IC_kwDOAN28mc5jTNC7",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1665978555",
      "actor": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-04T17:51:22Z",
      "updated_at": "2023-08-04T17:51:22Z",
      "author_association": "CONTRIBUTOR",
      "body": "NACK without fixing the lack of an expiration time.\r\n\r\nRational: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-August/021849.html\r\n\r\nIMO better to discuss this issue on the bitcoin-dev mailing list, as it's relevant to all potential new address formats.",
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1665978555",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "reviewed",
      "id": 1564165333,
      "node_id": "PRR_kwDOAN28mc5dO0TV",
      "url": null,
      "actor": null,
      "commit_id": "478a5c54eae35a8fb54300a564d83c73cacf9ba1",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "bitcoinfinancier",
        "id": 134175231,
        "node_id": "U_kgDOB_9Z_w",
        "avatar_url": "https://avatars.githubusercontent.com/u/134175231?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoinfinancier",
        "html_url": "https://github.com/bitcoinfinancier",
        "followers_url": "https://api.github.com/users/bitcoinfinancier/followers",
        "following_url": "https://api.github.com/users/bitcoinfinancier/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoinfinancier/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoinfinancier/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoinfinancier/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoinfinancier/orgs",
        "repos_url": "https://api.github.com/users/bitcoinfinancier/repos",
        "events_url": "https://api.github.com/users/bitcoinfinancier/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoinfinancier/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1564165333",
      "submitted_at": "2023-08-06T14:59:47Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "reviewed",
      "id": 1564263806,
      "node_id": "PRR_kwDOAN28mc5dPMV-",
      "url": null,
      "actor": null,
      "commit_id": "478a5c54eae35a8fb54300a564d83c73cacf9ba1",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1564263806",
      "submitted_at": "2023-08-06T22:20:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "rezaeghbal01",
        "id": 87917112,
        "node_id": "MDQ6VXNlcjg3OTE3MTEy",
        "avatar_url": "https://avatars.githubusercontent.com/u/87917112?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rezaeghbal01",
        "html_url": "https://github.com/rezaeghbal01",
        "followers_url": "https://api.github.com/users/rezaeghbal01/followers",
        "following_url": "https://api.github.com/users/rezaeghbal01/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/rezaeghbal01/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/rezaeghbal01/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/rezaeghbal01/subscriptions",
        "organizations_url": "https://api.github.com/users/rezaeghbal01/orgs",
        "repos_url": "https://api.github.com/users/rezaeghbal01/repos",
        "events_url": "https://api.github.com/users/rezaeghbal01/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/rezaeghbal01/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-07T07:34:16Z",
      "updated_at": "2023-08-07T07:34:16Z",
      "source": {
        "issue": {
          "id": 1838864959,
          "node_id": "I_kwDOAOvK985tmto_",
          "url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27870",
          "repository_url": "https://api.github.com/repos/ethereum/go-ethereum",
          "labels_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27870/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27870/comments",
          "events_url": "https://api.github.com/repos/ethereum/go-ethereum/issues/27870/events",
          "html_url": "https://github.com/ethereum/go-ethereum/issues/27870",
          "number": 27870,
          "state": "closed",
          "state_reason": "completed",
          "title": "spam",
          "body": null,
          "user": {
            "login": "rezaeghbal01",
            "id": 87917112,
            "node_id": "MDQ6VXNlcjg3OTE3MTEy",
            "avatar_url": "https://avatars.githubusercontent.com/u/87917112?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/rezaeghbal01",
            "html_url": "https://github.com/rezaeghbal01",
            "followers_url": "https://api.github.com/users/rezaeghbal01/followers",
            "following_url": "https://api.github.com/users/rezaeghbal01/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/rezaeghbal01/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/rezaeghbal01/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/rezaeghbal01/subscriptions",
            "organizations_url": "https://api.github.com/users/rezaeghbal01/orgs",
            "repos_url": "https://api.github.com/users/rezaeghbal01/repos",
            "events_url": "https://api.github.com/users/rezaeghbal01/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/rezaeghbal01/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 0,
          "closed_at": "2023-08-07T07:40:16Z",
          "created_at": "2023-08-07T07:34:16Z",
          "updated_at": "2023-08-07T07:41:03Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1566215297,
      "node_id": "PRR_kwDOAN28mc5dWoyB",
      "url": null,
      "actor": null,
      "commit_id": "478a5c54eae35a8fb54300a564d83c73cacf9ba1",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "cygnet3",
        "id": 131168104,
        "node_id": "U_kgDOB9F3aA",
        "avatar_url": "https://avatars.githubusercontent.com/u/131168104?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cygnet3",
        "html_url": "https://github.com/cygnet3",
        "followers_url": "https://api.github.com/users/cygnet3/followers",
        "following_url": "https://api.github.com/users/cygnet3/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cygnet3/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cygnet3/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cygnet3/subscriptions",
        "organizations_url": "https://api.github.com/users/cygnet3/orgs",
        "repos_url": "https://api.github.com/users/cygnet3/repos",
        "events_url": "https://api.github.com/users/cygnet3/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cygnet3/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1566215297",
      "submitted_at": "2023-08-07T22:16:58Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "commented",
      "id": 1669991489,
      "node_id": "IC_kwDOAN28mc5jigxB",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1669991489",
      "actor": {
        "login": "cygnet3",
        "id": 131168104,
        "node_id": "U_kgDOB9F3aA",
        "avatar_url": "https://avatars.githubusercontent.com/u/131168104?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cygnet3",
        "html_url": "https://github.com/cygnet3",
        "followers_url": "https://api.github.com/users/cygnet3/followers",
        "following_url": "https://api.github.com/users/cygnet3/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cygnet3/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cygnet3/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cygnet3/subscriptions",
        "organizations_url": "https://api.github.com/users/cygnet3/orgs",
        "repos_url": "https://api.github.com/users/cygnet3/repos",
        "events_url": "https://api.github.com/users/cygnet3/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cygnet3/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-08T17:03:22Z",
      "updated_at": "2023-08-08T17:03:22Z",
      "author_association": "NONE",
      "body": "Regarding the test vectors: I think it is best to remove the 'amount' values from the sending tests.\r\n\r\nPayment amounts don't test any logic about silent payments directly. Rather, they are indirectly used for the following two purposes:\r\n\r\n1) to match generated taproot outputs with a specific recipient (because all the amounts are unique)\r\n2) to ensure determinism in testing (sorting on amounts for every silent payment group)\r\n\r\nIn other words, they are used as a sort-able unique identifier for each recipient.\r\n\r\nBoth of these goals can be achieved in another way:\r\n\r\n1) For the sending outputs, expect a dictionary object instead, where the key is a recipient (bech32m string representing a silent payment address), and the value is a list of taproot outputs  (hex encoding of 32-byte x-only public key) generated for this recipient.\r\n2) In the tests, sort by B<sub>m</sub> where we currently sort by amount. This shouldn't reveal any extra information in the generated outputs, since these outputs are calculated as P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G and t<sub>n</sub> is a sha256 digest.\r\n\r\nOrdering of a `ECPubKey` does not seem to be implemented in the simplified `secp256k1.py` test library, but it is defined in the [`secp256k1` library itself](https://github.com/bitcoin-core/secp256k1/blob/master/include/secp256k1.h#L471). I have access to it in the `rust-secp256k1` library via the `Ord` and `PartialOrd` trait implementations of the `PublicKey` struct.\r\n\r\nI think doing (1) at least makes a lot of sense. SP implementations will always need to be able to map outputs with specific recipients, so the tests should reflect that.\r\n\r\nFor (2) I am less certain. Regardless, if the only point of 'amounts' is to create deterministic test results, it would be better to rename `amount` to `order` or something.",
      "user": {
        "login": "cygnet3",
        "id": 131168104,
        "node_id": "U_kgDOB9F3aA",
        "avatar_url": "https://avatars.githubusercontent.com/u/131168104?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cygnet3",
        "html_url": "https://github.com/cygnet3",
        "followers_url": "https://api.github.com/users/cygnet3/followers",
        "following_url": "https://api.github.com/users/cygnet3/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cygnet3/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cygnet3/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cygnet3/subscriptions",
        "organizations_url": "https://api.github.com/users/cygnet3/orgs",
        "repos_url": "https://api.github.com/users/cygnet3/repos",
        "events_url": "https://api.github.com/users/cygnet3/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cygnet3/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1669991489",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "commented",
      "id": 1670050214,
      "node_id": "IC_kwDOAN28mc5jivGm",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1670050214",
      "actor": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-08T17:50:20Z",
      "updated_at": "2023-08-08T17:50:20Z",
      "author_association": "NONE",
      "body": "> Regarding the test vectors: I think it is best to remove the 'amount' values from the sending tests.\r\n> \r\n> Payment amounts don't test any logic about silent payments directly. Rather, they are indirectly used for the following two purposes:\r\n> \r\n>     1. to match generated taproot outputs with a specific recipient (because all the amounts are unique)\r\n> \r\n>     2. to ensure determinism in testing (sorting on amounts for every silent payment group)\r\n> \r\n> \r\n> In other words, they are used as a sort-able unique identifier for each recipient.\r\n> \r\n> Both of these goals can be achieved in another way:\r\n> \r\n>     1. For the sending outputs, expect a dictionary object instead, where the key is a recipient (bech32m string representing a silent payment address), and the value is a list of taproot outputs  (hex encoding of 32-byte x-only public key) generated for this recipient.\r\n> \r\n>     2. In the tests, sort by Bm where we currently sort by amount. This shouldn't reveal any extra information in the generated outputs, since these outputs are calculated as Pmn = Bm + tn·G and tn is a sha256 digest.\r\n> \r\n> \r\n> Ordering of a `ECPubKey` does not seem to be implemented in the simplified `secp256k1.py` test library, but it is defined in the [`secp256k1` library itself](https://github.com/bitcoin-core/secp256k1/blob/master/include/secp256k1.h#L471). I have access to it in the `rust-secp256k1` library via the `Ord` and `PartialOrd` trait implementations of the `PublicKey` struct.\r\n> \r\n> I think doing (1) at least makes a lot of sense. SP implementations will always need to be able to map outputs with specific recipients, so the tests should reflect that.\r\n> \r\n> For (2) I am less certain. Regardless, if the only point of 'amounts' is to create deterministic test results, it would be better to rename `amount` to `order` or something.\r\n\r\nI totally support this, and even for determinism frankly I already got rid of the amounts in my own test and it doesn't seem to affect me.\r\n\r\nI would change some other details about the tests and test vectors, I'll make a comment about that specifically soon.",
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1670050214",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "commented",
      "id": 1670984031,
      "node_id": "IC_kwDOAN28mc5jmTFf",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1670984031",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T09:28:35Z",
      "updated_at": "2023-08-09T09:28:35Z",
      "author_association": "NONE",
      "body": "@Sosthene00 @cygnet3 Thanks for the suggestions! I think just sorting the labeled spend pub keys is likely the best solution. For sorting, we can just lexicographically sort the compressed format (which is what secp2561 does).\r\n\r\nAlso fine with removing amounts, so long as we can be sure the correct amounts are being paid by the generated taproot outputs.\r\n\r\n@Sosthene00 I'll wait for the rest of your feedback before updating the tests",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1670984031",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "mentioned",
      "id": 10044581673,
      "node_id": "MEE_lADOAN28mc5n1phizwAAAAJWtCcp",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10044581673",
      "actor": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T09:28:35Z"
    },
    {
      "event": "subscribed",
      "id": 10044581687,
      "node_id": "SE_lADOAN28mc5n1phizwAAAAJWtCc3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10044581687",
      "actor": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T09:28:35Z"
    },
    {
      "event": "mentioned",
      "id": 10044581707,
      "node_id": "MEE_lADOAN28mc5n1phizwAAAAJWtCdL",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10044581707",
      "actor": {
        "login": "cygnet3",
        "id": 131168104,
        "node_id": "U_kgDOB9F3aA",
        "avatar_url": "https://avatars.githubusercontent.com/u/131168104?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cygnet3",
        "html_url": "https://github.com/cygnet3",
        "followers_url": "https://api.github.com/users/cygnet3/followers",
        "following_url": "https://api.github.com/users/cygnet3/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cygnet3/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cygnet3/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cygnet3/subscriptions",
        "organizations_url": "https://api.github.com/users/cygnet3/orgs",
        "repos_url": "https://api.github.com/users/cygnet3/repos",
        "events_url": "https://api.github.com/users/cygnet3/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cygnet3/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T09:28:35Z"
    },
    {
      "event": "subscribed",
      "id": 10044581727,
      "node_id": "SE_lADOAN28mc5n1phizwAAAAJWtCdf",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10044581727",
      "actor": {
        "login": "cygnet3",
        "id": 131168104,
        "node_id": "U_kgDOB9F3aA",
        "avatar_url": "https://avatars.githubusercontent.com/u/131168104?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cygnet3",
        "html_url": "https://github.com/cygnet3",
        "followers_url": "https://api.github.com/users/cygnet3/followers",
        "following_url": "https://api.github.com/users/cygnet3/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cygnet3/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cygnet3/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cygnet3/subscriptions",
        "organizations_url": "https://api.github.com/users/cygnet3/orgs",
        "repos_url": "https://api.github.com/users/cygnet3/repos",
        "events_url": "https://api.github.com/users/cygnet3/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cygnet3/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T09:28:35Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10044713610,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJWtiqK",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10044713610",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T09:41:32Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGM1NWY4MGM1M2M5ODY0MjM1NzcxMmMxODM5Y2ZkYzA1NTFkNTMxYzQ",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/c55f80c53c98642357712c1839cfdc0551d531c4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/c55f80c53c98642357712c1839cfdc0551d531c4",
      "tree": {
        "sha": "b27fbe7c875d774cc1594425d5a26e3bf8392a8b",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/b27fbe7c875d774cc1594425d5a26e3bf8392a8b"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree b27fbe7c875d774cc1594425d5a26e3bf8392a8b\nparent 4e4db8ba123aa8e9cba8cc4d2f700b9724cb8963\nauthor josibake <josibake@protonmail.com> 1678297558 +0100\ncommitter josibake <josibake@protonmail.com> 1691574552 +0200\n\nBIP for Silent Payments\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmTTYRoACgkQity1WMTz\nPWW+PhAAmc8+leAuVxIrxg/wJq7ipKnEpce8CKOZj88+3GLpDbYMG8D8jN3TDrxF\nifUz2dz6WC29INLTxA4YB9pKP7TS7Lw7y00skeH9SoOdpbo9Ly8oU4uAA1N5ymJh\n/tHTCCCkpV+qRE1XLKUBZzLDpuqrRvdxrXALDnnHOcvzwuX3pGuvLAZdtqvHvhmi\nP2k2f+fQGO4D+/OjCItonRfgKmWs233pM4o2DsYPl9ubQfe4CebiKUifTrrkXSeZ\nE40CLrCqgMG4aIwqcWS6L88/WmH8BaDU1lIWoAcGlhD0kH/alfGd7+UpsV88X0/c\nuzfIASRvSBQx5fa2rr0AY1N/v2VuUhK1IFTBPOMawyI8pxJtB1qFm3RTeQzjVNSE\ngv0OkHKrfjekF/a9E+7kjfgqAyK2KUTK0+pEPTjOE8O/qOaXodCGfKfxt4oMsg/B\nUInzsus2uPNfS6V6BNzwU9GaRkobsGke9bsTSkmDQONmpFCldLrT+8gAo00GmhU0\nbULZVUZinfVSfy67mW0fb4SojZLbf9auRzg6WoYv7g9gSsbzSHQs9vhU1KsxQL2z\nJXkJ9+a5UFlcLvCRdIOo6NA9YhIBYSkyxYV0TOwe1ewDGfW4wTZlujIj/1fS7Kos\n5zr7sWCQYlo2DOcy6RnF4owL3KcvtWKWI4HhtqbcbKKCOGtGIRI=\n=XmJH\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/4e4db8ba123aa8e9cba8cc4d2f700b9724cb8963",
          "sha": "4e4db8ba123aa8e9cba8cc4d2f700b9724cb8963",
          "html_url": "https://github.com/bitcoin/bips/commit/4e4db8ba123aa8e9cba8cc4d2f700b9724cb8963"
        }
      ],
      "message": "BIP for Silent Payments",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2023-08-09T09:49:12Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2023-03-08T17:45:58Z"
      },
      "sha": "c55f80c53c98642357712c1839cfdc0551d531c4"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10044794811,
      "node_id": "HRFPE_lADOAN28mc5n1phizwAAAAJWt2e7",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10044794811",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T09:49:23Z"
    },
    {
      "event": "commented",
      "id": 1703758225,
      "node_id": "IC_kwDOAN28mc5ljUmR",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1703758225",
      "actor": {
        "login": "FeatureSpitter",
        "id": 39516190,
        "node_id": "MDQ6VXNlcjM5NTE2MTkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/39516190?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/FeatureSpitter",
        "html_url": "https://github.com/FeatureSpitter",
        "followers_url": "https://api.github.com/users/FeatureSpitter/followers",
        "following_url": "https://api.github.com/users/FeatureSpitter/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/FeatureSpitter/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/FeatureSpitter/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/FeatureSpitter/subscriptions",
        "organizations_url": "https://api.github.com/users/FeatureSpitter/orgs",
        "repos_url": "https://api.github.com/users/FeatureSpitter/repos",
        "events_url": "https://api.github.com/users/FeatureSpitter/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/FeatureSpitter/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-02T07:57:57Z",
      "updated_at": "2023-09-02T07:58:25Z",
      "author_association": "NONE",
      "body": "What do you mean by \"without requiring any interaction or on-chain overhead\"?\r\n\r\nYou still have to record a new transaction in the ledger with this new UTXO targeting the \"silent tweaked address\" (`X' = hash(i*X)*G + X`). Thus I don't understand where don't you have on-chain overhead or what you mean by it.\r\n\r\nThanks",
      "user": {
        "login": "FeatureSpitter",
        "id": 39516190,
        "node_id": "MDQ6VXNlcjM5NTE2MTkw",
        "avatar_url": "https://avatars.githubusercontent.com/u/39516190?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/FeatureSpitter",
        "html_url": "https://github.com/FeatureSpitter",
        "followers_url": "https://api.github.com/users/FeatureSpitter/followers",
        "following_url": "https://api.github.com/users/FeatureSpitter/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/FeatureSpitter/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/FeatureSpitter/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/FeatureSpitter/subscriptions",
        "organizations_url": "https://api.github.com/users/FeatureSpitter/orgs",
        "repos_url": "https://api.github.com/users/FeatureSpitter/repos",
        "events_url": "https://api.github.com/users/FeatureSpitter/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/FeatureSpitter/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1703758225",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "Kruwed",
        "id": 118238055,
        "node_id": "U_kgDOBwwrZw",
        "avatar_url": "https://avatars.githubusercontent.com/u/118238055?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Kruwed",
        "html_url": "https://github.com/Kruwed",
        "followers_url": "https://api.github.com/users/Kruwed/followers",
        "following_url": "https://api.github.com/users/Kruwed/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Kruwed/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Kruwed/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Kruwed/subscriptions",
        "organizations_url": "https://api.github.com/users/Kruwed/orgs",
        "repos_url": "https://api.github.com/users/Kruwed/repos",
        "events_url": "https://api.github.com/users/Kruwed/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Kruwed/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-02T22:01:37Z",
      "updated_at": "2023-09-02T22:01:37Z",
      "source": {
        "issue": {
          "id": 1878743319,
          "node_id": "I_kwDOA0xxnc5v-1kX",
          "url": "https://api.github.com/repos/zkSNACKs/WalletWasabi/issues/11413",
          "repository_url": "https://api.github.com/repos/zkSNACKs/WalletWasabi",
          "labels_url": "https://api.github.com/repos/zkSNACKs/WalletWasabi/issues/11413/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/zkSNACKs/WalletWasabi/issues/11413/comments",
          "events_url": "https://api.github.com/repos/zkSNACKs/WalletWasabi/issues/11413/events",
          "html_url": "https://github.com/zkSNACKs/WalletWasabi/issues/11413",
          "number": 11413,
          "state": "open",
          "state_reason": null,
          "title": "Silent Payments, reusable payment code ",
          "body": "\n### Description\n\nSilent payments are a type of payment that can be made to a unique onchain address for every payment even though the receiver provided the spender with a reusable (offchain) address.\n\n### Reasoning\n\nThis is the best available design. \n\nhttps://bitcoinops.org/en/topics/silent-payments/",
          "user": {
            "login": "MaxHillebrand",
            "id": 30683012,
            "node_id": "MDQ6VXNlcjMwNjgzMDEy",
            "avatar_url": "https://avatars.githubusercontent.com/u/30683012?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/MaxHillebrand",
            "html_url": "https://github.com/MaxHillebrand",
            "followers_url": "https://api.github.com/users/MaxHillebrand/followers",
            "following_url": "https://api.github.com/users/MaxHillebrand/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/MaxHillebrand/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/MaxHillebrand/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/MaxHillebrand/subscriptions",
            "organizations_url": "https://api.github.com/users/MaxHillebrand/orgs",
            "repos_url": "https://api.github.com/users/MaxHillebrand/repos",
            "events_url": "https://api.github.com/users/MaxHillebrand/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/MaxHillebrand/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 1,
          "created_at": "2023-09-02T15:49:21Z",
          "updated_at": "2023-09-02T22:01:36Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1705050337,
      "node_id": "IC_kwDOAN28mc5loQDh",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1705050337",
      "actor": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-04T10:51:30Z",
      "updated_at": "2023-09-04T10:51:30Z",
      "author_association": "NONE",
      "body": "> What do you mean by \"without requiring any interaction or on-chain overhead\"?\r\n> \r\n> You still have to record a new transaction in the ledger with this new UTXO targeting the \"silent tweaked address\" (`X' = hash(i*X)*G + X`). Thus I don't understand where don't you have on-chain overhead or what you mean by it.\r\n> \r\n> Thanks\r\n\r\nHi, I think it just means that we don't need extra transactions beside the payment and don't add data to transactions either, like BIP47 or Private Payment that both need a notification transaction with some data in an `OP_RETURN`. ",
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1705050337",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "reviewed",
      "id": 1608335822,
      "node_id": "PRR_kwDOAN28mc5f3UHO",
      "url": null,
      "actor": null,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "This BIP seems to be structured as \"let's gradually build a silent payment construction by improving in stages\". That's more what a blogpost would be. For the spec, I would prefer to just have a description of the final construction instead of all the intermediate ones. Right now it's kinda confusing, you might be skimming and read something in the middle that is actually not part of the actually proposed construction..",
      "user": {
        "login": "stevenroose",
        "id": 853468,
        "node_id": "MDQ6VXNlcjg1MzQ2OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/853468?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stevenroose",
        "html_url": "https://github.com/stevenroose",
        "followers_url": "https://api.github.com/users/stevenroose/followers",
        "following_url": "https://api.github.com/users/stevenroose/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stevenroose/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stevenroose/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stevenroose/subscriptions",
        "organizations_url": "https://api.github.com/users/stevenroose/orgs",
        "repos_url": "https://api.github.com/users/stevenroose/repos",
        "events_url": "https://api.github.com/users/stevenroose/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stevenroose/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#pullrequestreview-1608335822",
      "submitted_at": "2023-09-07T18:44:52Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "benthecarman",
        "id": 15256660,
        "node_id": "MDQ6VXNlcjE1MjU2NjYw",
        "avatar_url": "https://avatars.githubusercontent.com/u/15256660?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benthecarman",
        "html_url": "https://github.com/benthecarman",
        "followers_url": "https://api.github.com/users/benthecarman/followers",
        "following_url": "https://api.github.com/users/benthecarman/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benthecarman/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benthecarman/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benthecarman/subscriptions",
        "organizations_url": "https://api.github.com/users/benthecarman/orgs",
        "repos_url": "https://api.github.com/users/benthecarman/repos",
        "events_url": "https://api.github.com/users/benthecarman/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benthecarman/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-09T16:43:45Z",
      "updated_at": "2023-09-09T16:43:45Z",
      "source": {
        "issue": {
          "id": 1888809544,
          "node_id": "I_kwDODgwEWM5wlPJI",
          "url": "https://api.github.com/repos/bitcoindevkit/bdk/issues/1114",
          "repository_url": "https://api.github.com/repos/bitcoindevkit/bdk",
          "labels_url": "https://api.github.com/repos/bitcoindevkit/bdk/issues/1114/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoindevkit/bdk/issues/1114/comments",
          "events_url": "https://api.github.com/repos/bitcoindevkit/bdk/issues/1114/events",
          "html_url": "https://github.com/bitcoindevkit/bdk/issues/1114",
          "number": 1114,
          "state": "open",
          "state_reason": null,
          "title": "Support for sending to silent payments",
          "body": "https://github.com/bitcoin/bips/pull/1458\r\n\r\nSupporting receiving for silent payments would be a very large undertaking. However, supporting sending should be relatively pretty trivial.",
          "user": {
            "login": "benthecarman",
            "id": 15256660,
            "node_id": "MDQ6VXNlcjE1MjU2NjYw",
            "avatar_url": "https://avatars.githubusercontent.com/u/15256660?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/benthecarman",
            "html_url": "https://github.com/benthecarman",
            "followers_url": "https://api.github.com/users/benthecarman/followers",
            "following_url": "https://api.github.com/users/benthecarman/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/benthecarman/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/benthecarman/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/benthecarman/subscriptions",
            "organizations_url": "https://api.github.com/users/benthecarman/orgs",
            "repos_url": "https://api.github.com/users/benthecarman/repos",
            "events_url": "https://api.github.com/users/benthecarman/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/benthecarman/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 2,
          "created_at": "2023-09-09T16:43:45Z",
          "updated_at": "2023-09-12T13:46:50Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1715984625,
      "node_id": "IC_kwDOAN28mc5mR9jx",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1715984625",
      "actor": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-12T15:47:17Z",
      "updated_at": "2023-09-12T15:47:17Z",
      "author_association": "NONE",
      "body": "Thanks for the feedback @stevenroose\r\n\r\n>I would prefer to just have a description of the final construction\r\n\r\nIn the opening paragraph of the Overview we explicitly mention this:\r\n\r\n`We first present an informal overview of the protocol. [...] Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see Specification.`\r\n\r\nWhile I see how it can also lead to confusion in some cases, we've also received a lot of feedback on how this made it easier to comprehend the protocol. There are a lot of steps involved, and this gives us a good framework of introducing them to the reader one by one.",
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1458#issuecomment-1715984625",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1458"
    },
    {
      "event": "mentioned",
      "id": 10348664248,
      "node_id": "MEE_lADOAN28mc5n1phizwAAAAJo1BW4",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10348664248",
      "actor": {
        "login": "stevenroose",
        "id": 853468,
        "node_id": "MDQ6VXNlcjg1MzQ2OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/853468?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stevenroose",
        "html_url": "https://github.com/stevenroose",
        "followers_url": "https://api.github.com/users/stevenroose/followers",
        "following_url": "https://api.github.com/users/stevenroose/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stevenroose/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stevenroose/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stevenroose/subscriptions",
        "organizations_url": "https://api.github.com/users/stevenroose/orgs",
        "repos_url": "https://api.github.com/users/stevenroose/repos",
        "events_url": "https://api.github.com/users/stevenroose/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stevenroose/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-12T15:47:17Z"
    },
    {
      "event": "subscribed",
      "id": 10348664260,
      "node_id": "SE_lADOAN28mc5n1phizwAAAAJo1BXE",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10348664260",
      "actor": {
        "login": "stevenroose",
        "id": 853468,
        "node_id": "MDQ6VXNlcjg1MzQ2OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/853468?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stevenroose",
        "html_url": "https://github.com/stevenroose",
        "followers_url": "https://api.github.com/users/stevenroose/followers",
        "following_url": "https://api.github.com/users/stevenroose/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stevenroose/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stevenroose/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stevenroose/subscriptions",
        "organizations_url": "https://api.github.com/users/stevenroose/orgs",
        "repos_url": "https://api.github.com/users/stevenroose/repos",
        "events_url": "https://api.github.com/users/stevenroose/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stevenroose/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-12T15:47:17Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1218471896",
      "pull_request_review_id": 1463200093,
      "id": 1218471896,
      "node_id": "PRRC_kwDOAN28mc5IoGfY",
      "diff_hunk": "@@ -0,0 +1,331 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 91,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f0ccab189ef1481c36c11908d6f675086c183283",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think you should either link to the light clients section below, or mention in this footnote that the 32-byte tweak for each TX in every block must be provided by a trusted source in addition to BIP158 data (If I understand correctly)",
      "created_at": "2023-06-05T19:00:16Z",
      "updated_at": "2023-06-05T19:00:17Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1218471896",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1218471896"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1219166650",
      "pull_request_review_id": 1464581432,
      "id": 1219166650,
      "node_id": "PRRC_kwDOAN28mc5IqwG6",
      "diff_hunk": "@@ -0,0 +1,331 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 91,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f0ccab189ef1481c36c11908d6f675086c183283",
      "in_reply_to_id": 1218471896,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good point! Done in https://github.com/bitcoin/bips/pull/1458/commits/f10996df34ad8a326384e6e018f2d16a7829e5a1",
      "created_at": "2023-06-06T08:26:04Z",
      "updated_at": "2023-06-06T08:26:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1219166650",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1219166650"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1220406775",
      "pull_request_review_id": 1466163601,
      "id": 1220406775,
      "node_id": "PRRC_kwDOAN28mc5Ive33",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 192,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": null,
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could this be changed to \"The sender MUST be able compute `ax * Bscan` on the tweaked private key (`ax`) corresponding to the taproot output key [...]\". I believe that BIP327 (MuSig2) users can compute the correct value to be used with silent payments, but this phrase excludes them using it. This would also require changing the computation of `P0` to something like:\r\n```\r\nlet S = a0 * B + a1 * B + ... + an * B\r\nlet P0 = hash(outpoints_hash * S || 0) * G + B\r\n```\r\n",
      "created_at": "2023-06-06T21:40:26Z",
      "updated_at": "2023-06-06T21:49:04Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1220406775",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1220406775"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1220408854",
      "pull_request_review_id": 1466163601,
      "id": 1220408854,
      "node_id": "PRRC_kwDOAN28mc5IvfYW",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude ''P2TR'' script path spends, unless ''H'' is used as the internal public key",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 221,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": null,
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should this read\r\n> Exclude ''P2TR'' outputs for whom `ax * Bscan` cannot be computed\r\n\r\n?",
      "created_at": "2023-06-06T21:41:59Z",
      "updated_at": "2023-06-06T21:49:04Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1220408854",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1220408854"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1220411253",
      "pull_request_review_id": 1466163601,
      "id": 1220411253,
      "node_id": "PRRC_kwDOAN28mc5Ivf91",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 194,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": null,
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Given that BIP-0341 recommends:\r\n> In order to avoid leaking the information that key path spending is not possible it is recommended to pick a fresh integer r in the range 0...n-1 uniformly at random and use H + rG as internal key.\r\n\r\nIt seems inadvisable to specify `H` directly in this BIP.",
      "created_at": "2023-06-06T21:44:22Z",
      "updated_at": "2023-06-06T21:49:04Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1220411253",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1220411253"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221709606",
      "pull_request_review_id": 1467851639,
      "id": 1221709606,
      "node_id": "PRRC_kwDOAN28mc5I0c8m",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 192,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220406775,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Glad to see this proposal advancing! I think with some minor changes it can be compatible with MuSig2 Taproot Keypaths (and potentially other off chain key aggregation schemes), which make it a powerful way of transacting privately even between users with advanced keys and scripts on Taproot.\r\n\r\nThanks so much for the review! We definitely want to support key aggregation techniques (Musig2 / FROST / etc) on both the sender (inputs) and receiver (having the spend key be an aggregated key). I need to read up on BIP327 to make sure I fully understand your comments but will respond shortly.  I've also responded in line to your other comments.",
      "created_at": "2023-06-07T14:32:24Z",
      "updated_at": "2023-06-07T14:32:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1221709606",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221709606"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221714272",
      "pull_request_review_id": 1467859255,
      "id": 1221714272,
      "node_id": "PRRC_kwDOAN28mc5I0eFg",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude ''P2TR'' script path spends, unless ''H'' is used as the internal public key",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 221,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220408854,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We want to be clear that the sender should never use the script path spend when funding a silent payment transaction. This is because a script path spend could contain any number of public keys and it becomes intractable for the receiver to try and determine which ones would have been used.\r\n\r\nIn the event the sender uses a script path spend where the internal public keys is H, it is safe to include it to fund the transaction because the receiver can clearly skip it when collecting the public keys for the ECDH step.",
      "created_at": "2023-06-07T14:35:35Z",
      "updated_at": "2023-06-07T14:35:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1221714272",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221714272"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221728624",
      "pull_request_review_id": 1467881949,
      "id": 1221728624,
      "node_id": "PRRC_kwDOAN28mc5I0hlw",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 194,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220411253,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There are certain use cases today where only the script path will be used (e.g. inscriptions), where it would be fine (and desirable) to use H as the internal public key. Seeing H clearly indicates to the recipient that this input was not used when deriving the silent payment address and allows them to skip the input when doing the shared secret derivation. Using H also allows the sender to fund silent payment transactions with UTXOs that were only ever intended to be spent as a script path spend.\r\n\r\nAlso, IIUC, the fact that the key path spend was never possible is only revealed at spending time, which for use cases like inscriptions seems totally fine.",
      "created_at": "2023-06-07T14:45:46Z",
      "updated_at": "2023-06-07T14:45:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1221728624",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221728624"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221870669",
      "pull_request_review_id": 1468111498,
      "id": 1221870669,
      "node_id": "PRRC_kwDOAN28mc5I1ERN",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude ''P2TR'' script path spends, unless ''H'' is used as the internal public key",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 221,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220408854,
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hmm, can we instead put it on the recipient to exclude P2TR inputs from the tweak if they are spent with script path, but let the sender include them?\r\n\r\nAny exclusion of allowable inputs seems like a footgun.",
      "created_at": "2023-06-07T16:18:10Z",
      "updated_at": "2023-06-07T16:18:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1221870669",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221870669"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221877550",
      "pull_request_review_id": 1468118940,
      "id": 1221877550,
      "node_id": "PRRC_kwDOAN28mc5I1F8u",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 194,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220411253,
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm led to the same direction as on the exclusion of P2TR script path spends - rather than excluding or including inputs based on their construction, can we include or exclude inputs based on how they are spent? If a P2TR input is spent using its keypath then the spender can compute `ax * Bscan`, so that input MUST be included in the silent payment tweak. If a P2TR input is spent using a script path the recipient cannot know whether the spender could compute `ax * Bscan` so that input MUST NOT be included from the silent payment tweak.",
      "created_at": "2023-06-07T16:22:36Z",
      "updated_at": "2023-06-07T16:22:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1221877550",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221877550"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221885669",
      "pull_request_review_id": 1468129731,
      "id": 1221885669,
      "node_id": "PRRC_kwDOAN28mc5I1H7l",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude ''P2TR'' script path spends, unless ''H'' is used as the internal public key",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 221,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220408854,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That would be ideal! Unfortunately, that causes a malleability issue with CoinJoin. This is explained in one of the footones: \r\n\r\n> Why not skip all taproot script path spends? This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.",
      "created_at": "2023-06-07T16:28:23Z",
      "updated_at": "2023-06-07T16:28:23Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1221885669",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221885669"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221888573",
      "pull_request_review_id": 1468134137,
      "id": 1221888573,
      "node_id": "PRRC_kwDOAN28mc5I1Io9",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 194,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220411253,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Doing it this way introduces a malleability issue with CoinJoins, see https://github.com/bitcoin/bips/pull/1458#discussion_r1221885669",
      "created_at": "2023-06-07T16:31:10Z",
      "updated_at": "2023-06-07T16:31:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1221888573",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1221888573"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 200,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222069440",
      "pull_request_review_id": 1468418535,
      "id": 1222069440,
      "node_id": "PRRC_kwDOAN28mc5I10zA",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude ''P2TR'' script path spends, unless ''H'' is used as the internal public key",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 221,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220408854,
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I see, but can't we still include the script path spend as long as the keypath `ax * Bscan` is included in the tweak?\r\n\r\nSo the rule would then be:\r\n> Exclude \"P2TR\" inputs for which `ax * Bscan` (`ax` being the tweaked private key corresponding to the taproot output key) cannot be computed, unless they are spent using a script path and the internal public key is exactly equal to `H`.\r\n\r\nAnd the receiver would always include P2TR output keys even if they were spent using script path, unless the internal key is exactly `H`.\r\n\r\nThere wouldn't be many cases where this would be different in practice than what you wrote, however one can imagine a CKBunker-type device which would be willing to provide an answer to the question \"What is your key times this public point\" but wouldn't be willing to sign a specific transaction spending its inputs. Then the spender could collect whatever other spending conditions might let them spend from the script path and still send the silent payment.",
      "created_at": "2023-06-07T19:31:09Z",
      "updated_at": "2023-06-07T19:31:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222069440",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222069440"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222118205",
      "pull_request_review_id": 1468505256,
      "id": 1222118205,
      "node_id": "PRRC_kwDOAN28mc5I2As9",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 176,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why do the outpoints need sorting if they already have an order defined by the transaction?",
      "created_at": "2023-06-07T20:23:59Z",
      "updated_at": "2023-06-07T20:38:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222118205",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222118205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222118313",
      "pull_request_review_id": 1468505256,
      "id": 1222118313,
      "node_id": "PRRC_kwDOAN28mc5I2Aup",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 212,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "How exactly is the parsing of public keys from non-standard scriptSigs supposed to be done? The only foolproof way I can think of—executing the scriptSig and then reading the top stack element—requires a Script interpreter, which is a non-trivial requirement if you aren't Bitcoin Core. If this is the case, it should probably be clarified.",
      "created_at": "2023-06-07T20:24:08Z",
      "updated_at": "2023-06-07T20:38:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222118313",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222118313"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 218,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222118418",
      "pull_request_review_id": 1468505256,
      "id": 1222118418,
      "node_id": "PRRC_kwDOAN28mc5I2AwS",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude ''P2TR'' script path spends, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>i</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = t<sub>n</sub>·G + B<sub>m</sub>''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''\n+\n+The sender should check to ensure that no two outputs in the final transaction have the same ''t<sub>n</sub>'' as this could result in a loss of privacy for the receiver<ref name=\"why_not_the_same_tn\">''' Why can't two outputs have the same ''t<sub>n</sub>''?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''t<sub>n</sub>·G + B<sub>spend</sub> + i·G'' and ''t<sub>n</sub>·G + B<sub>spend</sub> + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>.\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user’s silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''BIP_NUMBER'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>i</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Let ''ecdh_shared_secret = outpoints_hash·b<sub>scan</sub>·A''\n+* Check for outputs:\n+** Let ''outputs_to_check = all unspent taproot outputs in the transaction''\n+** Starting with ''n = 0'':\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Compute ''P<sub>n</sub> = t<sub>n</sub>·G + B<sub>spend</sub>''\n+**** If ''P<sub>n</sub>'' is in ''outputs_to_check'', add it to the wallet and continue with ''n++''\n+**** If ''P<sub>n</sub>'' is not found and the wallet has precomputed labels<ref name=\"precompute_labels\">''' Why precompute labels?''' Naively, a wallet could some max integer ''M'' which indicates the total number of labels it has used. When checking a transaction, the wallet would need to add all possible labels to each output. This ends up being ''n·m'' additions, where ''n'' is the number of outputs in the transaction and ''m'' is the number of labels in the wallet</ref>:",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 268,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Missing word in \"a wallet could some max integer\".",
      "created_at": "2023-06-07T20:24:14Z",
      "updated_at": "2023-06-07T20:38:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222118418",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222118418"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 268,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222200815",
      "pull_request_review_id": 1468623089,
      "id": 1222200815,
      "node_id": "PRRC_kwDOAN28mc5I2U3v",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 192,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220406775,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks for the comments. Is the concern that the way it is worded it sounds like the owner of an input is a single person while in reality it could be a group of owners using MuSig (or even FROST)? I do think it is worth specifically mentioning somewhere, but there shouldn't be anything in the current specification that causes issues for such cases. Shared secrets are linear and so in e.g. a MuSig 2-of-2 the two people can both just calculate the shared secret (with their MuSig tweaked key) and add up the result.\r\n\r\nIf these two people don't trust each other then they also need to provide an discreet log equivalence proof (relatively simple) to prove they calculated the shared secret correctly. This detail probably is important enough to add to the BIP, now that I think about it.",
      "created_at": "2023-06-07T21:35:49Z",
      "updated_at": "2023-06-07T21:35:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222200815",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222200815"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222208000",
      "pull_request_review_id": 1468633595,
      "id": 1222208000,
      "node_id": "PRRC_kwDOAN28mc5I2WoA",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude ''P2TR'' script path spends, unless ''H'' is used as the internal public key",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 221,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220408854,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">one can imagine a CKBunker-type device which would be willing to provide an answer to the question \"What is your key times this public point\" but wouldn't be willing to sign a specific transaction spending its inputs. Then the spender could collect whatever other spending conditions might let them spend from the script path and still send the silent payment.\r\n\r\nThe specification as currently described already allows for this. Was there any part that gave you the impression that it didn't?",
      "created_at": "2023-06-07T21:46:25Z",
      "updated_at": "2023-06-07T21:46:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222208000",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222208000"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222216284",
      "pull_request_review_id": 1468646455,
      "id": 1222216284,
      "node_id": "PRRC_kwDOAN28mc5I2Ypc",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 176,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1222118205,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This makes it so the order of the inputs doesn't matter for the resulting address, which is slightly safer even if issues around this are unlikely to occur. For instance, a wallet might RBF bump a tx and for some reason decide the change the order of the inputs, and neglect to realize this also means they'd have to recalculate the SP output. Now they won't have to.",
      "created_at": "2023-06-07T21:58:22Z",
      "updated_at": "2023-06-07T21:58:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222216284",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222216284"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222217664",
      "pull_request_review_id": 1468648108,
      "id": 1222217664,
      "node_id": "PRRC_kwDOAN28mc5I2Y_A",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 192,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220406775,
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "My concern was just the precise phrase `MUST use the tweaked private key` which does not exist in an aggregate key situation. So changing the phrasing be explicit about what computation is required ensures that users of complex keys are not incorrectly deterred. I think the approach for MuSig in particular would be something like...\r\n\r\nParticipants compute and publish:\r\n```\r\naB_px = d_px * B\r\n```\r\nCoordinator computes:\r\n```\r\nuntweaked_agg_pk = keyagg_coef_p1 * A_p1 + keyagg_coef_p2 * A_p2 + ... + keyagg_coef_pn * A_pn\r\naB_agg = keyagg_coef_p1 * aB_p1 + keyagg_coef_p2 * aB_p2 + ... + keyagg_coef_pn * aB_pn\r\naB_agg' = pointNegate(aB_agg) if !has_even_y(untweaked_agg_pk) else aB_agg\r\naB = aB_agg' + tapTweak * B\r\n```\r\n(please don't quote me on this computation, I think it's close, but probably missed at least one detail)\r\n\r\nOf course the above is also complicated by x-only internal keys. yay.",
      "created_at": "2023-06-07T21:59:59Z",
      "updated_at": "2023-06-07T21:59:59Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222217664",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222217664"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222220000",
      "pull_request_review_id": 1468651594,
      "id": 1222220000,
      "node_id": "PRRC_kwDOAN28mc5I2Zjg",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude ''P2TR'' script path spends, unless ''H'' is used as the internal public key",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 221,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220408854,
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> The specification as currently described already allows for this. Was there any part that gave you the impression that it didn't?\r\n\r\n`Exclude ''P2TR\" script path spends` <-- that phrase in the input selection\r\n\r\nThe requirement is that even if I am going to spend with script path I must include the taproot outputkey in the ECDH to prevent malleability.",
      "created_at": "2023-06-07T22:02:46Z",
      "updated_at": "2023-06-07T22:02:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222220000",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222220000"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222235175",
      "pull_request_review_id": 1468670277,
      "id": 1222235175,
      "node_id": "PRRC_kwDOAN28mc5I2dQn",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 212,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1222118313,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, the logic behind this is that there are only two ways to scan for silent payments:\r\n1. Run a full node (in which case you'd have a script interpreter)\r\n2. Receive tweak data from a full node (the full node will have interpreted the script for you in order to generate the tweak data)\r\n\r\nSo to the best of our knowledge there is no scenario where you're not relying on a full node anyway, either directly or indirectly.\r\n\r\nThat said, it seems a full script interpreter would not even be strictly required in this case. All you'd need to do is to find the 33 or 65 byte stack elements in the scriptsig (the only two possibilities for (un)compressed keys) and check which one of those matches up to the hashed value in the scriptpubkey.",
      "created_at": "2023-06-07T22:11:12Z",
      "updated_at": "2023-06-07T22:11:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222235175",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222235175"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 218,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222438414",
      "pull_request_review_id": 1468977453,
      "id": 1222438414,
      "node_id": "PRRC_kwDOAN28mc5I3O4O",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude ''P2TR'' script path spends, unless ''H'' is used as the internal public key",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 221,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220408854,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> a CKBunker-type device which would be willing to provide an answer to the question \"What is your key times this public point\" but wouldn't be willing to sign a specific transaction spending its inputs. Then the spender could collect whatever other spending conditions might let them spend from the script path and still send the silent payment.\r\n\r\nIf I'm understanding your example, the key path private key is on the CKBunker and never signs transactions, but the user can spend from a separate wallet using script path conditions for the same input(s)?",
      "created_at": "2023-06-08T04:30:51Z",
      "updated_at": "2023-06-08T04:30:51Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222438414",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222438414"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222440579",
      "pull_request_review_id": 1468980517,
      "id": 1222440579,
      "node_id": "PRRC_kwDOAN28mc5I3PaD",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 176,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1222118205,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> order defined by the transaction\r\n\r\nIn addition to Ruben's comment, I'd add I don't think this order is defined until the transaction is signed, whereas you are generating the silent payment output before signing. Seems much safer to have an ordering defined by the protocol rather than requiring wallet software to ensure the prevout outpoints are always kept in the same order during the entire transaction creation process",
      "created_at": "2023-06-08T04:35:59Z",
      "updated_at": "2023-06-08T04:35:59Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222440579",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222440579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222443935",
      "pull_request_review_id": 1468985169,
      "id": 1222443935,
      "node_id": "PRRC_kwDOAN28mc5I3QOf",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude ''P2TR'' script path spends, unless ''H'' is used as the internal public key",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 221,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220408854,
      "user": {
        "login": "brandonblack",
        "id": 90655836,
        "node_id": "MDQ6VXNlcjkwNjU1ODM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/90655836?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brandonblack",
        "html_url": "https://github.com/brandonblack",
        "followers_url": "https://api.github.com/users/brandonblack/followers",
        "following_url": "https://api.github.com/users/brandonblack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brandonblack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brandonblack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brandonblack/subscriptions",
        "organizations_url": "https://api.github.com/users/brandonblack/orgs",
        "repos_url": "https://api.github.com/users/brandonblack/repos",
        "events_url": "https://api.github.com/users/brandonblack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brandonblack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> If I'm understanding your example, the key path private key is on the CKBunker and never signs transactions, but the user can spend from a separate wallet using script path conditions for the same input(s)?\r\n\r\nYeah. I might have my CKBunker at home, set to sign nothing, but produce the ECDH shares for silent payments. I also have an `OP_CSV <pubkey> OP_CHECKSIG` script path for a key I keep on my phone 1 million sats per week, so I can send using my phone and silent payments up to that amount as long as my CKBunker is willing to provide its ECDH shares.\r\n\r\nObviously I made up this example on the spot, but with vaults and other advanced constructions, I don't think it makes sense to exclude the possibility that someone could have limited access to the keypath secret key (or shares), but want to spend using a script path for one reason or another.",
      "created_at": "2023-06-08T04:43:25Z",
      "updated_at": "2023-06-08T04:43:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222443935",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222443935"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222449159",
      "pull_request_review_id": 1468992503,
      "id": 1222449159,
      "node_id": "PRRC_kwDOAN28mc5I3RgH",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude ''P2TR'' script path spends, unless ''H'' is used as the internal public key",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 221,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220408854,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks for the explanation! Initially, my thinking on this was there's never a (likely) scenario where you would have access to the taproot output key but choose to spend with the script path, so we could likely simplify implementations for the sender by just skipping inputs where we only have the script path data altogether in coin selection.\r\n\r\nBut, given your example, I agree that there might be interesting use cases that we don't want to rule out. ",
      "created_at": "2023-06-08T04:54:25Z",
      "updated_at": "2023-06-08T04:54:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222449159",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222449159"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222609105",
      "pull_request_review_id": 1469250800,
      "id": 1222609105,
      "node_id": "PRRC_kwDOAN28mc5I34jR",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude ''P2TR'' script path spends, unless ''H'' is used as the internal public key",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 221,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220408854,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Perhaps as a foot note to point out there are theoretical exceptions to `Exclude ''P2TR\" script path spends`. In practice almost none of the sender implementations are going to need to consider this, but it's true, so worth mentioning.",
      "created_at": "2023-06-08T07:58:32Z",
      "updated_at": "2023-06-08T07:58:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222609105",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222609105"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222706283",
      "pull_request_review_id": 1469402484,
      "id": 1222706283,
      "node_id": "PRRC_kwDOAN28mc5I4QRr",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude ''P2TR'' script path spends, unless ''H'' is used as the internal public key",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 221,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220408854,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I updated the wording to remove the \"exclude\" language, more as a placeholder because I think this still needs a bit of re-working (along with the \"P2TR\" section in \"Inputs for Shared Secret Derivation\"",
      "created_at": "2023-06-08T09:22:58Z",
      "updated_at": "2023-06-08T09:22:59Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222706283",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222706283"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222707012",
      "pull_request_review_id": 1469403649,
      "id": 1222707012,
      "node_id": "PRRC_kwDOAN28mc5I4QdE",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude ''P2TR'' script path spends, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>i</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = t<sub>n</sub>·G + B<sub>m</sub>''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''\n+\n+The sender should check to ensure that no two outputs in the final transaction have the same ''t<sub>n</sub>'' as this could result in a loss of privacy for the receiver<ref name=\"why_not_the_same_tn\">''' Why can't two outputs have the same ''t<sub>n</sub>''?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''t<sub>n</sub>·G + B<sub>spend</sub> + i·G'' and ''t<sub>n</sub>·G + B<sub>spend</sub> + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>.\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user’s silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''BIP_NUMBER'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>i</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Let ''ecdh_shared_secret = outpoints_hash·b<sub>scan</sub>·A''\n+* Check for outputs:\n+** Let ''outputs_to_check = all unspent taproot outputs in the transaction''\n+** Starting with ''n = 0'':\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Compute ''P<sub>n</sub> = t<sub>n</sub>·G + B<sub>spend</sub>''\n+**** If ''P<sub>n</sub>'' is in ''outputs_to_check'', add it to the wallet and continue with ''n++''\n+**** If ''P<sub>n</sub>'' is not found and the wallet has precomputed labels<ref name=\"precompute_labels\">''' Why precompute labels?''' Naively, a wallet could some max integer ''M'' which indicates the total number of labels it has used. When checking a transaction, the wallet would need to add all possible labels to each output. This ends up being ''n·m'' additions, where ''n'' is the number of outputs in the transaction and ''m'' is the number of labels in the wallet</ref>:",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 268,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1222118418,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in https://github.com/bitcoin/bips/pull/1458/commits/1ae1b4bf80bc21911fbd90033edd8006d5e6b592",
      "created_at": "2023-06-08T09:23:37Z",
      "updated_at": "2023-06-08T09:23:37Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1222707012",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1222707012"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 268,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1223312180",
      "pull_request_review_id": 1470395096,
      "id": 1223312180,
      "node_id": "PRRC_kwDOAN28mc5I6kM0",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 176,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1222118205,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thank you both for comments. In case you'd like to turn them into a footnote, it could be something like:\r\n\r\n**Why are outpoints sorted before hashing?** This way the silent payment output does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during a RBF bump.",
      "created_at": "2023-06-08T16:47:56Z",
      "updated_at": "2023-06-08T16:47:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1223312180",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1223312180"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226054226",
      "pull_request_review_id": 1473991698,
      "id": 1226054226,
      "node_id": "PRRC_kwDOAN28mc5JFBpS",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 119,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "1ae1b4bf80bc21911fbd90033edd8006d5e6b592",
      "in_reply_to_id": null,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This feels unnecessarily foot-shooty. Since `m=[1,2,3,...]` is arbitrary and only really important to Bob, why can't he simply do `m=[B<sub>scan</sub>*1, B<sub>scan</sub>*2, B<sub>scan</sub>*3,...]` instead? No additional information is required, and Bob's check would check for the above list, rather than the known-to-everybod `int*G` list.\r\n\r\nEdit: originally used privkeys for scan, but not sure if this would be potentially leaky so switched to (some specified serialization form of) the pubkey type. Not sure if that defeats the purpose though.",
      "created_at": "2023-06-12T03:47:32Z",
      "updated_at": "2023-06-12T05:16:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1226054226",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226054226"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226120425",
      "pull_request_review_id": 1474085564,
      "id": 1226120425,
      "node_id": "PRRC_kwDOAN28mc5JFRzp",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 119,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "1ae1b4bf80bc21911fbd90033edd8006d5e6b592",
      "in_reply_to_id": 1226054226,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Hey @kallewoof, thanks for the review! With multiple `Bscans`, Bob now has to do the ECDH step multiple times for the same transaction to determine if there is an output for him. For someone with sufficiently powerful hardware, this might not be an issue, but it certainly wouldn't be possible on mobile or even your \"average\" node runner using commodity hardware.\r\n\r\nImagine the use case where Bob is an exchange and wants to have a unique SP address for each user: if he hands out a `Bscan*int` per user, he now has to do an EC mult per user, per transaction. With the labels approach we describe, he would only have to do one EC mult per transaction, subtract that from the outputs of the transaction and see if any of the remainders (`int*G + Bspend` ) are in his database with a simple lookup. This scales nicely to millions of users.\r\n\r\n> rather than the known-to-everybod int*G list\r\n\r\nI'm not sure what you mean by known-to-everybody. If Bob posts two SP addresses, `Bscan, Bspend + 1*G` and `Bscan, Bspend + 2*G`, an outside observer can see two SP addresses with `Bscan` in common and infer that they are owned by the same entity, but they don't know `Bspend` and can't determine which `int*G` tweak was used, or even if an `int*G` tweak was used.",
      "created_at": "2023-06-12T05:56:14Z",
      "updated_at": "2023-06-12T05:56:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1226120425",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226120425"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226150199",
      "pull_request_review_id": 1474130412,
      "id": 1226150199,
      "node_id": "PRRC_kwDOAN28mc5JFZE3",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 119,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "1ae1b4bf80bc21911fbd90033edd8006d5e6b592",
      "in_reply_to_id": 1226054226,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Hey @kallewoof, thanks for the review! With multiple `Bscans`, Bob now has to do the ECDH step multiple times for the same transaction to determine if there is an output for him. For someone with sufficiently powerful hardware, this might not be an issue, but it certainly wouldn't be possible on mobile or even your \"average\" node runner using commodity hardware.\r\n\r\nIs powmod really that expensive? I thought it was pretty instant/cheap.\r\n\r\n> Imagine the use case where Bob is an exchange and wants to have a unique SP address for each user: if he hands out a `Bscan*int` per user, he now has to do an EC mult per user, per transaction. With the labels approach we describe, he would only have to do one EC mult per transaction, subtract that from the outputs of the transaction and see if any of the remainders (`int*G + Bspend` ) are in his database with a simple lookup. This scales nicely to millions of users.\r\n\r\nIf we're talking millions of users, then perhaps it becomes prohibitively expensive, but otoh an exchange won't be run off of a mobile device, so maybe they can handle that processing power bump. Perhaps I'm underestimating the complexity-bump here.\r\n\r\n> I'm not sure what you mean by known-to-everybody. If Bob posts two SP addresses, `Bscan, Bspend + 1*G` and `Bscan, Bspend + 2*G`, an outside observer can see two SP addresses with `Bscan` in common and infer that they are owned by the same entity, but they don't know `Bspend` and can't determine which `int*G` tweak was used, or even if an `int*G` tweak was used.\r\n\r\nIf I see a pubkey X, and I then see a pubkey X + (known to everyone) n*G where n is a tiny predictable number, then I can indeed determine which `int*G` tweak was used, no? It would require me to track a lot of data, so perhaps it's no biggie, but it definitely isn't impossible.",
      "created_at": "2023-06-12T06:31:05Z",
      "updated_at": "2023-06-12T06:31:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1226150199",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226150199"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226259367",
      "pull_request_review_id": 1474310768,
      "id": 1226259367,
      "node_id": "PRRC_kwDOAN28mc5JFzun",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 119,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "1ae1b4bf80bc21911fbd90033edd8006d5e6b592",
      "in_reply_to_id": 1226054226,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Is powmod really that expensive? I thought it was pretty instant/cheap\r\n\r\nIt's more that EC addition is cheaper. The other significant advantage in my mind is that if we apply the additive tweak to `Bspend`, we only have to do this once and can cache it. If we use the `Bscan*int` approach, we have to redo the calculation for each `int` for each new transaction (i.e `Bscan*int*InputPubKeys`)\r\n\r\n> so maybe they can handle that processing power bump\r\n\r\nPerhaps worth mentioning there is nothing stopping an exchange (or anyone with sufficient processing power) from doing it this way and they would still be completely compatible with the SP protocol! The sender doesn't care (or even know) how the receiver is tweaking their keys. Its not clear to me why the exchange would prefer this over the additive method, but they could do it. It would be a custom implementation, which would make recovering from backup into different wallet software an issue, but that's more a concern for individual users, imo.\r\n\r\n> If I see a pubkey X, and I then see a pubkey X + (known to everyone) n*G\r\n\r\nRight, my point was you've never seen pubkey X (`Bspend`, in this example), and you wouldn't know it was the untweaked `Bspend` even if you saw it. All you see are three Pubkeys. \r\n\r\nI'd also add it doesn't hurt the receiver's privacy or security at all if you were to learn which `int*G` they used. It's just a nice benefit that until you've seen multiple addresses with `Bscan` in common, you can't know whether or not any particular SP addresses is using a label tweak or not.",
      "created_at": "2023-06-12T08:15:00Z",
      "updated_at": "2023-06-12T08:15:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1226259367",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226259367"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226306042",
      "pull_request_review_id": 1474378304,
      "id": 1226306042,
      "node_id": "PRRC_kwDOAN28mc5JF_H6",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 119,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "1ae1b4bf80bc21911fbd90033edd8006d5e6b592",
      "in_reply_to_id": 1226054226,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think I got caught on the initial `\"easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity\"` part. But if I'm not mistaken, the Bspend pubkeys are not used directly, but they are tweaked in payments, so even knowing them I won't know when a payment is made using them, unless I hold the corresponding privkey.\r\n\r\nThanks, resolving.",
      "created_at": "2023-06-12T08:45:37Z",
      "updated_at": "2023-06-12T08:45:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1226306042",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226306042"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226318158",
      "pull_request_review_id": 1474399209,
      "id": 1226318158,
      "node_id": "PRRC_kwDOAN28mc5JGCFO",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 119,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "1ae1b4bf80bc21911fbd90033edd8006d5e6b592",
      "in_reply_to_id": 1226054226,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks for the comments @kallewoof.\r\n\r\n>If I see a pubkey X, and I then see a pubkey X + (known to everyone) n\\*G where n is a tiny predictable number, then I can indeed determine which int\\*G tweak was used, no?\r\n\r\nThe full calculation is P = hash(shared_secret)\\*G + X + n\\*G. Since outside observers don't know hash(shared_secret)*G, they can't figure out n.\r\n\r\nThe recipient on the other hand *can* figure out n by calculating hash(shared_secret)\\*G + X and subtracting it from P (where P is every taproot output in a tx).\r\n\r\nNote that as soon as you start modifying shared_secret, you have to multiply by G again for every n. So scanning cost goes up linearly with n as opposed to staying the same no matter how big n is.",
      "created_at": "2023-06-12T08:55:28Z",
      "updated_at": "2023-06-12T09:01:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1226318158",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1226318158"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1228709420",
      "pull_request_review_id": 1478071840,
      "id": 1228709420,
      "node_id": "PRRC_kwDOAN28mc5JPJ4s",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 192,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "1ae1b4bf80bc21911fbd90033edd8006d5e6b592",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Using the term _taproot output key_ to refer to both a public key and a private key is somewhat confusing. Additionally, that the key be tweaked is not required, only highly recommended. How about:\r\n```suggestion\r\nThe sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.\r\n```\r\n(If the diff isn't rendering correctly for you, I removed the first instance of \"tweaked\" and replaced \"the taproot output key\" with \"this key\".)",
      "created_at": "2023-06-13T21:21:30Z",
      "updated_at": "2023-06-13T21:21:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1228709420",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1228709420"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229364595",
      "pull_request_review_id": 1479038967,
      "id": 1229364595,
      "node_id": "PRRC_kwDOAN28mc5JRp1z",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 192,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "1ae1b4bf80bc21911fbd90033edd8006d5e6b592",
      "in_reply_to_id": 1228709420,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch! I was incorrectly using \"taproot output key\" to refer to the private key, it should always refer to the public key. I've added your suggested wording.",
      "created_at": "2023-06-14T10:15:50Z",
      "updated_at": "2023-06-14T10:15:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1229364595",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229364595"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229389610",
      "pull_request_review_id": 1479076244,
      "id": 1229389610,
      "node_id": "PRRC_kwDOAN28mc5JRv8q",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 176,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1222118205,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks for the suggested footnote! I've added it.",
      "created_at": "2023-06-14T10:36:52Z",
      "updated_at": "2023-06-14T10:36:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1229389610",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229389610"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229553588",
      "pull_request_review_id": 1479339973,
      "id": 1229553588,
      "node_id": "PRRC_kwDOAN28mc5JSX-0",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 192,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220406775,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added a footnote and attempted to update the language to indicate key aggregation techniques are supported in https://github.com/bitcoin/bips/pull/1458/commits/d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14\r\n\r\n@brandonblack let me know if you have any suggestions on how to improve it!",
      "created_at": "2023-06-14T12:42:20Z",
      "updated_at": "2023-06-14T12:42:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1229553588",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1229553588"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230292210",
      "pull_request_review_id": 1480480680,
      "id": 1230292210,
      "node_id": "PRRC_kwDOAN28mc5JVMTy",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 151,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This footnote about new output types is specific only to the third bullet point below, so it should be moved there (and the ref name should probably be made more specific).",
      "created_at": "2023-06-15T00:20:34Z",
      "updated_at": "2023-06-15T00:25:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1230292210",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230292210"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 151,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230292341",
      "pull_request_review_id": 1480480680,
      "id": 1230292341,
      "node_id": "PRRC_kwDOAN28mc5JVMV1",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 166,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In the implementation PR the human-readable part for regtest is \"sprt\" but here it is \"tsp\", which one is correct?",
      "created_at": "2023-06-15T00:20:55Z",
      "updated_at": "2023-06-15T00:25:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1230292341",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230292341"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 166,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230292387",
      "pull_request_review_id": 1480480680,
      "id": 1230292387,
      "node_id": "PRRC_kwDOAN28mc5JVMWj",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 169,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "BIP173 gives a limit of 90 characters for a Bech32 string, so the required increased limit of 115 should be mentioned here.",
      "created_at": "2023-06-15T00:21:04Z",
      "updated_at": "2023-06-15T00:25:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1230292387",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230292387"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": 165,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 173,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230292418",
      "pull_request_review_id": 1480480680,
      "id": 1230292418,
      "node_id": "PRRC_kwDOAN28mc5JVMXC",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using Musig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and Musig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or Musig2. This would require participants to perform the ECDH step collaboratively e.g ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = hash(outpoints_hash·ECDH || 0)·G + B<sub>spend</sub>''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 192,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nits:\r\n* \"e.g\" instead of \"e.g.\"\r\n* \"Musig2\" instead of \"MuSig2\"",
      "created_at": "2023-06-15T00:21:08Z",
      "updated_at": "2023-06-15T00:25:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1230292418",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230292418"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230292515",
      "pull_request_review_id": 1480480680,
      "id": 1230292515,
      "node_id": "PRRC_kwDOAN28mc5JVMYj",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using Musig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and Musig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or Musig2. This would require participants to perform the ECDH step collaboratively e.g ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = hash(outpoints_hash·ECDH || 0)·G + B<sub>spend</sub>''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The sending wallet MUST have access to the taproot output key, unless ''H'' is used as the internal public key",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 221,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Same as above, _taproot output key_ only refers to the public key:\r\n```suggestion\r\n* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\r\n```",
      "created_at": "2023-06-15T00:21:23Z",
      "updated_at": "2023-06-15T00:25:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1230292515",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230292515"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230292811",
      "pull_request_review_id": 1480480680,
      "id": 1230292811,
      "node_id": "PRRC_kwDOAN28mc5JVMdL",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using Musig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and Musig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or Musig2. This would require participants to perform the ECDH step collaboratively e.g ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = hash(outpoints_hash·ECDH || 0)·G + B<sub>spend</sub>''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The sending wallet MUST have access to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = t<sub>n</sub>·G + B<sub>m</sub>''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''\n+\n+The sender should check to ensure that no two outputs in the final transaction have the same ''t<sub>n</sub>'' as this could result in a loss of privacy for the receiver<ref name=\"why_not_the_same_tn\">''' Why can't two outputs have the same ''t<sub>n</sub>''?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''t<sub>n</sub>·G + B<sub>spend</sub> + i·G'' and ''t<sub>n</sub>·G + B<sub>spend</sub> + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 239,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "How could two outputs have the same t<sub>n</sub> if the algorithm above is implemented correctly? What exactly is meant by \"check to ensure\"?",
      "created_at": "2023-06-15T00:22:10Z",
      "updated_at": "2023-06-15T00:25:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1230292811",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230292811"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230292902",
      "pull_request_review_id": 1480480680,
      "id": 1230292902,
      "node_id": "PRRC_kwDOAN28mc5JVMem",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using Musig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and Musig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or Musig2. This would require participants to perform the ECDH step collaboratively e.g ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = hash(outpoints_hash·ECDH || 0)·G + B<sub>spend</sub>''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The sending wallet MUST have access to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = t<sub>n</sub>·G + B<sub>m</sub>''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''\n+\n+The sender should check to ensure that no two outputs in the final transaction have the same ''t<sub>n</sub>'' as this could result in a loss of privacy for the receiver<ref name=\"why_not_the_same_tn\">''' Why can't two outputs have the same ''t<sub>n</sub>''?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''t<sub>n</sub>·G + B<sub>spend</sub> + i·G'' and ''t<sub>n</sub>·G + B<sub>spend</sub> + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>.\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 251,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why does the silent payment version need to be in the derivation path? It seems to me that a future version would be its own BIP and therefore purpose field.",
      "created_at": "2023-06-15T00:22:20Z",
      "updated_at": "2023-06-15T00:25:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1230292902",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230292902"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": 250,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 251,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230683559",
      "pull_request_review_id": 1481063532,
      "id": 1230683559,
      "node_id": "PRRC_kwDOAN28mc5JWr2n",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 166,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "in_reply_to_id": 1230292341,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The implementation is out of date, will fix today. \r\n\r\nOn this topic I've gotten feedback both ways: \"regtest should be sprt to be consistent with bitcoin core\" and \"a special hrp for regtest is unnecessary.\" I'm leaning towards keeping it as-is in the BIP and using one HRP for all test networks, but curious what your opinion on this is?",
      "created_at": "2023-06-15T08:59:56Z",
      "updated_at": "2023-06-15T08:59:56Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1230683559",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230683559"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 166,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230686506",
      "pull_request_review_id": 1481068159,
      "id": 1230686506,
      "node_id": "PRRC_kwDOAN28mc5JWskq",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using Musig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and Musig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or Musig2. This would require participants to perform the ECDH step collaboratively e.g ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = hash(outpoints_hash·ECDH || 0)·G + B<sub>spend</sub>''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The sending wallet MUST have access to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = t<sub>n</sub>·G + B<sub>m</sub>''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''\n+\n+The sender should check to ensure that no two outputs in the final transaction have the same ''t<sub>n</sub>'' as this could result in a loss of privacy for the receiver<ref name=\"why_not_the_same_tn\">''' Why can't two outputs have the same ''t<sub>n</sub>''?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''t<sub>n</sub>·G + B<sub>spend</sub> + i·G'' and ''t<sub>n</sub>·G + B<sub>spend</sub> + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 239,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "in_reply_to_id": 1230292811,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There is no way this could happen if the sender is following the protocol. IIRC, we added this sentence as a belt and suspenders, but I'm inclined to remove it and instead make sure we have a test case for this.",
      "created_at": "2023-06-15T09:02:02Z",
      "updated_at": "2023-06-15T09:02:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1230686506",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230686506"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 239,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230704736",
      "pull_request_review_id": 1481095601,
      "id": 1230704736,
      "node_id": "PRRC_kwDOAN28mc5JWxBg",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using Musig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and Musig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or Musig2. This would require participants to perform the ECDH step collaboratively e.g ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = hash(outpoints_hash·ECDH || 0)·G + B<sub>spend</sub>''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The sending wallet MUST have access to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = t<sub>n</sub>·G + B<sub>m</sub>''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''\n+\n+The sender should check to ensure that no two outputs in the final transaction have the same ''t<sub>n</sub>'' as this could result in a loss of privacy for the receiver<ref name=\"why_not_the_same_tn\">''' Why can't two outputs have the same ''t<sub>n</sub>''?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''t<sub>n</sub>·G + B<sub>spend</sub> + i·G'' and ''t<sub>n</sub>·G + B<sub>spend</sub> + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>.\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 251,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "in_reply_to_id": 1230292902,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is here precisely because I _don't_ see us needing a new BIP for new versions of silent payments. Imagine we get a new output type and want to add it to the \"Inputs for shared secret derivation\" list. All we'd need to do is update this BIP with a version 1 section and everything else would remain unchanged.\r\n\r\nHowever, the more I think about this, maybe having the version in the derivation path is a bad idea. Imagine the same scenario I described above: for this upgrade, it would be great if you could keep the same secret data and backups, and just update your address with a new version number (`sp1p...`). This sp v1 address could still accept payments from v0 wallets, as well as v1 wallets.\r\n\r\nIf there is a different upgrade to silent payments which fundamentally changes how the address is used (e.g using something besides x-only pubkeys), then we would likely have a new BIP number, which makes the version field unnecessary.\r\n\r\nThoughts @RubenSomsen ?",
      "created_at": "2023-06-15T09:13:42Z",
      "updated_at": "2023-06-15T09:13:42Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1230704736",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230704736"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": 250,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 251,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230803033",
      "pull_request_review_id": 1481247769,
      "id": 1230803033,
      "node_id": "PRRC_kwDOAN28mc5JXJBZ",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 166,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "in_reply_to_id": 1230292341,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Did some digging on this and have come to the following conclusion:\r\n\r\n* `regtest` is a bitcoin core implementation specific concept. As such, I don't think it should be specified in a BIP\r\n* its fine for bitcoin core to use the regtest HRP (for consistency with our own internal testing framework), but this could just as easily be swapped out for `tsp` or any other random string for regtest\r\n\r\nBased on this, I think its best to remove any reference to regtest from the BIP, and also keep regtest handling consistent with how other addresses are treated in bitcoin core.\r\n\r\nFor more context, see: https://github.com/bitcoin/bitcoin/issues/12314",
      "created_at": "2023-06-15T10:34:08Z",
      "updated_at": "2023-06-15T10:34:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1230803033",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1230803033"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 166,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231312680",
      "pull_request_review_id": 1482044280,
      "id": 1231312680,
      "node_id": "PRRC_kwDOAN28mc5JZFco",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 166,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "in_reply_to_id": 1230292341,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm leaning slightly towards \"sprt\" for regtest, but I guess it doesn't really need to be specified. BIP173 doesn't specify the regtest HRP either.",
      "created_at": "2023-06-15T16:57:57Z",
      "updated_at": "2023-06-15T16:57:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1231312680",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231312680"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 166,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231324467",
      "pull_request_review_id": 1482062692,
      "id": 1231324467,
      "node_id": "PRRC_kwDOAN28mc5JZIUz",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character for bech32 strings, whereas a silent payment address requires 115 characters.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 171,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nNote: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 115 characters.\r\n```",
      "created_at": "2023-06-15T17:10:32Z",
      "updated_at": "2023-06-15T17:11:54Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1231324467",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231324467"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 171,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231324796",
      "pull_request_review_id": 1482062692,
      "id": 1231324796,
      "node_id": "PRRC_kwDOAN28mc5JZIZ8",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character for bech32 strings, whereas a silent payment address requires 115 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>'', where ''ecdh_shared_secret'' is a compressed public key\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 235,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The serialization of _ecdh_shared_secret_ is implicit here. Perhaps it would be a good idea to reuse the function ser<sub>P</sub>(P) from BIP32 and make it explicit? This also applies to other places where EC points are implicitly converted to byte arrays.",
      "created_at": "2023-06-15T17:10:52Z",
      "updated_at": "2023-06-15T17:11:54Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1231324796",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231324796"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 235,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231325070",
      "pull_request_review_id": 1482062692,
      "id": 1231325070,
      "node_id": "PRRC_kwDOAN28mc5JZIeO",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character for bech32 strings, whereas a silent payment address requires 115 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>'', where ''ecdh_shared_secret'' is a compressed public key\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''BIP_NUMBER'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 260,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In my own implementation I'm running into parity issues: because _B<sub>scan</sub>_ is a BIP340 public key which always has an even parity while _A_ is a sum of potentially non-BIP340 keys and can thus have any parity, in about half the cases _ecdh_shared_secret_ is different for sender and receiver. Isn't there a step missing that corrects for this, or am I missing something?",
      "created_at": "2023-06-15T17:11:10Z",
      "updated_at": "2023-06-15T17:11:54Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1231325070",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231325070"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231325561",
      "pull_request_review_id": 1482062692,
      "id": 1231325561,
      "node_id": "PRRC_kwDOAN28mc5JZIl5",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 139,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In BIP32, ser<sub>32</sub>(i) is a big-endian serialization. Since we're reusing the notation here, shouldn't we also reuse the meaning?",
      "created_at": "2023-06-15T17:11:42Z",
      "updated_at": "2023-06-15T17:11:55Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1231325561",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231325561"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231892356",
      "pull_request_review_id": 1482897219,
      "id": 1231892356,
      "node_id": "PRRC_kwDOAN28mc5JbS-E",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 166,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "in_reply_to_id": 1230292341,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've removed regtest from the wording in the BIP, and I'll leave the PR as is with `sprt` for regtest.",
      "created_at": "2023-06-16T07:30:56Z",
      "updated_at": "2023-06-16T07:30:56Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1231892356",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231892356"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 166,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231892519",
      "pull_request_review_id": 1482897448,
      "id": 1231892519,
      "node_id": "PRRC_kwDOAN28mc5JbTAn",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 169,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "in_reply_to_id": 1230292387,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-06-16T07:31:06Z",
      "updated_at": "2023-06-16T07:31:06Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1231892519",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231892519"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": 165,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 173,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231906338",
      "pull_request_review_id": 1482925182,
      "id": 1231906338,
      "node_id": "PRRC_kwDOAN28mc5JbWYi",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character for bech32 strings, whereas a silent payment address requires 115 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>'', where ''ecdh_shared_secret'' is a compressed public key\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''BIP_NUMBER'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 260,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": 1231325070,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Interesting, do you have some test data I can use to try and reproduce this? I _think_ we have a test for this (mixing of taproot and non-taproot in the inputs) in the functional tests on the PR, so seems there is a step we are doing in the Bitcoin Core implementation that isn't explained clearly in the BIP.",
      "created_at": "2023-06-16T07:45:25Z",
      "updated_at": "2023-06-16T11:04:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1231906338",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231906338"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231913130",
      "pull_request_review_id": 1482935850,
      "id": 1231913130,
      "node_id": "PRRC_kwDOAN28mc5JbYCq",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 139,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": 1231325561,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'd prefer to keep it little-endian, as it's more consistent with the rest of the BIP and consistent with how Bitcoin Core serializes `uint32_t` types. Perhaps naming the function `ser_le` to make it clear? Or dropping the function and just specifying that `output_index` is 4-byte little-endian?",
      "created_at": "2023-06-16T07:52:29Z",
      "updated_at": "2023-06-16T07:52:29Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1231913130",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231913130"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231914572",
      "pull_request_review_id": 1482938120,
      "id": 1231914572,
      "node_id": "PRRC_kwDOAN28mc5JbYZM",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character for bech32 strings, whereas a silent payment address requires 115 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>'', where ''ecdh_shared_secret'' is a compressed public key\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 235,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": 1231324796,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Already ran into an issue with this where serializing `ecdh_shared_secret` as x-only vs compressed gave different results :sweat_smile: .",
      "created_at": "2023-06-16T07:53:59Z",
      "updated_at": "2023-06-16T07:53:59Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1231914572",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1231914572"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 235,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1232074895",
      "pull_request_review_id": 1483181170,
      "id": 1232074895,
      "node_id": "PRRC_kwDOAN28mc5Jb_iP",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character for bech32 strings, whereas a silent payment address requires 115 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>'', where ''ecdh_shared_secret'' is a compressed public key\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 235,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": 1231324796,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added! This definitely improves the readability",
      "created_at": "2023-06-16T10:30:00Z",
      "updated_at": "2023-06-16T10:30:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1232074895",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1232074895"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 235,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1232077555",
      "pull_request_review_id": 1483185286,
      "id": 1232077555,
      "node_id": "PRRC_kwDOAN28mc5JcALz",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 139,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": 1231325561,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "On further reflection, I agree it's better to reuse notation and conventions from other BIP. It's also very likely that most wallets implementing silent payments will already have code written (or use libraries) with these serialization functions written for working with BIP32. Much better if we can reuse existing code rather than have wallets write custom code just for serializing data for silent payments.\r\n\r\nI've updated the spec to reflect this and will update the Bitcoin Core PR shortly.",
      "created_at": "2023-06-16T10:33:02Z",
      "updated_at": "2023-06-16T10:33:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1232077555",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1232077555"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1232102823",
      "pull_request_review_id": 1483223293,
      "id": 1232102823,
      "node_id": "PRRC_kwDOAN28mc5JcGWn",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using Musig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and Musig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or Musig2. This would require participants to perform the ECDH step collaboratively e.g ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = hash(outpoints_hash·ECDH || 0)·G + B<sub>spend</sub>''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The sending wallet MUST have access to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = t<sub>n</sub>·G + B<sub>m</sub>''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''\n+\n+The sender should check to ensure that no two outputs in the final transaction have the same ''t<sub>n</sub>'' as this could result in a loss of privacy for the receiver<ref name=\"why_not_the_same_tn\">''' Why can't two outputs have the same ''t<sub>n</sub>''?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''t<sub>n</sub>·G + B<sub>spend</sub> + i·G'' and ''t<sub>n</sub>·G + B<sub>spend</sub> + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>.\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 251,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d9e5a1b61dd464b808c8ebc45bbe0104ae8e5e14",
      "in_reply_to_id": 1230292902,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The more I've thought about this, I think we should remove the version from the derivation path since having it would require users to generate new keys when there is likely no reason to.\r\n\r\n I've updated the BIP to reflect this and also added a blurb to the version section.",
      "created_at": "2023-06-16T11:01:38Z",
      "updated_at": "2023-06-16T11:01:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1232102823",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1232102823"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": 250,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 251,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1232817532",
      "pull_request_review_id": 1484456638,
      "id": 1232817532,
      "node_id": "PRRC_kwDOAN28mc5Je018",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character for bech32 strings, whereas a silent payment address requires 115 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>'', where ''ecdh_shared_secret'' is a compressed public key\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''BIP_NUMBER'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 260,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": 1231325070,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Here are the test vectors that cause a parity mismatch in my implementation, along with the computed shared secret and partial computations.\r\n\r\n_B<sub>scan</sub>_ = 76e246e6b92aec2efd6c8db8037d284651ccd3c9b9ac1404010b7b3268016e92\r\n_b<sub>scan</sub>_ = ad8af2bd1bf108f3dd2ac74a2a5ec51d9a173c684c9e6365c6af93d5c5fdf61a\r\n_B<sub>spend</sub>_ = _B<sub>m</sub>_ = 8810c8029bb9560ab5c54241a108912f847ab7975df626f816430a64a35be68c\r\n_A<sub>0</sub>_ = _A_ = 03603ce64dcf386cd11c97b6c6d94de719c4638101ae9613f2f1e6fae78bb89e0f\r\n_a<sub>0</sub>_ = _a_ = 5f230aed01b015c4fdd78d209f878cb67be5135504b4d7a2c85b368d1c042b9d\r\n_outpoints_hash_ = 2f11ade1789049b1a26837d517bae661fb3b2dfc00a0d812f65ee207c7617c05\r\n\r\n**Sender:**\r\n_a_·_B<sub>scan</sub>_ = 03bc2412cc4aad38e93f0ce1ad5628ae231aac7cf1b6f54dfb074999bd34076f68\r\n_ecdh_shared_secret_ = 028408231298cc86c22e61ca8ba1967dd9192d68bcb4ca575e7f8284ae9c417828\r\n\r\n**Receiver:**\r\n_b<sub>scan</sub>_·_A_ = 02bc2412cc4aad38e93f0ce1ad5628ae231aac7cf1b6f54dfb074999bd34076f68\r\n_ecdh_shared_secret_ = 038408231298cc86c22e61ca8ba1967dd9192d68bcb4ca575e7f8284ae9c417828",
      "created_at": "2023-06-16T21:48:04Z",
      "updated_at": "2023-06-16T21:48:04Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1232817532",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1232817532"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1232861515",
      "pull_request_review_id": 1484526159,
      "id": 1232861515,
      "node_id": "PRRC_kwDOAN28mc5Je_lL",
      "diff_hunk": "@@ -0,0 +1,340 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 167,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d920133138dc587238f58dc266409f7f7fe0fe7b",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "BIP340 public keys are byte arrays, not EC points, so I believe this and all other expressions that implicitly treat them as such are technically wrong:\r\n> Note that we use a very different public key format (32 bytes) than the ones used by existing systems (which typically use elliptic curve points as public keys, or 33-byte or 65-byte encodings of them).",
      "created_at": "2023-06-16T22:47:04Z",
      "updated_at": "2023-06-16T22:47:04Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1232861515",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1232861515"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1233921896",
      "pull_request_review_id": 1486011159,
      "id": 1233921896,
      "node_id": "PRRC_kwDOAN28mc5JjCdo",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character for bech32 strings, whereas a silent payment address requires 115 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>'', where ''ecdh_shared_secret'' is a compressed public key\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''BIP_NUMBER'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 260,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": 1231325070,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks for the test data! Your parity mismatch is coming from the fact that _b<sub>scan</sub>_ produces an odd y value and needs to be negated.\r\n\r\nIt was my understanding that in order to be a valid BIP340 public key, the private key must be negated if it returns an odd y. Rereading BIP340, however, this doesn't seem to be clearly specified. The closest reference I can find is:\r\n\r\n> Note that we use a very different public key format (32 bytes) than the ones used by existing systems (which typically use elliptic curve points as public keys, or 33-byte or 65-byte encodings of them). A side effect is that PubKey(sk) = PubKey(bytes(n - int(sk)), so every public key has two corresponding secret keys. \r\n\r\nSo I think we do need to specify this in the silent payments BIP. Perhaps something like: \r\n\r\n> \"if _has_even_y(B<sub>scan</sub>)_ is false, negate _b<sub>scan</sub>_\"",
      "created_at": "2023-06-19T11:26:35Z",
      "updated_at": "2023-06-19T11:41:48Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1233921896",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1233921896"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1235289298",
      "pull_request_review_id": 1488187669,
      "id": 1235289298,
      "node_id": "PRRC_kwDOAN28mc5JoQTS",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can’t be distinguished\n+* Transactions can’t be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = hash(a·B)·G + B''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = hash(b·A)·G + B'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = hash(a·B || n)·G + B''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = hash(a·B || n)·G + B''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = hash(b·A || 0)·G + B''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = hash(b·A || 1)·G + B''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = hash(outpoint_hash·a·B || 0)·G + B''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice’s transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B || 0)·G + B''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob’s public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G + B<sub>spend</sub>''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A)·G + B<sub>spend</sub>'' with his online device and can spend from his cold storage signing device using ''(hash(outpoints_hash·b<sub>scan</sub>·A) + b<sub>spend</sub>) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G + B<sub>spend</sub>''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = hash(outpoints_hash·a·B<sub>change</sub> || 0)·G + B<sub>spend</sub>''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely<ref name=\"why_skip_transactions\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref> when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g SegWit versions > 1)\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver’s [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g  signet, testnet, regtest)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>m</sub> || B<sub>scan</sub>''\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path spends)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path spends)'''\n+\n+The sender MUST use the tweaked private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). If the taproot output key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds.</ref>.",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 192,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "f1c188faa55adb84ea0972dd451f319355c2860c",
      "in_reply_to_id": 1220406775,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Marking this as resolved for now, but keen to hear your feedback, if you have any @brandonblack ",
      "created_at": "2023-06-20T13:42:16Z",
      "updated_at": "2023-06-20T13:42:17Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1235289298",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1235289298"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 192,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1235694848",
      "pull_request_review_id": 1488818079,
      "id": 1235694848,
      "node_id": "PRRC_kwDOAN28mc5JpzUA",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character for bech32 strings, whereas a silent payment address requires 115 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>'', where ''ecdh_shared_secret'' is a compressed public key\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''BIP_NUMBER'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 260,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": 1231325070,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't have a strong opinion on how to correct the parity mismatch, but \"if _has_even_y(B<sub>scan</sub>)_ is false, negate _b<sub>scan</sub>_\" has the same problem as mentioned below that B<sub>scan</sub> is not an EC point but a byte array. [BIP340: Default Signing](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#default-signing) includes notation for private key negation which you could reuse. Another option would be to use 33-byte keys instead of x-only keys (I suppose this choice was made to make the silent payment address shorter?).",
      "created_at": "2023-06-20T18:49:49Z",
      "updated_at": "2023-06-20T18:49:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1235694848",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1235694848"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1236765323",
      "pull_request_review_id": 1490376411,
      "id": 1236765323,
      "node_id": "PRRC_kwDOAN28mc5Jt4qL",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character for bech32 strings, whereas a silent payment address requires 115 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>'', where ''ecdh_shared_secret'' is a compressed public key\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''BIP_NUMBER'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 260,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": 1231325070,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I need to rework the notation a bit, per your point about byte arrays vs EC points. I think that can be fixed, though.\r\n\r\nRegarding the choice of x-only public keys: yes, one reason is saving 2 bytes in the silent payment address. The address is already quite long and might become longer in the future with new silent payment versions, so we want to be as conservative as possible. The second reason is that the spend key can be a FROST or MuSig2 aggregate public key, both of which are only defined for BIP340 keys, IIUC. That doesn't stop us from adding and removing the extra byte as needed, but that seems clunky if we could just use x-only public keys instead.",
      "created_at": "2023-06-21T10:27:31Z",
      "updated_at": "2023-06-21T10:27:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1236765323",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1236765323"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1243572575",
      "pull_request_review_id": 1500603206,
      "id": 1243572575,
      "node_id": "PRRC_kwDOAN28mc5KH2lf",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character for bech32 strings, whereas a silent payment address requires 115 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>'', where ''ecdh_shared_secret'' is a compressed public key\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''BIP_NUMBER'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 260,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": 1231325070,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I wrote some test cases for this and turns out it's very difficult to keep track of the parity between sender and receiver, especially when using labels. While it could be done with x-only public keys, it would involve checking the evenness and negating keys at almost every step. I think the extra byte is definitely worth adding to keep things simple and save on computation when scanning.\r\n\r\nI've updated the specification to use 33-byte keys for the address, which I believe also addresses the notation concern.",
      "created_at": "2023-06-27T11:19:24Z",
      "updated_at": "2023-06-27T11:19:24Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1243572575",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1243572575"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1243577775",
      "pull_request_review_id": 1500616228,
      "id": 1243577775,
      "node_id": "PRRC_kwDOAN28mc5KH32v",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character for bech32 strings, whereas a silent payment address requires 115 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>'', where ''ecdh_shared_secret'' is a compressed public key\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''BIP_NUMBER'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 260,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": 1231325070,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Additionally, your example made me notice that we need to check both _output - P<sub>n</sub>_ and _output\\_negated - P<sub>n</sub>_ when scanning for labels. This wasn't necessary when using the old method of brute-forcing the label checks for all _m_, which is why we didn't notice it when we updated to use the subtraction technique when scanning for labels. I also updated the BIP to include this step. Thanks so much for working on an implementation and helping uncover this with your test case @vostrnad ! ",
      "created_at": "2023-06-27T11:24:11Z",
      "updated_at": "2023-06-27T11:24:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1243577775",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1243577775"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1243579831",
      "pull_request_review_id": 1500618785,
      "id": 1243579831,
      "node_id": "PRRC_kwDOAN28mc5KH4W3",
      "diff_hunk": "@@ -0,0 +1,340 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 167,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d920133138dc587238f58dc266409f7f7fe0fe7b",
      "in_reply_to_id": 1232861515,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've updated the BIP to use 33-byte compressed keys, per https://github.com/bitcoin/bips/pull/1458/files#r1243572575, so I think this is all good now.",
      "created_at": "2023-06-27T11:25:31Z",
      "updated_at": "2023-06-27T11:25:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1243579831",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1243579831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 167,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1246911474",
      "pull_request_review_id": 1505750983,
      "id": 1246911474,
      "node_id": "PRRC_kwDOAN28mc5KUlvy",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character for bech32 strings, whereas a silent payment address requires 115 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>'', where ''ecdh_shared_secret'' is a compressed public key\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''BIP_NUMBER'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 260,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": 1231325070,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've looked over the changes and they seem to mostly address the parity issues, however it seems to me that one step is missing: doesn't the sender need to negate the taproot private keys whose public keys have an odd Y coordinate?",
      "created_at": "2023-06-29T17:05:53Z",
      "updated_at": "2023-06-29T17:05:53Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1246911474",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1246911474"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1246956286",
      "pull_request_review_id": 1505819972,
      "id": 1246956286,
      "node_id": "PRRC_kwDOAN28mc5KUwr-",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character for bech32 strings, whereas a silent payment address requires 115 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>'', where ''ecdh_shared_secret'' is a compressed public key\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''BIP_NUMBER'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 260,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": 1231325070,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yep, that's correct. I had always assumed that being a taproot outpoint meant you always used the private key which corresponds with the even Y coordinate, but seems we should explicitly spell that out as a step in the BIP.",
      "created_at": "2023-06-29T18:14:02Z",
      "updated_at": "2023-06-29T18:14:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1246956286",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1246956286"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254343840",
      "pull_request_review_id": 1516397718,
      "id": 1254343840,
      "node_id": "PRRC_kwDOAN28mc5Kw8Sg",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 91,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": null,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should be 33 bytes",
      "created_at": "2023-07-06T12:07:25Z",
      "updated_at": "2023-07-06T14:00:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1254343840",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254343840"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254371356",
      "pull_request_review_id": 1516397718,
      "id": 1254371356,
      "node_id": "PRRC_kwDOAN28mc5KxDAc",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 117,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": null,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could use a footnote, something like:\r\n```\r\nAlternatively, ''m·G'' could be added to ''P<sub>0</sub>'' for each label ''m'' and compared to the transaction outputs. This is more performant in cases where the number of eligible outputs exceeds the number of labels in use. In practice this will mainly apply to users that choose never to use labels.\r\n```\r\nOr maybe this could be added to footnote 17 \"Why precompute the labels?\"",
      "created_at": "2023-07-06T12:32:20Z",
      "updated_at": "2023-07-06T14:00:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1254371356",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254371356"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254380682",
      "pull_request_review_id": 1516397718,
      "id": 1254380682,
      "node_id": "PRRC_kwDOAN28mc5KxFSK",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7||-\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail",
      "path": "bip-0352.mediawiki",
      "position": 181,
      "original_position": 180,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": null,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I can imagine people will end up wanting to embed optional metadata in the address, such as their pseudonym. The way it's written now, we'd force them to use v1 for that...",
      "created_at": "2023-07-06T12:40:54Z",
      "updated_at": "2023-07-06T14:00:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1254380682",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254380682"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 181,
      "original_line": 181,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254417304",
      "pull_request_review_id": 1516397718,
      "id": 1254417304,
      "node_id": "PRRC_kwDOAN28mc5KxOOY",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7||-\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 191,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": null,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We probably need to be more precise in our language here to ensure we covered all bases. Any ambiguity here will cause issues. What about the nVersion field inside transactions? I'm not fully sure at the moment how they relate to soft forks. ",
      "created_at": "2023-07-06T13:12:08Z",
      "updated_at": "2023-07-06T14:00:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1254417304",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254417304"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254431527",
      "pull_request_review_id": 1516397718,
      "id": 1254431527,
      "node_id": "PRRC_kwDOAN28mc5KxRsn",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7||-\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 232,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": null,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe we should just copy the sentence in question from BIP341 instead of merely referring to it. It's easier for readers and that way our BIP does not depend on whether BIP341 remains unchanged.",
      "created_at": "2023-07-06T13:18:55Z",
      "updated_at": "2023-07-06T14:00:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1254431527",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254431527"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254434664",
      "pull_request_review_id": 1516397718,
      "id": 1254434664,
      "node_id": "PRRC_kwDOAN28mc5KxSdo",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7||-\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list",
      "path": "bip-0352.mediawiki",
      "position": 273,
      "original_position": 258,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": null,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Another restriction is that none of the inputs must exceed segwit v1 (and depending on the answer to my previous comment we may also need to put restrictions on the nVersion field?)\r\n\r\nI think ideally we should refer back here to the part where it says \"A transaction is not a Silent Payments v0 transaction and should be skipped entirely when scanning if any of the following are true\"",
      "created_at": "2023-07-06T13:21:31Z",
      "updated_at": "2023-07-06T14:00:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1254434664",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254434664"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 273,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254449842",
      "pull_request_review_id": 1516397718,
      "id": 1254449842,
      "node_id": "PRRC_kwDOAN28mc5KxWKy",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7||-\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+** Optionally, if the sending wallet implements receiving silent payments, it can create change outputs in the following manner:\n+*** Let ''A<sub>change</sub> = A<sub>spend</sub> + sha256(ser<sub>256</sub>(a<sub>scan</sub>))·G''\n+*** Let ''change_shared_secret = outpoints_hash·a·A<sub>scan</sub>''\n+*** Let ''n = 0''\n+*** For each change output desired:\n+**** Let ''c<sub>n</sub> = sha256(ser<sub>P</sub>(change_shared_secret) || ser<sub>32</sub>(n))''\n+**** Let ''C<sub>n</sub> = A<sub>change</sub> + c<sub>n</sub>·G''\n+**** Encode ''C<sub>n</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+**** Repeat with ''n++'' for additional change outputs\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''352'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 305,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": null,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "More precisely, any tx that is an eligible SP tx should be scanned. This should also refer back to \"A transaction is not a Silent Payments v0 transaction and should be skipped entirely when scanning if any of the following are true\"",
      "created_at": "2023-07-06T13:32:55Z",
      "updated_at": "2023-07-06T14:00:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1254449842",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254449842"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 305,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254460747",
      "pull_request_review_id": 1516397718,
      "id": 1254460747,
      "node_id": "PRRC_kwDOAN28mc5KxY1L",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7||-\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+** Optionally, if the sending wallet implements receiving silent payments, it can create change outputs in the following manner:\n+*** Let ''A<sub>change</sub> = A<sub>spend</sub> + sha256(ser<sub>256</sub>(a<sub>scan</sub>))·G''\n+*** Let ''change_shared_secret = outpoints_hash·a·A<sub>scan</sub>''\n+*** Let ''n = 0''\n+*** For each change output desired:\n+**** Let ''c<sub>n</sub> = sha256(ser<sub>P</sub>(change_shared_secret) || ser<sub>32</sub>(n))''\n+**** Let ''C<sub>n</sub> = A<sub>change</sub> + c<sub>n</sub>·G''\n+**** Encode ''C<sub>n</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+**** Repeat with ''n++'' for additional change outputs\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''352'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Let ''ecdh_shared_secret = outpoints_hash·b<sub>scan</sub>·A''\n+* Check for outputs:\n+** Let ''outputs_to_check = the taproot output key from each unspent taproot output in the transaction''\n+** Starting with ''n = 0'':\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Compute ''P<sub>n</sub> = B<sub>spend</sub> + t<sub>n</sub>·G''\n+*** For each ''output'' in ''outputs_to_check'':\n+**** If ''P<sub>n</sub>'' equals ''output'':\n+***** Add ''P<sub>n</sub>'' to the wallet\n+***** Remove ''output'' from ''outputs_to_check'' and rescan ''outputs_to_check'' with ''n++''\n+**** Else, if the wallet has precomputed labels (including the change label, if used)<ref name=\"precompute_labels\">''' Why precompute labels?''' Naively, a wallet could store some max integer ''M'' which indicates the total number of labels it has used. When checking a transaction, the wallet would need to add all possible labels to each output. This ends up being ''n·m'' additions, where ''n'' is the number of outputs in the transaction and ''m'' is the number of labels in the wallet. By precomputing the labels, the wallet only needs to compute ''m·G'' once per label and can determine if a label was used via a lookup, rather than adding each label to each output.</ref>:",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 319,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": null,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think the wording needs to change to say change labels must be scanned.\r\n\r\nIdeally we'd have two recommendations:\r\na. No labels except for the change label\r\nb. X number of labels (where X is some number that seems reasonable pending benchmarks)\r\n\r\nIf the user knows they never used labels then they can scan with option a, if unsure they'll have to scan for b, if they went beyond X they'll have to manually pick a high enough number.",
      "created_at": "2023-07-06T13:41:30Z",
      "updated_at": "2023-07-06T14:00:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1254460747",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254460747"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 319,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254469116",
      "pull_request_review_id": 1516397718,
      "id": 1254469116,
      "node_id": "PRRC_kwDOAN28mc5Kxa38",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7||-\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+** Optionally, if the sending wallet implements receiving silent payments, it can create change outputs in the following manner:\n+*** Let ''A<sub>change</sub> = A<sub>spend</sub> + sha256(ser<sub>256</sub>(a<sub>scan</sub>))·G''\n+*** Let ''change_shared_secret = outpoints_hash·a·A<sub>scan</sub>''\n+*** Let ''n = 0''\n+*** For each change output desired:\n+**** Let ''c<sub>n</sub> = sha256(ser<sub>P</sub>(change_shared_secret) || ser<sub>32</sub>(n))''\n+**** Let ''C<sub>n</sub> = A<sub>change</sub> + c<sub>n</sub>·G''\n+**** Encode ''C<sub>n</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+**** Repeat with ''n++'' for additional change outputs\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''352'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Let ''ecdh_shared_secret = outpoints_hash·b<sub>scan</sub>·A''\n+* Check for outputs:\n+** Let ''outputs_to_check = the taproot output key from each unspent taproot output in the transaction''\n+** Starting with ''n = 0'':\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Compute ''P<sub>n</sub> = B<sub>spend</sub> + t<sub>n</sub>·G''\n+*** For each ''output'' in ''outputs_to_check'':\n+**** If ''P<sub>n</sub>'' equals ''output'':\n+***** Add ''P<sub>n</sub>'' to the wallet\n+***** Remove ''output'' from ''outputs_to_check'' and rescan ''outputs_to_check'' with ''n++''\n+**** Else, if the wallet has precomputed labels (including the change label, if used)<ref name=\"precompute_labels\">''' Why precompute labels?''' Naively, a wallet could store some max integer ''M'' which indicates the total number of labels it has used. When checking a transaction, the wallet would need to add all possible labels to each output. This ends up being ''n·m'' additions, where ''n'' is the number of outputs in the transaction and ''m'' is the number of labels in the wallet. By precomputing the labels, the wallet only needs to compute ''m·G'' once per label and can determine if a label was used via a lookup, rather than adding each label to each output.</ref>:\n+***** Compute ''m·G = output - P<sub>n</sub>''\n+***** Check if ''m·G'' exists in the list of labels used by the wallet\n+***** If a match is found:\n+****** Add the ''P<sub>n</sub> + m·G'' to the wallet\n+****** Remove ''output'' from ''outputs_to_check'' and rescan ''outputs_to_check'' with ''n++''\n+***** If the label is not found, negate ''output'' and check again\n+*** If no matches are found, stop\n+\n+==== Backup and Recovery ====\n+\n+Since each silent payment output address is derived independently, regular backups are recommended. When recovering from a backup, the wallet will need to scan since the last backup to detect new payments.\n+\n+If using a seed phrase only style backup, the user can recover the wallet's unspent outputs from the UTXO set (by only scanning transactions with at least one unspent taproot output) and can recover the full wallet history by scanning the blockchain, starting from the wallet birthday. If a wallet uses labels, this information SHOULD be included in the backup. If the user does not know whether or not labels were used, they can precompute a large number of labels based on a safe upper bound (e.g. 100k labels) to use when re-scanning.\n+\n+== Backward Compatibility ==\n+\n+Silent payments introduces a new address format and protocol for sending and as such is not compatible with older wallet software or wallets which have not implemented the silent payments protocol.\n+\n+== Test Vectors ==\n+\n+A [[bip-0340/test-vectors.csv|collection of test vectors in JSON format]] are provided, along with a [[bip-0340/reference.py|python reference implementation]]. Each test vector consists of a sending test case and corresponding receiving test case. This is to allow sending and receiving to be implemented separately. Test cases use the following schema:\n+\n+''' test_case '''\n+\n+    {\n+        \"comment\": \"Comment describing the behavior being tested\",\n+        \"sending\": [<array of sender test objects>],\n+        \"receiving\": [<array of recipient test objects>],\n+    }\n+\n+''' sender '''\n+\n+    {\n+        \"given\": {\n+            \"outpoints\": [<array of tuples, where each tuple represents an outpoint: (txid, vout)>],\n+            \"input_priv_keys\": [<array of tuples, where each tuple is a hex encoded private key and boolean for taproot: (priv_key, is_taproot)>],\n+            \"recipients\": [<array of tuples, where each tuple is a bech32m string representing a silent payment address and an float amount: (silent_payment_address, amount)>]\n+        },\n+        \"expected\": {\n+            \"outputs\": [<array of key, value objects, where the key is the hex encoding of 32-byte x-only public key and the value an integer amount: {taproot_x_only_key: amount}]\n+        },\n+    }\n+\n+''' recipient '''\n+\n+    {\n+        \"given\": {\n+            \"outpoints\": [<array of tuples, where each tuple represents an outpoint: (txid, vout)>],\n+            \"input_pub_keys\": [<array of hex encoded public keys, either 33-byte compressed or 32-byte x-only>],\n+            \"bip32_seed\": \"byte data for generating a bip32 master seed\",\n+            \"labels\": {<dictionary object, where the key is the hex encoding (33-byte compressed) of m*G and the value is the integer m>},\n+         },\n+         \"expected\": {\n+             \"addresses\": [<array of bech32m strings, one for the silent payment address and each labeled address (if used)>],\n+             \"outputs\": [\n+                 {\n+                     \"pub_key\": <hex encoded x-only public key>,\n+                     \"priv_key_teak\": <hex encoded private key tweak data>.\n+                     \"signature\": <hex encoded signature for the output (produced with spend_priv_key + priv_key_tweak)>\n+                 },\n+                 ...\n+             ]\n+         }\n+     }\n+\n+Wallets should include inputs not in the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list when testing to ensure that only inputs from the list are being used for shared secret derivation. Additionally, receiving wallets should include non-silent payment outputs for themselves in testing to ensure silent payments scanning does not interfere with regular outputs detection.\n+\n+=== Functional tests ===\n+\n+Below is a list of functional tests which should be included in sending and receiving implementations.\n+\n+==== Sending ====\n+\n+* Ensure taproot outputs are excluded during coin selection if the sender does not have access to the key path private key (unless using ''H'' as the taproot internal key)",
      "path": "bip-0352.mediawiki",
      "position": 419,
      "original_position": 393,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": null,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Same as previous comments, this should exclude things that would cause the tx to be skipped for SP, like segwit v>1 and refer back to \"A transaction is not a Silent Payments v0 transaction and should be skipped entirely when scanning if any of the following are true\"",
      "created_at": "2023-07-06T13:47:53Z",
      "updated_at": "2023-07-06T14:00:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1254469116",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254469116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 419,
      "original_line": 419,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254477828",
      "pull_request_review_id": 1516397718,
      "id": 1254477828,
      "node_id": "PRRC_kwDOAN28mc5KxdAE",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7||-\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 187,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": null,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is actually a pretty important section, which should probably have its own header. See later comments.",
      "created_at": "2023-07-06T13:53:56Z",
      "updated_at": "2023-07-06T14:00:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1254477828",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1254477828"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 187,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1257764710",
      "pull_request_review_id": 1521304086,
      "id": 1257764710,
      "node_id": "PRRC_kwDOAN28mc5K9_dm",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7||-\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail",
      "path": "bip-0352.mediawiki",
      "position": 181,
      "original_position": 180,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": 1254380682,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For me, this is a feature. If people are going to include metadata, I'd argue it needs to be formally defined so wallets can actually use it. Writing it this way ensures there is a strict definition of what a v0 address is, but in a way that is forwards compatible with people adding metadata in a v1, v2, etc.\r\n\r\nBut I don't feel super strongly about it; do you see any downsides to requiring a new version for adding metadata?",
      "created_at": "2023-07-10T06:25:07Z",
      "updated_at": "2023-07-10T06:25:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1257764710",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1257764710"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 181,
      "original_line": 181,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1257808323",
      "pull_request_review_id": 1521383573,
      "id": 1257808323,
      "node_id": "PRRC_kwDOAN28mc5K-KHD",
      "diff_hunk": "@@ -0,0 +1,335 @@\n+<pre>\n+  BIP: ????\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-????\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD 2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>change</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte hash + 4-byte little-endian)\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte little-endian\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. For ''Silent Payments v0'':\n+\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 64 byte concatenation of the receiver's public keys, ''B<sub>scan</sub> || B<sub>m</sub>''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character for bech32 strings, whereas a silent payment address requires 115 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR (key path)''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around that as described below.\n+\n+''' P2TR (key path)'''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be used for sending a silent payment. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is being used in a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' is the 256-bit private key(s) of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>'', where ''ecdh_shared_secret'' is a compressed public key\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ecdh_shared_secret || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / silent_payment_version' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / silent_payment_version' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''BIP_NUMBER'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list",
      "path": "bip-0000.mediawiki",
      "position": null,
      "original_position": 260,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "d342de6e48b36e0a11155ca2b553310e083341d2",
      "in_reply_to_id": 1231325070,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a sentence to mention checking and negating taproot keys, if necessary",
      "created_at": "2023-07-10T07:01:39Z",
      "updated_at": "2023-07-10T07:01:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1257808323",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1257808323"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1258374034",
      "pull_request_review_id": 1522254317,
      "id": 1258374034,
      "node_id": "PRRC_kwDOAN28mc5LAUOS",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7||-\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 191,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": 1254417304,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "From what I've heard, the general idea is that soft forks via transaction `nVersion` is deprecated in favor of repurposing `OP_SUCCESS`, using a new witness version, or using a new tapscript leaf version. Not saying it won't *ever* be used, so we could say v0 skips transactions with `nVersion` > 3, but we'd need a new silent payments version if it turns out nVersion=4 is used for something other than a soft fork. Could also be ultra-conservative and say skip anything > 2, but that almost guarantees we'd need to add a new silent payment version if the transaction v3 proposal keeps making progress.\r\n\r\n",
      "created_at": "2023-07-10T14:42:27Z",
      "updated_at": "2023-07-10T14:42:27Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1258374034",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1258374034"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1258463783",
      "pull_request_review_id": 1522395402,
      "id": 1258463783,
      "node_id": "PRRC_kwDOAN28mc5LAqIn",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7||-\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 191,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": 1254417304,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I went ahead and added it as nVersion < 4, so that we don't need to update for transaction relay.",
      "created_at": "2023-07-10T15:49:19Z",
      "updated_at": "2023-07-10T15:49:19Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1258463783",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1258463783"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1258464346",
      "pull_request_review_id": 1522396244,
      "id": 1258464346,
      "node_id": "PRRC_kwDOAN28mc5LAqRa",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7||-\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list",
      "path": "bip-0352.mediawiki",
      "position": 273,
      "original_position": 258,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": 1254434664,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added it here explicitly, but also linked to the new section",
      "created_at": "2023-07-10T15:49:47Z",
      "updated_at": "2023-07-10T15:49:48Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1258464346",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1258464346"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 273,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1258465502",
      "pull_request_review_id": 1522398017,
      "id": 1258465502,
      "node_id": "PRRC_kwDOAN28mc5LAqje",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7||-\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 187,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": 1254477828,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I re-wrote this as its own section, feel free to add more or propose changes. I found that it read better once I reframed it as \"conditions you need to check TO scan,\" vs \"conditions for not scanning\"",
      "created_at": "2023-07-10T15:50:47Z",
      "updated_at": "2023-07-10T15:50:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1258465502",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1258465502"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 187,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1265974527",
      "pull_request_review_id": 1533812027,
      "id": 1265974527,
      "node_id": "PRRC_kwDOAN28mc5LdTz_",
      "diff_hunk": "@@ -303,6 +303,70 @@ If using a seed phrase only style backup, the user can recover the wallet's unsp\n \n Silent payments introduces a new address format and protocol for sending and as such is not compatible with older wallet software or wallets which have not implemented the silent payments protocol.\n \n+== Test Vectors ==\n+\n+A [[bip-0340/test-vectors.csv|collection of test vectors in JSON format]] are provided, along with a [[bip-0340/reference.py|python reference implementation]]. Each test vector consists of a sending test case and corresponding receiving test case. This is to allow sending and receiving to be implemented separately. Test cases use the following schema:",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 6,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "3530d9837b08935d26dd99f38d1981d47227fadb",
      "in_reply_to_id": null,
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think links are wrong here :)",
      "created_at": "2023-07-17T22:49:12Z",
      "updated_at": "2023-07-17T22:49:12Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1265974527",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1265974527"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 345,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1266351225",
      "pull_request_review_id": 1534383417,
      "id": 1266351225,
      "node_id": "PRRC_kwDOAN28mc5Levx5",
      "diff_hunk": "@@ -303,6 +303,70 @@ If using a seed phrase only style backup, the user can recover the wallet's unsp\n \n Silent payments introduces a new address format and protocol for sending and as such is not compatible with older wallet software or wallets which have not implemented the silent payments protocol.\n \n+== Test Vectors ==\n+\n+A [[bip-0340/test-vectors.csv|collection of test vectors in JSON format]] are provided, along with a [[bip-0340/reference.py|python reference implementation]]. Each test vector consists of a sending test case and corresponding receiving test case. This is to allow sending and receiving to be implemented separately. Test cases use the following schema:",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 6,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "3530d9837b08935d26dd99f38d1981d47227fadb",
      "in_reply_to_id": 1265974527,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks! That is indeed the wrong link, will update!",
      "created_at": "2023-07-18T07:30:25Z",
      "updated_at": "2023-07-18T07:30:26Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1266351225",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1266351225"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 345,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1271312933",
      "pull_request_review_id": 1542112568,
      "id": 1271312933,
      "node_id": "PRRC_kwDOAN28mc5LxrIl",
      "diff_hunk": "@@ -0,0 +1,457 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+* The transaction ''nVersion'' is < 4\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 212,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I was wondering how exactly we end up with a limit of 117 characters, maybe it's worth it to include a short breakdown (e.g. as a foot note)? IIUC, this should be\r\n- HRP [2-3 characters]\r\n- separator [1 character]\r\n- version [1 character]\r\n- payload, 66 bytes concatenated pubkeys [ ceil(66*8/5) = 106 characters]\r\n- checksum [6 characters]\r\n\r\ni.e. silent payment addresses have a fixed size of 117 characters on testnet/signet/regtest and 116 characters on mainnet.",
      "created_at": "2023-07-22T15:59:21Z",
      "updated_at": "2023-07-22T15:59:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1271312933",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1271312933"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1273235873",
      "pull_request_review_id": 1544991408,
      "id": 1273235873,
      "node_id": "PRRC_kwDOAN28mc5L5Amh",
      "diff_hunk": "@@ -0,0 +1,457 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+* The transaction ''nVersion'' is < 4\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling",
      "path": "bip-0352.mediawiki",
      "position": 204,
      "original_position": 204,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`label` or  `m` is defined as an integer or an int, which I suppose means it is supposed to be 4 bytes long. Since we need to convert it to a 32 bytes scalar to tweak the spend key wouldn't it be clearer and easier to specify it explicitly as such? I think it would also allow using private keys derived on another adjacent path (say `m/352'/0'/0'/3'`, but that's just an idea)  directly as labels, which could be nice for back up / recovery too. \r\nAnother way would be to just leave labels out of the specification and say this is whatever you can turn into a 256 bits scalar that can tweak a key, and the specific way to obtain that is implementation specific (maybe some services would rather have human readable labels and hash it to obtain the silent payment label)",
      "created_at": "2023-07-25T09:08:05Z",
      "updated_at": "2023-07-25T09:08:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1273235873",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1273235873"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 204,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1275300050",
      "pull_request_review_id": 1548288232,
      "id": 1275300050,
      "node_id": "PRRC_kwDOAN28mc5MA4jS",
      "diff_hunk": "@@ -0,0 +1,457 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+* The transaction ''nVersion'' is < 4\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 284,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thinking about it if labels are not small incremental int as I suggested above we may reuse _tn_. Not sure if it makes a lot of difference in practice though, I don't think it will often happen that a sender wants to pay _that_ many labels of the same receiver in one transaction so that not reusing _tn_ would induce a noticable burden.",
      "created_at": "2023-07-26T17:45:45Z",
      "updated_at": "2023-07-26T17:45:45Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1275300050",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1275300050"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1276162145",
      "pull_request_review_id": 1549654702,
      "id": 1276162145,
      "node_id": "PRRC_kwDOAN28mc5MELBh",
      "diff_hunk": "@@ -0,0 +1,457 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+* The transaction ''nVersion'' is < 4\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling",
      "path": "bip-0352.mediawiki",
      "position": 204,
      "original_position": 204,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "in_reply_to_id": 1273235873,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks for the review @Sosthene00 ! I think you're right that we need to specify this. Defining the label tweak as a 256 bit scalar seems the best choice, since this label `m` ends up as part of the private key when labels are used.\r\n\r\nThe reason for specifying it as an incremental integer is to easily recover your wallet from backup without any extra data about how many labels you used or derived them. The idea is you would pick some very large number `M` when scanning and check all integer values under that. But ultimately, it is up to the receiving client how to implement and I can imagine use cases where the label is an integer with some other meaning (like a product number or invoice number). I think maybe the best approach is like you said: specify that the label integer must be a 256-bit number, and we recommend making it an incremental scheme to enable easy backups.\r\n\r\nRegarding the BIP32 idea, I'm unsure if it's possible to easily check if a public key exists in a given derivation path, without traversing it, right? So you'd still need a datastore to do the efficient \"subtract and lookup\" method when scanning.",
      "created_at": "2023-07-27T11:45:00Z",
      "updated_at": "2023-07-27T11:45:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1276162145",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1276162145"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 204,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1276168993",
      "pull_request_review_id": 1549665784,
      "id": 1276168993,
      "node_id": "PRRC_kwDOAN28mc5MEMsh",
      "diff_hunk": "@@ -0,0 +1,457 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+* The transaction ''nVersion'' is < 4\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 284,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "in_reply_to_id": 1275300050,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's a good point, however, the sender has no idea what kind of label scheme the receiver has used, so it's possible their transaction could be doxxed as a silent payment transaction if the receiver uses an incremental integer scheme. Also worth pointing out that hashing the integer counter for each new output is a relatively cheap operation, and doing so gives us a guarantee that the transaction won't leak information, regardless of the labeling scheme used by the receiver",
      "created_at": "2023-07-27T11:52:01Z",
      "updated_at": "2023-07-27T11:52:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1276168993",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1276168993"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1279087750",
      "pull_request_review_id": 1554434396,
      "id": 1279087750,
      "node_id": "PRRC_kwDOAN28mc5MPVSG",
      "diff_hunk": "@@ -0,0 +1,457 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+* The transaction ''nVersion'' is < 4\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 284,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "in_reply_to_id": 1275300050,
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agree, probably best as it is now.",
      "created_at": "2023-07-31T10:13:01Z",
      "updated_at": "2023-07-31T10:13:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1279087750",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1279087750"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1279098066",
      "pull_request_review_id": 1554451190,
      "id": 1279098066,
      "node_id": "PRRC_kwDOAN28mc5MPXzS",
      "diff_hunk": "@@ -0,0 +1,457 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+* The transaction ''nVersion'' is < 4\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling",
      "path": "bip-0352.mediawiki",
      "position": 204,
      "original_position": 204,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "in_reply_to_id": 1273235873,
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes I was making the assumption that the receiver maintains some kind of labels database to check against incoming candidate transactions. What you mean is that if we use a simple incremental scheme for labels we don't even need a database to find out outputs that belong to us (beside easy backup)? You still need some kind of data storage to match labels to some identity and/or context though, but even if you lose it you won't lose any of your money so that's still something I guess. ",
      "created_at": "2023-07-31T10:23:31Z",
      "updated_at": "2023-07-31T10:23:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1279098066",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1279098066"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 204,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1279139283",
      "pull_request_review_id": 1554517375,
      "id": 1279139283,
      "node_id": "PRRC_kwDOAN28mc5MPh3T",
      "diff_hunk": "@@ -0,0 +1,457 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+* The transaction ''nVersion'' is < 4\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')",
      "path": "bip-0352.mediawiki",
      "position": 285,
      "original_position": 275,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "in_reply_to_id": null,
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think the specification should define the sorting of the `_m_`s in each `_scan_` group. In the reference implementation it just appends the _m_ keys in the order it finds it, meaning that altering the order of the inputs will result in different keys being generated. \r\n\r\nIf this is intended it means that the caller is responsible for the order of the arguments, which is asking for trouble I think (I can't see how the receiver could know for sure the order of the labels the sender used). Otoh it's only a problem when sender wants to pay multiple labels of the same receiver in one transaction, which is arguably rare, but still.\r\n\r\nSee also https://github.com/cygnet3/rust-silentpayments/issues/11",
      "created_at": "2023-07-31T11:02:32Z",
      "updated_at": "2023-07-31T11:02:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1279139283",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1279139283"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 285,
      "original_line": 285,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1279186166",
      "pull_request_review_id": 1554592735,
      "id": 1279186166,
      "node_id": "PRRC_kwDOAN28mc5MPtT2",
      "diff_hunk": "@@ -0,0 +1,457 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+* The transaction ''nVersion'' is < 4\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')",
      "path": "bip-0352.mediawiki",
      "position": 285,
      "original_position": 275,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "in_reply_to_id": 1279139283,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You are correct that changing the ordering will change the outputs created, but this isn't a problem for the receiver: the receiver does not need to know the ordering of the outputs to be able to find them.\r\n\r\nI can see how this would be annoying from a testing perspective, however, because changing the order of the _B<sub>m</sub>_ values will lead to completely different output sets if multiple labels are being paid by the same sender. I'll add a sorting step, but also a footnote that mentions that sorting is not necessary for the protocol but useful for determinism in testing.",
      "created_at": "2023-07-31T11:53:38Z",
      "updated_at": "2023-07-31T12:02:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1279186166",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1279186166"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 285,
      "original_line": 285,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1279246749",
      "pull_request_review_id": 1554696097,
      "id": 1279246749,
      "node_id": "PRRC_kwDOAN28mc5MP8Gd",
      "diff_hunk": "@@ -0,0 +1,457 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+* The transaction ''nVersion'' is < 4\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')",
      "path": "bip-0352.mediawiki",
      "position": 285,
      "original_position": 275,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "in_reply_to_id": 1279139283,
      "user": {
        "login": "Sosthene00",
        "id": 11726747,
        "node_id": "MDQ6VXNlcjExNzI2NzQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/11726747?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Sosthene00",
        "html_url": "https://github.com/Sosthene00",
        "followers_url": "https://api.github.com/users/Sosthene00/followers",
        "following_url": "https://api.github.com/users/Sosthene00/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Sosthene00/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Sosthene00/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Sosthene00/subscriptions",
        "organizations_url": "https://api.github.com/users/Sosthene00/orgs",
        "repos_url": "https://api.github.com/users/Sosthene00/repos",
        "events_url": "https://api.github.com/users/Sosthene00/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Sosthene00/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "After rereading carefully the bip, I see how the receiver would not be affected by this. \r\n\r\nActually sorting the labels as I first thought is indeed impossible, as the sender can't be aware of them. It could sort `m_pubkey`s though, but maybe it doesn't worth it. \r\n\r\nIf it's only a problem with testing, I think adding it inside the specification might be more confusing than really useful, it's probably better to add it as a comment in the reference implementation, so that future implementer won't get confused like I did. \r\n\r\nOr maybe only in a sidenote here, basically saying : \"while the sender modifying the order of `m`s would result in different keys being generated, that doesn't affect the ability of the recipient to find them since it only looks at the difference between his `B_spend` and the actual key in an output, to check if this difference match a `label`. ",
      "created_at": "2023-07-31T12:47:03Z",
      "updated_at": "2023-07-31T12:47:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1279246749",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1279246749"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 285,
      "original_line": 285,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1279250579",
      "pull_request_review_id": 1554702033,
      "id": 1279250579,
      "node_id": "PRRC_kwDOAN28mc5MP9CT",
      "diff_hunk": "@@ -0,0 +1,457 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+* The transaction ''nVersion'' is < 4\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')",
      "path": "bip-0352.mediawiki",
      "position": 285,
      "original_position": 275,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "in_reply_to_id": 1279139283,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> If it's only a problem with testing, I think adding it inside the specification might be more confusing than really useful, it's probably better to add it as a comment in the reference implementation, so that future implementer won't get confused like I did.\r\n\r\nAgreed. I'll add an explanation to the testing section of the BIP, along with a comment in the reference implementation.",
      "created_at": "2023-07-31T12:50:27Z",
      "updated_at": "2023-07-31T12:50:28Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1279250579",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1279250579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 285,
      "original_line": 285,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282025091",
      "pull_request_review_id": 1559199327,
      "id": 1282025091,
      "node_id": "PRRC_kwDOAN28mc5MaiaD",
      "diff_hunk": "@@ -0,0 +1,461 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 185,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "64da95202f79e470f22571953622a7ea90a5fdf8",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This could be read as recommending that P2TR inputs explicitly use `SIGHASH_ALL`, while hopefully `SIGHASH_DEFAULT` will be more common. Perhaps you may want to explicitly mention that `SIGHASH_DEFAULT` is preferred where applicable, and otherwise `SIGHASH_ALL` should be used.",
      "created_at": "2023-08-02T14:52:47Z",
      "updated_at": "2023-08-02T15:26:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1282025091",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282025091"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282031389",
      "pull_request_review_id": 1559199327,
      "id": 1282031389,
      "node_id": "PRRC_kwDOAN28mc5Maj8d",
      "diff_hunk": "@@ -0,0 +1,461 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 194,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "64da95202f79e470f22571953622a7ea90a5fdf8",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is ambiguous. I first thought it refers to an output, but after reading the footnote, I surmise that only an _input spending a new output type_ would be an issue. Could you clarify whether an output with an unknown type would be an issue?",
      "created_at": "2023-08-02T14:57:07Z",
      "updated_at": "2023-08-02T15:26:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1282031389",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282031389"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282052593",
      "pull_request_review_id": 1559199327,
      "id": 1282052593,
      "node_id": "PRRC_kwDOAN28mc5MapHx",
      "diff_hunk": "@@ -0,0 +1,461 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires ''at least'' 117 characters. Additionally, since higher versions may add to the data field, it is recommended implementations use a limit of 1023 characters (see [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#checksum-design BIP173: Checksum design] for more details).\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Sort the outpoints with ''sort<sub>outpoints</sub>(outpoints)''<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>''\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+** Optionally, if the sending wallet implements receiving silent payments, it can create change outputs in the following manner:",
      "path": "bip-0352.mediawiki",
      "position": 295,
      "original_position": 286,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "64da95202f79e470f22571953622a7ea90a5fdf8",
      "in_reply_to_id": null,
      "user": {
        "login": "murchandamus",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/murchandamus",
        "html_url": "https://github.com/murchandamus",
        "followers_url": "https://api.github.com/users/murchandamus/followers",
        "following_url": "https://api.github.com/users/murchandamus/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/murchandamus/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/murchandamus/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/murchandamus/subscriptions",
        "organizations_url": "https://api.github.com/users/murchandamus/orgs",
        "repos_url": "https://api.github.com/users/murchandamus/repos",
        "events_url": "https://api.github.com/users/murchandamus/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/murchandamus/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If the recommendation is that Silent Payment users use BIP32 to derive scan and spend key, why would they not use BIP32 to derive change addresses but opt into creating change outputs from their scan key? It’s not clear to me what their motivation to do so would be.",
      "created_at": "2023-08-02T15:13:31Z",
      "updated_at": "2023-08-02T15:26:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1282052593",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282052593"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 295,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282837667",
      "pull_request_review_id": 1560515910,
      "id": 1282837667,
      "node_id": "PRRC_kwDOAN28mc5Mdoyj",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7||-\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 191,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": 1254417304,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Circling back, I ended up removing the nVersion restriction after a few offline conversations regarding how this field is meant to be used. TLDR; I think it's safe to assume nVersion will not be used for signaling a soft fork, and thus only be used to communicate policy changes.",
      "created_at": "2023-08-03T08:28:27Z",
      "updated_at": "2023-08-03T08:28:27Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1282837667",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282837667"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282839564",
      "pull_request_review_id": 1560518888,
      "id": 1282839564,
      "node_id": "PRRC_kwDOAN28mc5MdpQM",
      "diff_hunk": "@@ -0,0 +1,457 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+* The transaction ''nVersion'' is < 4\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')",
      "path": "bip-0352.mediawiki",
      "position": 285,
      "original_position": 275,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "in_reply_to_id": 1279139283,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added a comment to the reference implementation and mentioned this in the testing section",
      "created_at": "2023-08-03T08:30:02Z",
      "updated_at": "2023-08-03T08:30:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1282839564",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282839564"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 285,
      "original_line": 285,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282863031",
      "pull_request_review_id": 1560557030,
      "id": 1282863031,
      "node_id": "PRRC_kwDOAN28mc5Mdu-3",
      "diff_hunk": "@@ -0,0 +1,457 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+* The transaction ''nVersion'' is < 4\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 212,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "in_reply_to_id": 1271312933,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've updated this to recommend raising the character limit to 1023 for silent payment addresses. This is because new versions of silent payments may add additional bytes to the data field. For forward compatibility, the specification says a silent payments v0 sender can send to v0 - v30 addresses - they just read the first 66 bytes and discard the rest. This doesn't work if there is a size limit on the address since a v0 sender would fail to decode a v1 - v30 address.\r\n\r\nAlso, raising the limit seems \"safe\" per BIP173 and IIUC this is what lightning is using for their invoices.",
      "created_at": "2023-08-03T08:47:48Z",
      "updated_at": "2023-08-03T08:47:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1282863031",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282863031"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282863718",
      "pull_request_review_id": 1560558057,
      "id": 1282863718,
      "node_id": "PRRC_kwDOAN28mc5MdvJm",
      "diff_hunk": "@@ -0,0 +1,461 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 185,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "64da95202f79e470f22571953622a7ea90a5fdf8",
      "in_reply_to_id": 1282025091,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Great point! I'll update this ",
      "created_at": "2023-08-03T08:48:22Z",
      "updated_at": "2023-08-03T08:48:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1282863718",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282863718"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282865481",
      "pull_request_review_id": 1560560536,
      "id": 1282865481,
      "node_id": "PRRC_kwDOAN28mc5MdvlJ",
      "diff_hunk": "@@ -0,0 +1,461 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 194,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "64da95202f79e470f22571953622a7ea90a5fdf8",
      "in_reply_to_id": 1282031389,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Great catch, this is referring to inputs that spend unknown output types. Having an unknown output type in the outputs is perfectly fine. I'll update this to be explicit that we are referring to inputs here.",
      "created_at": "2023-08-03T08:49:41Z",
      "updated_at": "2023-08-03T08:49:42Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1282865481",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282865481"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282878799",
      "pull_request_review_id": 1560580110,
      "id": 1282878799,
      "node_id": "PRRC_kwDOAN28mc5Mdy1P",
      "diff_hunk": "@@ -0,0 +1,461 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires ''at least'' 117 characters. Additionally, since higher versions may add to the data field, it is recommended implementations use a limit of 1023 characters (see [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#checksum-design BIP173: Checksum design] for more details).\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Sort the outpoints with ''sort<sub>outpoints</sub>(outpoints)''<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>''\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+** Optionally, if the sending wallet implements receiving silent payments, it can create change outputs in the following manner:",
      "path": "bip-0352.mediawiki",
      "position": 295,
      "original_position": 286,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "64da95202f79e470f22571953622a7ea90a5fdf8",
      "in_reply_to_id": 1282052593,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If a wallet is only doing silent payments (i.e. doesn't have other descriptors), then I'd argue it's much simpler to use the silent payments protocol for change: you use BIP32 one time to get a spend and scan key and then the rest of the wallet code handles all UTXOs / rescanning / spending, etc as silent payment outputs. For a silent payments only wallet, this also means there are no gap limit concerns when re-scanning / importing from a backup.\r\n\r\nIf a wallet already supports using BIP32 and other descriptors and they are ADDING silent payments, then I don't really see an advantage of one over the other except that a user may want to keep change outputs created from paying a silent payment address separate from the rest of the change outputs in their wallet.",
      "created_at": "2023-08-03T08:58:55Z",
      "updated_at": "2023-08-03T08:58:55Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1282878799",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282878799"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 295,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282880543",
      "pull_request_review_id": 1560582732,
      "id": 1282880543,
      "node_id": "PRRC_kwDOAN28mc5MdzQf",
      "diff_hunk": "@@ -0,0 +1,457 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+* The transaction ''nVersion'' is < 4\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 212,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "cfe0771a0408a2d2de278d4e95bb9a33bd1615b2",
      "in_reply_to_id": 1271312933,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Also, yes, it would be nice to add a breakdown to the footnotes! Thanks for providing one!",
      "created_at": "2023-08-03T09:00:18Z",
      "updated_at": "2023-08-03T09:00:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1282880543",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1282880543"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283099456",
      "pull_request_review_id": 1560935373,
      "id": 1283099456,
      "node_id": "PRRC_kwDOAN28mc5MeotA",
      "diff_hunk": "@@ -0,0 +1,451 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 32 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as native Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7||-\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+A transaction is not a ''Silent Payments v0'' transaction and should be skipped entirely when scanning if any of the following are true:\n+\n+* The transaction does not contain any BIP341 taproot outputs\n+* The transaction does not have at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction inputs contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires 117 characters.\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>'', sorted by txid and vout, ascending order<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (as defined in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs]), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+** Optionally, if the sending wallet implements receiving silent payments, it can create change outputs in the following manner:\n+*** Let ''A<sub>change</sub> = A<sub>spend</sub> + sha256(ser<sub>256</sub>(a<sub>scan</sub>))·G''\n+*** Let ''change_shared_secret = outpoints_hash·a·A<sub>scan</sub>''\n+*** Let ''n = 0''\n+*** For each change output desired:\n+**** Let ''c<sub>n</sub> = sha256(ser<sub>P</sub>(change_shared_secret) || ser<sub>32</sub>(n))''\n+**** Let ''C<sub>n</sub> = A<sub>change</sub> + c<sub>n</sub>·G''\n+**** Encode ''C<sub>n</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+**** Repeat with ''n++'' for additional change outputs\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+    Spend private key: m / purpose' / coin_type' / account' / 0' / 0\n+     Scan private key: m / purpose' / coin_type' / account' / 1' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''352'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+For each transaction the receiving wallet suspects might be a silent payment to themselves, it must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Let ''ecdh_shared_secret = outpoints_hash·b<sub>scan</sub>·A''\n+* Check for outputs:\n+** Let ''outputs_to_check = the taproot output key from each unspent taproot output in the transaction''\n+** Starting with ''n = 0'':\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Compute ''P<sub>n</sub> = B<sub>spend</sub> + t<sub>n</sub>·G''\n+*** For each ''output'' in ''outputs_to_check'':\n+**** If ''P<sub>n</sub>'' equals ''output'':\n+***** Add ''P<sub>n</sub>'' to the wallet\n+***** Remove ''output'' from ''outputs_to_check'' and rescan ''outputs_to_check'' with ''n++''\n+**** Else, if the wallet has precomputed labels (including the change label, if used)<ref name=\"precompute_labels\">''' Why precompute labels?''' Naively, a wallet could store some max integer ''M'' which indicates the total number of labels it has used. When checking a transaction, the wallet would need to add all possible labels to each output. This ends up being ''n·m'' additions, where ''n'' is the number of outputs in the transaction and ''m'' is the number of labels in the wallet. By precomputing the labels, the wallet only needs to compute ''m·G'' once per label and can determine if a label was used via a lookup, rather than adding each label to each output.</ref>:",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 319,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "dc0b30711bafd37aafac70d15d5e67bccd532e15",
      "in_reply_to_id": 1254460747,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is only relevant when re-scanning, so I think we should mention something there. It doesn't really make sense to me for a new wallet to start scanning and always scan for change and labels when it knows for a fact it does not use them.",
      "created_at": "2023-08-03T11:58:05Z",
      "updated_at": "2023-08-03T11:58:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283099456",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283099456"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 319,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283753889",
      "pull_request_review_id": 1561906506,
      "id": 1283753889,
      "node_id": "PRRC_kwDOAN28mc5MhIeh",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 28,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Extra whitespace before footnote:\r\n```suggestion\r\nHowever, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain<ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\r\n```",
      "created_at": "2023-08-03T21:50:21Z",
      "updated_at": "2023-08-03T21:55:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283753889",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283753889"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283754391",
      "pull_request_review_id": 1561906506,
      "id": 1283754391,
      "node_id": "PRRC_kwDOAN28mc5MhImX",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 60,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nSince ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic-curve Diffie–Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (i.e. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\r\n```",
      "created_at": "2023-08-03T21:51:05Z",
      "updated_at": "2023-08-03T21:55:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283754391",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283754391"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 60,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283754458",
      "pull_request_review_id": 1561906506,
      "id": 1283754458,
      "node_id": "PRRC_kwDOAN28mc5MhIna",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 64,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nIn order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we include an integer in the following manner:\r\n```",
      "created_at": "2023-08-03T21:51:11Z",
      "updated_at": "2023-08-03T21:55:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283754458",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283754458"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 64,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283754627",
      "pull_request_review_id": 1561906506,
      "id": 1283754627,
      "node_id": "PRRC_kwDOAN28mc5MhIqD",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 91,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Blind-Diffie-Hellman → Blind Diffie–Hellman\r\n```suggestion\r\nIn our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind Diffie–Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\r\n```",
      "created_at": "2023-08-03T21:51:27Z",
      "updated_at": "2023-08-03T21:55:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283754627",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283754627"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283755572",
      "pull_request_review_id": 1561906506,
      "id": 1283755572,
      "node_id": "PRRC_kwDOAN28mc5MhI40",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:",
      "path": "bip-0352.mediawiki",
      "position": 101,
      "original_position": 101,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There should be a footnote explaining the rationale for having an independent scan key, as opposed to deriving it from the spend key. You mentioned in the PR review club that one reason was redundancy (a compromised spend key doesn't lead to loss of funds without also a compromised scan key), which I take some issue with<sup>1</sup>, and also something about labels not working without an independent scan key, which sounds better, but would be great to have an explanation for.\r\n\r\n<hr>\r\n\r\n<sup>1</sup> This kind of silent redundancy (pun not intended) isn't IMO something that should be purposely built into a protocol as it breaks the separation of responsibilities. The scan key is responsible for scanning for payments, and the consequence of its compromise is loss of privacy. The spend key is responsible for spending received outputs, and the consequence of its compromise should be understood as loss of funds, even if by a quirk of the protocol it doesn't necessarily have to be. Redundancy can be built on top of the spend key by using MuSig2 or FROST, not by treating the scan key as more important than it is.\r\n\r\nAlso the fact that both the spend and scan key are required for spending should perhaps be explicitly mentioned somewhere. Due to the naming one might think that the spend key is enough.",
      "created_at": "2023-08-03T21:52:46Z",
      "updated_at": "2023-08-03T21:55:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283755572",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283755572"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283755699",
      "pull_request_review_id": 1561906506,
      "id": 1283755699,
      "node_id": "PRRC_kwDOAN28mc5MhI6z",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 117,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\r\n* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>)'' etc.\r\n\r\nAlice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\r\n\r\n* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\r\n* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G'', 2·G'' etc.) that the wallet has previously used\r\n```",
      "created_at": "2023-08-03T21:52:57Z",
      "updated_at": "2023-08-03T21:55:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283755699",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283755699"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": 111,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283755827",
      "pull_request_review_id": 1561906506,
      "id": 1283755827,
      "node_id": "PRRC_kwDOAN28mc5MhI8z",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 138,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when computing the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\r\n```",
      "created_at": "2023-08-03T21:53:09Z",
      "updated_at": "2023-08-03T21:55:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283755827",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283755827"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 138,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283755953",
      "pull_request_review_id": 1561906506,
      "id": 1283755953,
      "node_id": "PRRC_kwDOAN28mc5MhI-x",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 139,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "sort<sub>outpoints</sub>(v) is only used once, so it doesn't make much sense to define a special function for it. Also, it confusingly sorts the vector in place instead of returning a new value like all the other functions. Lastly, what was wrong with the way it was worded in Outpoints hash? Seems completely fine to me:\r\n> Let _outpoints_ = _outpoint<sub>0</sub>_ || … || _outpoint<sub>n</sub>_, sorted by txid and vout, ascending order\r\n",
      "created_at": "2023-08-03T21:53:22Z",
      "updated_at": "2023-08-03T21:55:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283755953",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283755953"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756047",
      "pull_request_review_id": 1561906506,
      "id": 1283756047,
      "node_id": "PRRC_kwDOAN28mc5MhJAP",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 148,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The document is inconsistent in both the casing and italicization of \"silent payments\". Unsure about the casing, but I'd definitely drop the italics.",
      "created_at": "2023-08-03T21:53:29Z",
      "updated_at": "2023-08-03T21:55:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283756047",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756109",
      "pull_request_review_id": 1561906506,
      "id": 1283756109,
      "node_id": "PRRC_kwDOAN28mc5MhJBN",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail",
      "path": "bip-0352.mediawiki",
      "position": 183,
      "original_position": 183,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Some rationale for this would be nice. What kind of changes could be made in a new version without breaking compatibility with v0?",
      "created_at": "2023-08-03T21:53:36Z",
      "updated_at": "2023-08-03T21:55:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283756109",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756109"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": 182,
      "original_start_line": 182,
      "start_side": "RIGHT",
      "line": 183,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756169",
      "pull_request_review_id": 1561906506,
      "id": 1283756169,
      "node_id": "PRRC_kwDOAN28mc5MhJCJ",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''DEFAULT, ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations use ''SIGHASH_DEFAULT'' when applicable, or ''SIGHASH_ALL''<ref name=\"why_sighash_default_or_all\">'''Why recommend ''SIGHASH_[DEFAULT|ALL]''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 185,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A few suggestions:\r\n* Break italics for commas.\r\n* Improved wording on the difference between SIGHASH_ALL and SIGHASH_DEFAULT.\r\n* The footnote doesn't say why DEFAULT/ALL is the preferred sighash flag, only why ANYONECANPAY is unsafe, so the footnote name should reflect that.\r\n* Remove italics from the link to section. This is not consistent throughout the document and other BIPs I checked don't do this.\r\n\r\n```suggestion\r\n* The sender should sign with one of the sighash flags ''DEFAULT'', ''ALL'', ''SINGLE'', ''NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations use ''SIGHASH_ALL'' (''SIGHASH_DEFAULT'' for taproot inputs) when possible<ref name=\"why_not_sighash_anyonecanpay\">'''Why is it unsafe to use ''SIGHASH_ANYONECANPAY''?''' Since the output address for the receiver is derived from from the sum of the [[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]] public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\r\n```",
      "created_at": "2023-08-03T21:53:39Z",
      "updated_at": "2023-08-03T21:55:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283756169",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756169"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 185,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756259",
      "pull_request_review_id": 1561906506,
      "id": 1283756259,
      "node_id": "PRRC_kwDOAN28mc5MhJDj",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''DEFAULT, ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations use ''SIGHASH_DEFAULT'' when applicable, or ''SIGHASH_ALL''<ref name=\"why_sighash_default_or_all\">'''Why recommend ''SIGHASH_[DEFAULT|ALL]''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not spend a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules. Note: this restriction only applies to the inputs of a transaction.</ref>\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires ''at least'' 117 characters<ref name=\"why_117_chars\"> ''' Why do silent payment addresses need at least 117 characters?''' A silent payment address is a bech32m encoding comprised of the following parts:\n+\n+\n+* HRP [2-3 characters]\n+* separator [1 character]\n+* version [1-2 characters]\n+* payload, 66 bytes concatenated pubkeys [ceil(66*8/5) = 106 characters]\n+* checksum [6 characters]\n+\n+\n+For a silent payments v0 address, this results in a 117 character address when using a 3 character HRP. Future versions of silent payment addresses may add to the payload, which is why a 1023 character limit is suggested.</ref>. Additionally, since higher versions may add to the data field, it is recommended implementations use a limit of 1023 characters (see [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#checksum-design BIP173: Checksum design] for more details).\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Sort the outpoints with ''sort<sub>outpoints</sub>(outpoints)''<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 229,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n* Sort the outpoints with ''sort<sub>outpoints</sub>(outpoints)''<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment output does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\r\n```",
      "created_at": "2023-08-03T21:53:48Z",
      "updated_at": "2023-08-03T21:55:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283756259",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 229,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756339",
      "pull_request_review_id": 1561906506,
      "id": 1283756339,
      "node_id": "PRRC_kwDOAN28mc5MhJEz",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''DEFAULT, ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations use ''SIGHASH_DEFAULT'' when applicable, or ''SIGHASH_ALL''<ref name=\"why_sighash_default_or_all\">'''Why recommend ''SIGHASH_[DEFAULT|ALL]''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not spend a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules. Note: this restriction only applies to the inputs of a transaction.</ref>\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires ''at least'' 117 characters<ref name=\"why_117_chars\"> ''' Why do silent payment addresses need at least 117 characters?''' A silent payment address is a bech32m encoding comprised of the following parts:\n+\n+\n+* HRP [2-3 characters]\n+* separator [1 character]\n+* version [1-2 characters]\n+* payload, 66 bytes concatenated pubkeys [ceil(66*8/5) = 106 characters]\n+* checksum [6 characters]\n+\n+\n+For a silent payments v0 address, this results in a 117 character address when using a 3 character HRP. Future versions of silent payment addresses may add to the payload, which is why a 1023 character limit is suggested.</ref>. Additionally, since higher versions may add to the data field, it is recommended implementations use a limit of 1023 characters (see [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#checksum-design BIP173: Checksum design] for more details).\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Sort the outpoints with ''sort<sub>outpoints</sub>(outpoints)''<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>''\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 242,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Might as well write out explicitly how we work around this since it's not that much longer:\r\n```suggestion\r\nInputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this by using only the output public key.\r\n```",
      "created_at": "2023-08-03T21:53:55Z",
      "updated_at": "2023-08-03T21:55:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283756339",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756339"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756524",
      "pull_request_review_id": 1561906506,
      "id": 1283756524,
      "node_id": "PRRC_kwDOAN28mc5MhJHs",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''DEFAULT, ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations use ''SIGHASH_DEFAULT'' when applicable, or ''SIGHASH_ALL''<ref name=\"why_sighash_default_or_all\">'''Why recommend ''SIGHASH_[DEFAULT|ALL]''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not spend a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules. Note: this restriction only applies to the inputs of a transaction.</ref>\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires ''at least'' 117 characters<ref name=\"why_117_chars\"> ''' Why do silent payment addresses need at least 117 characters?''' A silent payment address is a bech32m encoding comprised of the following parts:\n+\n+\n+* HRP [2-3 characters]\n+* separator [1 character]\n+* version [1-2 characters]\n+* payload, 66 bytes concatenated pubkeys [ceil(66*8/5) = 106 characters]\n+* checksum [6 characters]\n+\n+\n+For a silent payments v0 address, this results in a 117 character address when using a 3 character HRP. Future versions of silent payment addresses may add to the payload, which is why a 1023 character limit is suggested.</ref>. Additionally, since higher versions may add to the data field, it is recommended implementations use a limit of 1023 characters (see [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#checksum-design BIP173: Checksum design] for more details).\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Sort the outpoints with ''sort<sub>outpoints</sub>(outpoints)''<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>''\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 295,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Extra question mark:\r\n```suggestion\r\n*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>'' when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\r\n```",
      "created_at": "2023-08-03T21:54:11Z",
      "updated_at": "2023-08-03T21:55:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283756524",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756524"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756593",
      "pull_request_review_id": 1561906506,
      "id": 1283756593,
      "node_id": "PRRC_kwDOAN28mc5MhJIx",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''DEFAULT, ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations use ''SIGHASH_DEFAULT'' when applicable, or ''SIGHASH_ALL''<ref name=\"why_sighash_default_or_all\">'''Why recommend ''SIGHASH_[DEFAULT|ALL]''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not spend a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules. Note: this restriction only applies to the inputs of a transaction.</ref>\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires ''at least'' 117 characters<ref name=\"why_117_chars\"> ''' Why do silent payment addresses need at least 117 characters?''' A silent payment address is a bech32m encoding comprised of the following parts:\n+\n+\n+* HRP [2-3 characters]\n+* separator [1 character]\n+* version [1-2 characters]\n+* payload, 66 bytes concatenated pubkeys [ceil(66*8/5) = 106 characters]\n+* checksum [6 characters]\n+\n+\n+For a silent payments v0 address, this results in a 117 character address when using a 3 character HRP. Future versions of silent payment addresses may add to the payload, which is why a 1023 character limit is suggested.</ref>. Additionally, since higher versions may add to the data field, it is recommended implementations use a limit of 1023 characters (see [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#checksum-design BIP173: Checksum design] for more details).\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Sort the outpoints with ''sort<sub>outpoints</sub>(outpoints)''<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>''\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+** Optionally, if the sending wallet implements receiving silent payments, it can create change outputs in the following manner:\n+*** Let ''A<sub>change</sub> = A<sub>spend</sub> + sha256(ser<sub>256</sub>(a<sub>scan</sub>))·G''\n+*** Let ''change_shared_secret = outpoints_hash·a·A<sub>scan</sub>''\n+*** Let ''n = 0''\n+*** For each change output desired:\n+**** Let ''c<sub>n</sub> = sha256(ser<sub>P</sub>(change_shared_secret) || ser<sub>32</sub>(n))''\n+**** Let ''C<sub>n</sub> = A<sub>change</sub> + c<sub>n</sub>·G''\n+**** Encode ''C<sub>n</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+**** Repeat with ''n++'' for additional change outputs\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+     Scan private key: m / purpose' / coin_type' / account' / 1' / 0\n+    Spend private key: m / purpose' / coin_type' / account' / 0' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''352'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+If each of the checks in ''[[#scanning-transactions|Scanning transactions]]'' passes, the receiving wallet must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Let ''ecdh_shared_secret = outpoints_hash·b<sub>scan</sub>·A''\n+* Check for outputs:\n+** Let ''outputs_to_check = the taproot output key from each unspent taproot output in the transaction''",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 328,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n** Let ''outputs_to_check'' be the taproot output keys from all unspent taproot outputs in the transaction\r\n```",
      "created_at": "2023-08-03T21:54:16Z",
      "updated_at": "2023-08-03T21:55:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283756593",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756593"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 328,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756628",
      "pull_request_review_id": 1561906506,
      "id": 1283756628,
      "node_id": "PRRC_kwDOAN28mc5MhJJU",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''DEFAULT, ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations use ''SIGHASH_DEFAULT'' when applicable, or ''SIGHASH_ALL''<ref name=\"why_sighash_default_or_all\">'''Why recommend ''SIGHASH_[DEFAULT|ALL]''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not spend a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules. Note: this restriction only applies to the inputs of a transaction.</ref>\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires ''at least'' 117 characters<ref name=\"why_117_chars\"> ''' Why do silent payment addresses need at least 117 characters?''' A silent payment address is a bech32m encoding comprised of the following parts:\n+\n+\n+* HRP [2-3 characters]\n+* separator [1 character]\n+* version [1-2 characters]\n+* payload, 66 bytes concatenated pubkeys [ceil(66*8/5) = 106 characters]\n+* checksum [6 characters]\n+\n+\n+For a silent payments v0 address, this results in a 117 character address when using a 3 character HRP. Future versions of silent payment addresses may add to the payload, which is why a 1023 character limit is suggested.</ref>. Additionally, since higher versions may add to the data field, it is recommended implementations use a limit of 1023 characters (see [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#checksum-design BIP173: Checksum design] for more details).\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Sort the outpoints with ''sort<sub>outpoints</sub>(outpoints)''<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>''\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+** Optionally, if the sending wallet implements receiving silent payments, it can create change outputs in the following manner:\n+*** Let ''A<sub>change</sub> = A<sub>spend</sub> + sha256(ser<sub>256</sub>(a<sub>scan</sub>))·G''\n+*** Let ''change_shared_secret = outpoints_hash·a·A<sub>scan</sub>''\n+*** Let ''n = 0''\n+*** For each change output desired:\n+**** Let ''c<sub>n</sub> = sha256(ser<sub>P</sub>(change_shared_secret) || ser<sub>32</sub>(n))''\n+**** Let ''C<sub>n</sub> = A<sub>change</sub> + c<sub>n</sub>·G''\n+**** Encode ''C<sub>n</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+**** Repeat with ''n++'' for additional change outputs\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+     Scan private key: m / purpose' / coin_type' / account' / 1' / 0\n+    Spend private key: m / purpose' / coin_type' / account' / 0' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''352'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+If each of the checks in ''[[#scanning-transactions|Scanning transactions]]'' passes, the receiving wallet must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Let ''ecdh_shared_secret = outpoints_hash·b<sub>scan</sub>·A''\n+* Check for outputs:\n+** Let ''outputs_to_check = the taproot output key from each unspent taproot output in the transaction''\n+** Starting with ''n = 0'':\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Compute ''P<sub>n</sub> = B<sub>spend</sub> + t<sub>n</sub>·G''\n+*** For each ''output'' in ''outputs_to_check'':\n+**** If ''P<sub>n</sub>'' equals ''output'':\n+***** Add ''P<sub>n</sub>'' to the wallet\n+***** Remove ''output'' from ''outputs_to_check'' and rescan ''outputs_to_check'' with ''n++''\n+**** Else, if the wallet has precomputed labels (including the change label, if used)<ref name=\"precompute_labels\">''' Why precompute labels?''' Precomputing the labels is not strictly necessary: a wallet could track the max number of labels it has used (call it ''M'') and scan for labels by adding ''m·G'' to ''P<sub>0</sub>'' for each label ''m'' up to ''M'' and comparing to the transaction outputs. This is more performant than precomputing the labels and checking via subtraction in cases where the number of eligible outputs exceeds the number of labels in use. In practice this will mainly apply to users that choose never to use labels, or users that use a single label for generating silent payment change outputs. If using a large number of labels, the wallet would need to add all possible labels to each output. This ends up being ''n·M'' additions, where ''n'' is the number of outputs in the transaction and ''M'' is the number of labels in the wallet. By precomputing the labels, the wallet only needs to compute ''m·G'' once when creating the labeled address and can determine if a label was used via a lookup, rather than adding each label to each output.</ref>:\n+***** Compute ''m·G = output - P<sub>n</sub>''\n+***** Check if ''m·G'' exists in the list of labels used by the wallet\n+***** If a match is found:\n+****** Add the ''P<sub>n</sub> + m·G'' to the wallet\n+****** Remove ''output'' from ''outputs_to_check'' and rescan ''outputs_to_check'' with ''n++''\n+***** If the label is not found, negate ''output'' and check again\n+*** If no matches are found, stop\n+",
      "path": "bip-0352.mediawiki",
      "position": 343,
      "original_position": 344,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "There is no section for speding outputs, like there is for creating and scanning. While it's not exceedingly difficult to figure out how to calculate the private key of a silent payment output once it's detected in scanning, I think the procedure should be explicitly stated.",
      "created_at": "2023-08-03T21:54:20Z",
      "updated_at": "2023-08-03T21:55:37Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1283756628",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1283756628"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 343,
      "original_line": 343,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1284087831",
      "pull_request_review_id": 1562339110,
      "id": 1284087831,
      "node_id": "PRRC_kwDOAN28mc5MiaAX",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 139,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": 1283755953,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It was mentioned by another reviewer offline that how to sort the outpoints was a bit unclear, but I'm leaning toward taking it out and just mentioning lexicographic sorting here. Something like:\r\n\r\n> Let _outpoints = outpoint<sub>0</sub> || ... || outpoint<sub>n</sub>_, sorted lexicographically by txid and vout, ascending order",
      "created_at": "2023-08-04T07:35:58Z",
      "updated_at": "2023-08-04T07:35:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1284087831",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1284087831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1284107566",
      "pull_request_review_id": 1562368612,
      "id": 1284107566,
      "node_id": "PRRC_kwDOAN28mc5Mie0u",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail",
      "path": "bip-0352.mediawiki",
      "position": 183,
      "original_position": 183,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": 1283756109,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Here are a few (admittedly contrived) examples:\r\n\r\n* A new output type gets added to the \"Inputs for shared secret derivation\" list. This would be a new address version so that senders know they can include the new output type when sending to a v1 address, and v0 senders can also send to the v1 address using the v0 rules.\r\n* A new output type gets added and is meant to replace taproot, so now the v1 is interpreted as \"create outputs as <new output type> if possible, otherwise create taproot outputs\"\r\n* Some solution for optimistic notifications develops and the receiver adds some metadata to the payload to indicate how they want to receive notifications (nostr, simplex, hand-wavy p2p messaging that doesn't exist yet). A v1 sender would parse that extra metadata and use it, whereas a v0 sender would read the first 66 bytes and ignore the rest.\r\n* Some fancy new key type is added for quantum resistance and the key is added as a third public key to the payload. v1 knows to use the third key, whereas a v0 sender use the first 66 bytes and discards the rest",
      "created_at": "2023-08-04T07:54:23Z",
      "updated_at": "2023-08-04T07:54:23Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1284107566",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1284107566"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": 182,
      "original_start_line": 182,
      "start_side": "RIGHT",
      "line": 183,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1284169101",
      "pull_request_review_id": 1562466203,
      "id": 1284169101,
      "node_id": "PRRC_kwDOAN28mc5Mit2N",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:",
      "path": "bip-0352.mediawiki",
      "position": 101,
      "original_position": 101,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": 1283755572,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> labels not working without an independent scan key\r\n\r\nTo be precise, my point was that for labels to work, there is no way for the sender to infer the spend public key from the scan public key. The suggestion from the review club was if we can somehow derive the spend private key from the scan private key, there might be a way for the sender to derive the spend public key from the scan public key, allowing us to post one public key instead of two.\r\n\r\nEven if the spend key is derived from the scan key, labels work by adding another public key (_m·G_) to the spend public key, where _m_ is unknown to the sender.\r\n\r\n> This kind of silent redundancy (pun not intended) isn't IMO something that should be purposely built into a protocol as it breaks the separation of responsibilities.\r\n\r\nYou make a really good point. First, I agree we need to be more explicit: both the spend key and scan key are required to spend funds. The scan key is needed for finding the \"shared secret\" portion of the private key and the spend key is needed to ensure it is only spendable by the recipient. Given that, having independent derivation is a weak argument in that it only addresses one very narrow case: you compromise the spend key, but you don't compromise your BIP32 master key.\r\n\r\nOriginally, we had the scan key defined as the hash of the spend key, which then allows you to derive the spend key with or without BIP32. What I'm unsure of is what's easier/safer for hardware wallets: hashing a spend key and exporting that, or exporting a private key from a specific derivation path. Depending on the answer to that question, I may be more inclined to go back to the original: _scan_key = hash(spend_key)_",
      "created_at": "2023-08-04T08:56:42Z",
      "updated_at": "2023-08-04T08:56:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1284169101",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1284169101"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1284196083",
      "pull_request_review_id": 1562509110,
      "id": 1284196083,
      "node_id": "PRRC_kwDOAN28mc5Mi0bz",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 148,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": 1283756047,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A quick grammar refresher led me to believe lowercasing throughout is probably the best option.",
      "created_at": "2023-08-04T09:23:32Z",
      "updated_at": "2023-08-04T09:23:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1284196083",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1284196083"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1284590202",
      "pull_request_review_id": 1563148939,
      "id": 1284590202,
      "node_id": "PRRC_kwDOAN28mc5MkUp6",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 117,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": 1283755699,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "My bad, should be `''1·G'', ''2·G'' etc.`.",
      "created_at": "2023-08-04T15:52:31Z",
      "updated_at": "2023-08-04T15:52:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1284590202",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1284590202"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": 111,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 117,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285260943",
      "pull_request_review_id": 1564200798,
      "id": 1285260943,
      "node_id": "PRRC_kwDOAN28mc5Mm4aP",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:",
      "path": "bip-0352.mediawiki",
      "position": 101,
      "original_position": 101,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "30f957d7e9e148bdea91e89cf455fe0a11e296ff",
      "in_reply_to_id": 1283755572,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">there might be a way for the sender to derive the spend public key from the scan public key, allowing us to post one public key instead of two\r\n\r\nThat is impossible (unless scan key == spend key, but then that would defeat the purpose)",
      "created_at": "2023-08-06T20:49:44Z",
      "updated_at": "2023-08-06T20:49:45Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1285260943",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285260943"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285261787",
      "pull_request_review_id": 1564201601,
      "id": 1285261787,
      "node_id": "PRRC_kwDOAN28mc5Mm4nb",
      "diff_hunk": "@@ -0,0 +1,461 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain <ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic Curve Diffie-Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (e.g. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we included an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind-Diffie-Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>) …''\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G, 2·G ..'') that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when compute the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''ALL, SINGLE, NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations only use ''SIGHASH_ALL'' for silent payments<ref name=\"why_sighash_all\">'''Why recommend ''SIGHASH_ALL''?''' Since the output address for the receiver is derived from from the sum of the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not contain a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules.</ref>\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires ''at least'' 117 characters. Additionally, since higher versions may add to the data field, it is recommended implementations use a limit of 1023 characters (see [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#checksum-design BIP173: Checksum design] for more details).\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Sort the outpoints with ''sort<sub>outpoints</sub>(outpoints)''<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment otuput does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>''\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this as described below.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>''? when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+** Optionally, if the sending wallet implements receiving silent payments, it can create change outputs in the following manner:",
      "path": "bip-0352.mediawiki",
      "position": 295,
      "original_position": 286,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "64da95202f79e470f22571953622a7ea90a5fdf8",
      "in_reply_to_id": 1282052593,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Related to the gap limit, there is also the theoretical advantage that you can recover access to your funds from just the UTXO set + tweak data, something you'd be unable to do with BIP32 unless you brute force it with a huge gap limit.\r\n\r\nWallets are free to handle the creation of change outputs in any way they like, but it _is_ important that all wallets always scan for SP style change outputs to ensure no funds are overlooked when importing from a different wallet.",
      "created_at": "2023-08-06T20:59:39Z",
      "updated_at": "2023-08-06T20:59:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1285261787",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285261787"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 295,
      "original_line": 295,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285267239",
      "pull_request_review_id": 1564263806,
      "id": 1285267239,
      "node_id": "PRRC_kwDOAN28mc5Mm58n",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain<ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic-curve Diffie–Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (i.e. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we include an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind Diffie–Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>)'' etc.\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G'', 2·G'' etc.) that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when computing the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''DEFAULT'', ''ALL'', ''SINGLE'', ''NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations use ''SIGHASH_ALL'' (''SIGHASH_DEFAULT'' for taproot inputs) when possible<ref name=\"why_not_sighash_anyonecanpay\">'''Why is it unsafe to use ''SIGHASH_ANYONECANPAY''?''' Since the output address for the receiver is derived from from the sum of the [[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]] public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not spend a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules. Note: this restriction only applies to the inputs of a transaction.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 194,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "478a5c54eae35a8fb54300a564d83c73cacf9ba1",
      "in_reply_to_id": null,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should `e.g. SegWit versions > 1` be `i.e. SegWit versions > 1`? Are there others that matter?",
      "created_at": "2023-08-06T22:02:16Z",
      "updated_at": "2023-08-06T22:20:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1285267239",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285267239"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285267570",
      "pull_request_review_id": 1564263806,
      "id": 1285267570,
      "node_id": "PRRC_kwDOAN28mc5Mm6By",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain<ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic-curve Diffie–Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (i.e. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we include an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind Diffie–Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>)'' etc.\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G'', 2·G'' etc.) that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when computing the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)",
      "path": "bip-0352.mediawiki",
      "position": 182,
      "original_position": 182,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "478a5c54eae35a8fb54300a564d83c73cacf9ba1",
      "in_reply_to_id": null,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should we be explicit about an upper bound here? Otherwise some v0 wallets may not be able to read v1+ if it's longer than they can read. Elsewhere regarding bech32m we say `it is recommended implementations use a limit of 1023 characters`.",
      "created_at": "2023-08-06T22:06:12Z",
      "updated_at": "2023-08-06T22:21:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1285267570",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285267570"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 182,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285268297",
      "pull_request_review_id": 1564263806,
      "id": 1285268297,
      "node_id": "PRRC_kwDOAN28mc5Mm6NJ",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain<ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic-curve Diffie–Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (i.e. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we include an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind Diffie–Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>)'' etc.\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G'', 2·G'' etc.) that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when computing the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''DEFAULT'', ''ALL'', ''SINGLE'', ''NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations use ''SIGHASH_ALL'' (''SIGHASH_DEFAULT'' for taproot inputs) when possible<ref name=\"why_not_sighash_anyonecanpay\">'''Why is it unsafe to use ''SIGHASH_ANYONECANPAY''?''' Since the output address for the receiver is derived from from the sum of the [[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]] public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not spend a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules. Note: this restriction only applies to the inputs of a transaction.</ref>\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires ''at least'' 117 characters<ref name=\"why_117_chars\"> ''' Why do silent payment addresses need at least 117 characters?''' A silent payment address is a bech32m encoding comprised of the following parts:\n+\n+\n+* HRP [2-3 characters]\n+* separator [1 character]\n+* version [1-2 characters]\n+* payload, 66 bytes concatenated pubkeys [ceil(66*8/5) = 106 characters]\n+* checksum [6 characters]\n+\n+\n+For a silent payments v0 address, this results in a 117 character address when using a 3 character HRP. Future versions of silent payment addresses may add to the payload, which is why a 1023 character limit is suggested.</ref>. Additionally, since higher versions may add to the data field, it is recommended implementations use a limit of 1023 characters (see [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#checksum-design BIP173: Checksum design] for more details).\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Sort the outpoints with ''sort<sub>outpoints</sub>(outpoints)''<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment output does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>''\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this by using only the output public key.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>'' when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+** Optionally, if the sending wallet implements receiving silent payments, it can create change outputs in the following manner:\n+*** Let ''A<sub>change</sub> = A<sub>spend</sub> + sha256(ser<sub>256</sub>(a<sub>scan</sub>))·G''\n+*** Let ''change_shared_secret = outpoints_hash·a·A<sub>scan</sub>''\n+*** Let ''n = 0''\n+*** For each change output desired:\n+**** Let ''c<sub>n</sub> = sha256(ser<sub>P</sub>(change_shared_secret) || ser<sub>32</sub>(n))''\n+**** Let ''C<sub>n</sub> = A<sub>change</sub> + c<sub>n</sub>·G''\n+**** Encode ''C<sub>n</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+**** Repeat with ''n++'' for additional change outputs\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+     Scan private key: m / purpose' / coin_type' / account' / 1' / 0\n+    Spend private key: m / purpose' / coin_type' / account' / 0' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''352'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+If each of the checks in ''[[#scanning-transactions|Scanning transactions]]'' passes, the receiving wallet must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Let ''ecdh_shared_secret = outpoints_hash·b<sub>scan</sub>·A''\n+* Check for outputs:\n+** Let ''outputs_to_check'' be the taproot output keys from all unspent taproot outputs in the transaction\n+** Starting with ''n = 0'':\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Compute ''P<sub>n</sub> = B<sub>spend</sub> + t<sub>n</sub>·G''\n+*** For each ''output'' in ''outputs_to_check'':\n+**** If ''P<sub>n</sub>'' equals ''output'':\n+***** Add ''P<sub>n</sub>'' to the wallet\n+***** Remove ''output'' from ''outputs_to_check'' and rescan ''outputs_to_check'' with ''n++''\n+**** Else, if the wallet has precomputed labels (including the change label, if used)<ref name=\"precompute_labels\">''' Why precompute labels?''' Precomputing the labels is not strictly necessary: a wallet could track the max number of labels it has used (call it ''M'') and scan for labels by adding ''m·G'' to ''P<sub>0</sub>'' for each label ''m'' up to ''M'' and comparing to the transaction outputs. This is more performant than precomputing the labels and checking via subtraction in cases where the number of eligible outputs exceeds the number of labels in use. In practice this will mainly apply to users that choose never to use labels, or users that use a single label for generating silent payment change outputs. If using a large number of labels, the wallet would need to add all possible labels to each output. This ends up being ''n·M'' additions, where ''n'' is the number of outputs in the transaction and ''M'' is the number of labels in the wallet. By precomputing the labels, the wallet only needs to compute ''m·G'' once when creating the labeled address and can determine if a label was used via a lookup, rather than adding each label to each output.</ref>:\n+***** Compute ''m·G = output - P<sub>n</sub>''\n+***** Check if ''m·G'' exists in the list of labels used by the wallet\n+***** If a match is found:\n+****** Add the ''P<sub>n</sub> + m·G'' to the wallet\n+****** Remove ''output'' from ''outputs_to_check'' and rescan ''outputs_to_check'' with ''n++''\n+***** If the label is not found, negate ''output'' and check again\n+*** If no matches are found, stop\n+\n+==== Backup and Recovery ====\n+\n+Since each silent payment output address is derived independently, regular backups are recommended. When recovering from a backup, the wallet will need to scan since the last backup to detect new payments.\n+\n+If using a seed/seed phrase only style backup, the user can recover the wallet's unspent outputs from the UTXO set (i.e. only scanning transactions with at least one unspent taproot output) and can recover the full wallet history by scanning the blockchain starting from the wallet birthday. If a wallet uses labels or generates its change addresses using the change label, this information SHOULD be included in the backup. If the user does not know whether labels or the change label were used, it is strongly recommended they always check for the change label when recovering from backup and precompute a large number of labels (e.g. 100k labels) to use when re-scanning. This ensures that the wallet can recover all funds from only a seed/seed phrase backup.",
      "path": "bip-0352.mediawiki",
      "position": 355,
      "original_position": 349,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "478a5c54eae35a8fb54300a564d83c73cacf9ba1",
      "in_reply_to_id": null,
      "user": {
        "login": "RubenSomsen",
        "id": 9066803,
        "node_id": "MDQ6VXNlcjkwNjY4MDM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/9066803?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/RubenSomsen",
        "html_url": "https://github.com/RubenSomsen",
        "followers_url": "https://api.github.com/users/RubenSomsen/followers",
        "following_url": "https://api.github.com/users/RubenSomsen/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/RubenSomsen/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/RubenSomsen/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/RubenSomsen/subscriptions",
        "organizations_url": "https://api.github.com/users/RubenSomsen/orgs",
        "repos_url": "https://api.github.com/users/RubenSomsen/repos",
        "events_url": "https://api.github.com/users/RubenSomsen/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/RubenSomsen/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">If a wallet uses labels or generates its change addresses using the change label, this information SHOULD be included in the backup.\r\n\r\nI think we should just always scan for change. I don't see much of a downside and it simplifies things. What if a user switches from a non-change wallet to a change wallet. Do they now have to redo the backup?\r\n\r\n>and precompute a large number of labels (e.g. 100k labels)\r\n\r\nI'd also argue here for a stronger statement on a default.\r\n\r\n",
      "created_at": "2023-08-06T22:14:38Z",
      "updated_at": "2023-08-06T22:20:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1285268297",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285268297"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 355,
      "original_line": 355,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285271751",
      "pull_request_review_id": 1564316849,
      "id": 1285271751,
      "node_id": "PRRC_kwDOAN28mc5Mm7DH",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain<ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic-curve Diffie–Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (i.e. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we include an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind Diffie–Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>)'' etc.\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G'', 2·G'' etc.) that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when computing the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''DEFAULT'', ''ALL'', ''SINGLE'', ''NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations use ''SIGHASH_ALL'' (''SIGHASH_DEFAULT'' for taproot inputs) when possible<ref name=\"why_not_sighash_anyonecanpay\">'''Why is it unsafe to use ''SIGHASH_ANYONECANPAY''?''' Since the output address for the receiver is derived from from the sum of the [[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]] public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not spend a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules. Note: this restriction only applies to the inputs of a transaction.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 194,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "478a5c54eae35a8fb54300a564d83c73cacf9ba1",
      "in_reply_to_id": 1285267239,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "CTV was originally proposed as a bare script output (`<32 bytes> OP_CTV`). I believe there was some effort to incorporate it into Tapscript, but the current version of the BIP seems to imply that CTV can be used anywhere, including bare scripts.\r\n\r\n",
      "created_at": "2023-08-06T22:49:32Z",
      "updated_at": "2023-08-06T22:49:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1285271751",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285271751"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285273043",
      "pull_request_review_id": 1564331114,
      "id": 1285273043,
      "node_id": "PRRC_kwDOAN28mc5Mm7XT",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain<ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic-curve Diffie–Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (i.e. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we include an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind Diffie–Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>)'' etc.\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G'', 2·G'' etc.) that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when computing the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''DEFAULT'', ''ALL'', ''SINGLE'', ''NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations use ''SIGHASH_ALL'' (''SIGHASH_DEFAULT'' for taproot inputs) when possible<ref name=\"why_not_sighash_anyonecanpay\">'''Why is it unsafe to use ''SIGHASH_ANYONECANPAY''?''' Since the output address for the receiver is derived from from the sum of the [[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]] public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not spend a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules. Note: this restriction only applies to the inputs of a transaction.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 194,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "478a5c54eae35a8fb54300a564d83c73cacf9ba1",
      "in_reply_to_id": 1285267239,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "More importantly, we never specify what the \"defined output types\" are. I automatically read this as all policy-standard output types, but standardness rules can change. What about larger than x-of-3 bare multisig that are non-standard but consensus-valid? How about bare `OP_1` ([emphemeral anchor](https://bitcoinops.org/en/topics/ephemeral-anchors/))? This shouldn't be left as an exercise for the reader.",
      "created_at": "2023-08-06T23:02:11Z",
      "updated_at": "2023-08-06T23:02:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1285273043",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1285273043"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1286425723",
      "pull_request_review_id": 1566215297,
      "id": 1286425723,
      "node_id": "PRRC_kwDOAN28mc5MrUx7",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain<ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic-curve Diffie–Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (i.e. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we include an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind Diffie–Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>)'' etc.\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G'', 2·G'' etc.) that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when computing the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''DEFAULT'', ''ALL'', ''SINGLE'', ''NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations use ''SIGHASH_ALL'' (''SIGHASH_DEFAULT'' for taproot inputs) when possible<ref name=\"why_not_sighash_anyonecanpay\">'''Why is it unsafe to use ''SIGHASH_ANYONECANPAY''?''' Since the output address for the receiver is derived from from the sum of the [[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]] public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not spend a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules. Note: this restriction only applies to the inputs of a transaction.</ref>\n+\n+Otherwise, skip the transaction. This is to ensure forward compatibility with future versions of silent payments without requiring future versions to scan a transaction multiple times with different rule sets.\n+\n+=== Address encoding ===\n+\n+A silent payment address is constructed in the following manner:\n+\n+* Let ''B<sub>scan</sub>, b<sub>scan</sub> = Receiver's scan public key and corresponding private key''\n+* Let ''B<sub>spend</sub>, b<sub>spend</sub> = Receiver's spend public key and corresponding private key''\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G'', where ''m'' an optional integer tweak for labeling\n+** In the case of ''m'' = 0, no label is applied and ''B<sub>m</sub> = B<sub>spend</sub>''\n+* The final address is a [https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki Bech32m] encoding of:\n+** The human-readable part \"sp\" for mainnet, \"tsp\" for testnets (e.g.  signet, testnet)\n+** The data-part values:\n+*** The character \"q\", to represent a silent payment address of version 0\n+*** The 66 byte concatenation of the receiver's public keys, ''ser<sub>P</sub>(B<sub>scan</sub>) || ser<sub>P</sub>(B<sub>m</sub>)''\n+\n+Note: [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki BIP173] imposes a 90 character limit for Bech32 strings, whereas a silent payment address requires ''at least'' 117 characters<ref name=\"why_117_chars\"> ''' Why do silent payment addresses need at least 117 characters?''' A silent payment address is a bech32m encoding comprised of the following parts:\n+\n+\n+* HRP [2-3 characters]\n+* separator [1 character]\n+* version [1-2 characters]\n+* payload, 66 bytes concatenated pubkeys [ceil(66*8/5) = 106 characters]\n+* checksum [6 characters]\n+\n+\n+For a silent payments v0 address, this results in a 117 character address when using a 3 character HRP. Future versions of silent payment addresses may add to the payload, which is why a 1023 character limit is suggested.</ref>. Additionally, since higher versions may add to the data field, it is recommended implementations use a limit of 1023 characters (see [https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#checksum-design BIP173: Checksum design] for more details).\n+\n+=== Outpoints hash ===\n+\n+The sender and receiver MUST calculate an outpoints hash for the transaction in the following manner:\n+\n+* Collect each ''outpoint'' used as an input to the transaction\n+* Sort the outpoints with ''sort<sub>outpoints</sub>(outpoints)''<ref name=\"why_sort_outpoints\">'''Why are outpoints sorted before hashing?''' This way the silent payment output does not need to be recalculated if the wallet changes the order of inputs, e.g. at signing time or during an RBF bump.</ref>\n+* Let ''outpoints = outpoint<sub>0</sub> || … || outpoint<sub>n</sub>''\n+* Let ''outpoints_hash = sha256(outpoints)''\n+\n+=== Inputs For Shared Secret Derivation ===\n+\n+While any UTXO with known output scripts can be used to fund the transaction, the sender and receiver MUST use inputs from the following list when deriving the shared secret:\n+\n+* ''P2TR''\n+* ''P2WPKH''\n+* ''P2SH-P2WPKH''\n+* ''P2PKH''\n+\n+Inputs with conditional branches or multiple public keys (e.g. ''CHECKMULTISIG'') are not included as this introduces malleability and would allow a sender to re-sign with a different set of public keys after the silent payment output has been derived. This is not a concern when the sender controls all of the inputs, but is an issue for CoinJoins and other collaborative protocols, where a malicious participant can participate in deriving the silent payment address with one set of keys and then re-broadcast the transaction with signatures for a different set of public keys. P2TR can have hidden conditional branches (script path), but we work around this by using only the output public key.\n+\n+''' P2TR '''\n+\n+The sender MUST use the private key corresponding to the taproot output key (i.e. the tweaked private key for a key path spend). This can be a single private key or an aggregate key (e.g. taproot outputs using MuSig2 or FROST)<ref name=\"musig_frost_support\">'''Are key aggregation techniques like FROST and MuSig2 supported?''' Any taproot output able to do a key path spend is supported. While a full specification of how to do this securely is outside the scope of this BIP, in theory any offline key aggregation technique can be used, such as FROST or MuSig2. This would require participants to perform the ECDH step collaboratively e.g. ''ECDH = a<sub>0</sub>·B<sub>scan</sub> + a<sub>1</sub>·B<sub>scan</sub> + ... + a<sub>t</sub>·B<sub>scan</sub>'' and ''P = B<sub>spend</sub> + hash(outpoints_hash·ECDH || 0)·G''. Additionally, it may be necessary for the participants to provide a DLEQ proof to ensure they are not acting maliciously.</ref>. If this key is not available, the output cannot be included as an input to the transaction. The receiver always uses the taproot output key when scanning, regardless of whether the taproot output is using a key path spend or a script path spend<ref name=\"why_always_output_pubkey\">''' Why not skip all taproot script path spends? ''' This causes malleability issues for CoinJoins. If the silent payments protocol skipped taproot script path spends, this would allow an attacker to join a CoinJoin round, participate in deriving the silent payment address using the tweaked private key for a key path spend, and then broadcast their own version of the transaction using the script path spend. If the receiver were to only consider key path spends, they would skip the attacker's script path spend input when deriving the shared secret and not be able to find the funds. Additionally, there may be scenarios where a sender has access to the key path private key but spends the output using the script path.</ref>.\n+\n+The one exception is script path spends that use NUMS point ''H'' as their internal key (where ''H = lift_x(0x50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)'' which is constructed by taking the hash of the standard uncompressed encoding of the secp256k1 base point ''G'' as X coordinate, see [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP341: Constructing and spending Taproot outputs] for more details), in which case the output will be skipped for the purposes of shared secret derivation<ref name=\"why_ignore_h\">'''Why skip outputs with H as the internal taproot key?''' If use cases get popularized where the taproot key path cannot be used, these outputs can still be included without getting in the way of making a silent payment, provided they specifically use H as their internal taproot key.</ref>.\n+\n+''' P2WPKH '''\n+\n+The sender performs the tweak using the private key for the output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2SH-P2WPKH '''\n+\n+The sender performs the tweak using the private key for the nested ''P2WPKH'' output and the receiver obtains the public key from the ''witness''.\n+\n+''' P2PKH '''\n+\n+The sender performs the tweak using the private key for the output and SHOULD sign using the standard script template:\n+\n+\n+    scriptSig: <Signature> <Public Key>\n+\n+\n+The receiver obtains the public key from the ''scriptSig''. The receiver MUST parse the ''scriptSig'' for the public key, even if the ''scriptSig'' is non-standard (e.g. <code><dummy> OP_DROP <Signature> <Public Key></code>). This is to address the [https://en.bitcoin.it/wiki/Transaction_malleability third-party malleability of ''P2PKH'' ''scriptSigs''].\n+\n+=== Sender ===\n+\n+==== Selecting inputs ====\n+\n+The sending wallet performs coin selection as usual with the following restrictions:\n+\n+* At least one input MUST be from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Exclude inputs with witness version > 1 (see ''[[#scanning-transactions|Scanning transactions]]'')\n+* For each taproot output spent the sending wallet MUST have access to the private key corresponding to the taproot output key, unless ''H'' is used as the internal public key\n+\n+==== Creating outputs ====\n+\n+After the inputs have been selected, the sender can create one or more outputs for one or more silent payment addresses in the following manner:\n+\n+* Collect the private keys for each input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* For each private key ''a<sub>i</sub>'' corresponding to a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output, check that the private key produces a point with an even y-value and negate the private key if not<ref name=\"why_negate_taproot_private_keys\">'''Why do taproot private keys need to be checked?''' Recall from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki BIP340] that each x-only public key has two corresponding private keys, ''d'' and ''n - d''. To maintain parity between sender and receiver, it is necessary to use the private key corresponding to the even y-value when performing the ECDH step since the receiver will assume the even y-value when summing the taproot x-only public keys.</ref>\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> + … a<sub>n</sub>'', where each ''a<sub>i</sub>'' has been negated if necessary\n+* Generate the ''outpoints_hash'', using the method described above\n+* Group receiver silent payment addresses by ''B<sub>scan</sub>'' (e.g. each group consists of one ''B<sub>scan</sub>'' and one or more ''B<sub>m</sub>'')\n+* For each group:\n+** Let ''ecdh_shared_secret = outpoints_hash·a·B<sub>scan</sub>''\n+** Let ''n = 0''\n+** For each ''B<sub>m</sub>'' in the group:\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Let ''P<sub>mn</sub> = B<sub>m</sub> + t<sub>n</sub>·G''\n+*** Encode ''P<sub>mn</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+*** Optionally, repeat with n++ to create additional outputs for the current ''B<sub>m</sub>''\n+*** If no additional outputs are required, continue to the next ''B<sub>m</sub>'' with ''n++''<ref name=\"why_not_the_same_tn\">''' Why not re-use ''t<sub>n</sub>'' when paying different labels to the same receiver?''' If paying the same entity but to two separate labeled addresses in the same transaction without incrementing ''n'', the two outputs would be ''B<sub>spend</sub> + t<sub>n</sub>·G + i·G'' and ''B<sub>spend</sub> + t<sub>n</sub>·G + j·G''. The attacker could subtract the two values and observe that the distance between i and j is small. This would allow them to deduce that this transaction is a silent payment transaction and that a single entity received two outputs, but won't tell them who the entity is.</ref>\n+** Optionally, if the sending wallet implements receiving silent payments, it can create change outputs in the following manner:\n+*** Let ''A<sub>change</sub> = A<sub>spend</sub> + sha256(ser<sub>256</sub>(a<sub>scan</sub>))·G''\n+*** Let ''change_shared_secret = outpoints_hash·a·A<sub>scan</sub>''\n+*** Let ''n = 0''\n+*** For each change output desired:\n+**** Let ''c<sub>n</sub> = sha256(ser<sub>P</sub>(change_shared_secret) || ser<sub>32</sub>(n))''\n+**** Let ''C<sub>n</sub> = A<sub>change</sub> + c<sub>n</sub>·G''\n+**** Encode ''C<sub>n</sub>'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+**** Repeat with ''n++'' for additional change outputs\n+\n+=== Receiver ===\n+\n+==== Key Derivation ====\n+\n+Two keys are needed to create a silent payments address: the spend key and the scan key. While these keys can be generated independently, wallet software SHOULD use BIP32 derivation<ref name=\"bip32_derivation\">'''Why use BIP32 hardened derivation?''' Using BIP32 derivation allows users to add silent payments to an existing master seed. It also ensures that a user's silent payment funds are recoverable in any wallet which supports BIP32 derivation. Using hardened derivation ensures that it is safe to export the scan private key without exposing the master key or spend private key.</ref> to ensure compatibility across wallets.\n+\n+A scan and spend key pair using BIP32 derivation are defined (taking inspiration from [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44]) in the following manner:\n+\n+\n+     Scan private key: m / purpose' / coin_type' / account' / 1' / 0\n+    Spend private key: m / purpose' / coin_type' / account' / 0' / 0\n+\n+Wallet software MUST use hardened derivation to ensure the master key is not exposed in the event the scan private key is compromised. Purpose is a constant set to ''352'' following the BIP43 recommendation. Refer to [https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki BIP43] and [https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki BIP44] for more details.\n+\n+==== Scanning ====\n+\n+If each of the checks in ''[[#scanning-transactions|Scanning transactions]]'' passes, the receiving wallet must:\n+\n+* Generate the ''outpoints_hash'', using the method described above\n+* Let ''A = A<sub>0</sub> + A<sub>1</sub> + … A<sub>n</sub>'', where each ''A<sub>i</sub>'' is the public key of an input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* Let ''ecdh_shared_secret = outpoints_hash·b<sub>scan</sub>·A''\n+* Check for outputs:\n+** Let ''outputs_to_check'' be the taproot output keys from all unspent taproot outputs in the transaction\n+** Starting with ''n = 0'':\n+*** Let ''t<sub>n</sub> = sha256(ser<sub>P</sub>(ecdh_shared_secret) || ser<sub>32</sub>(n))''\n+*** Compute ''P<sub>n</sub> = B<sub>spend</sub> + t<sub>n</sub>·G''\n+*** For each ''output'' in ''outputs_to_check'':\n+**** If ''P<sub>n</sub>'' equals ''output'':\n+***** Add ''P<sub>n</sub>'' to the wallet\n+***** Remove ''output'' from ''outputs_to_check'' and rescan ''outputs_to_check'' with ''n++''\n+**** Else, if the wallet has precomputed labels (including the change label, if used)<ref name=\"precompute_labels\">''' Why precompute labels?''' Precomputing the labels is not strictly necessary: a wallet could track the max number of labels it has used (call it ''M'') and scan for labels by adding ''m·G'' to ''P<sub>0</sub>'' for each label ''m'' up to ''M'' and comparing to the transaction outputs. This is more performant than precomputing the labels and checking via subtraction in cases where the number of eligible outputs exceeds the number of labels in use. In practice this will mainly apply to users that choose never to use labels, or users that use a single label for generating silent payment change outputs. If using a large number of labels, the wallet would need to add all possible labels to each output. This ends up being ''n·M'' additions, where ''n'' is the number of outputs in the transaction and ''M'' is the number of labels in the wallet. By precomputing the labels, the wallet only needs to compute ''m·G'' once when creating the labeled address and can determine if a label was used via a lookup, rather than adding each label to each output.</ref>:\n+***** Compute ''m·G = output - P<sub>n</sub>''\n+***** Check if ''m·G'' exists in the list of labels used by the wallet\n+***** If a match is found:\n+****** Add the ''P<sub>n</sub> + m·G'' to the wallet\n+****** Remove ''output'' from ''outputs_to_check'' and rescan ''outputs_to_check'' with ''n++''\n+***** If the label is not found, negate ''output'' and check again\n+*** If no matches are found, stop\n+\n+==== Backup and Recovery ====\n+\n+Since each silent payment output address is derived independently, regular backups are recommended. When recovering from a backup, the wallet will need to scan since the last backup to detect new payments.\n+\n+If using a seed/seed phrase only style backup, the user can recover the wallet's unspent outputs from the UTXO set (i.e. only scanning transactions with at least one unspent taproot output) and can recover the full wallet history by scanning the blockchain starting from the wallet birthday. If a wallet uses labels or generates its change addresses using the change label, this information SHOULD be included in the backup. If the user does not know whether labels or the change label were used, it is strongly recommended they always check for the change label when recovering from backup and precompute a large number of labels (e.g. 100k labels) to use when re-scanning. This ensures that the wallet can recover all funds from only a seed/seed phrase backup.\n+\n+== Backward Compatibility ==\n+\n+Silent payments introduces a new address format and protocol for sending and as such is not compatible with older wallet software or wallets which have not implemented the silent payments protocol.\n+\n+== Test Vectors ==\n+\n+A [[bip-0352/send_and_receive_test_vectors.json|collection of test vectors in JSON format]] are provided, along with a [[bip-0352/reference.py|python reference implementation]]. Each test vector consists of a sending test case and corresponding receiving test case. This is to allow sending and receiving to be implemented separately. To ensure determinism while testing, sort the array of ''B<sub>m</sub>'' by amount (see the [[bip-0352/reference.py|reference implementation]]). Test cases use the following schema:\n+\n+''' test_case '''\n+\n+    {\n+        \"comment\": \"Comment describing the behavior being tested\",\n+        \"sending\": [<array of sender test objects>],\n+        \"receiving\": [<array of recipient test objects>],\n+    }\n+\n+''' sender '''\n+\n+    {\n+        \"given\": {\n+            \"outpoints\": [<array of tuples, where each tuple represents an outpoint: (txid, vout)>],\n+            \"input_priv_keys\": [<array of tuples, where each tuple is a hex encoded private key and boolean for taproot: (priv_key, is_taproot)>],\n+            \"recipients\": [<array of tuples, where each tuple is a bech32m string representing a silent payment address and an float amount: (silent_payment_address, amount)>]\n+        },\n+        \"expected\": {\n+            \"outputs\": [<array of key, value objects, where the key is the hex encoding of 32-byte x-only public key and the value an integer amount: {taproot_x_only_key: amount}]",
      "path": "bip-0352.mediawiki",
      "position": 382,
      "original_position": 376,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "478a5c54eae35a8fb54300a564d83c73cacf9ba1",
      "in_reply_to_id": null,
      "user": {
        "login": "cygnet3",
        "id": 131168104,
        "node_id": "U_kgDOB9F3aA",
        "avatar_url": "https://avatars.githubusercontent.com/u/131168104?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/cygnet3",
        "html_url": "https://github.com/cygnet3",
        "followers_url": "https://api.github.com/users/cygnet3/followers",
        "following_url": "https://api.github.com/users/cygnet3/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/cygnet3/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/cygnet3/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/cygnet3/subscriptions",
        "organizations_url": "https://api.github.com/users/cygnet3/orgs",
        "repos_url": "https://api.github.com/users/cygnet3/repos",
        "events_url": "https://api.github.com/users/cygnet3/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/cygnet3/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Test vector format has since updated:\r\n\r\n```suggestion\r\n            \"outputs\": [<array of tuples, where each tuple is the hex encoding of 32-byte x-only public key and an integer amount: (taproot_x_only_key, amount)]\r\n```",
      "created_at": "2023-08-07T22:16:58Z",
      "updated_at": "2023-08-07T22:16:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1286425723",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1286425723"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 382,
      "original_line": 382,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1288186883",
      "pull_request_review_id": 1569100058,
      "id": 1288186883,
      "node_id": "PRRC_kwDOAN28mc5MyCwD",
      "diff_hunk": "@@ -0,0 +1,471 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain<ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic-curve Diffie–Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (i.e. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we include an integer in the following manner:\n+\n+* Let ''n = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''n'' by one (''n++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.\n+\n+''' Using all inputs '''\n+\n+In our simplified example we have been referring to Alice's transactions as having only one input ''A'', but in reality a Bitcoin transaction can have many inputs. Instead of requiring Alice to pick a particular input and requiring Bob to check each input separately, we can instead require Alice to perform the tweak with the sum of the input public keys<ref name=\"other_inputs\">'''What about inputs without public keys?''' Inputs without public keys can still be spent in the transaction but are simply ignored in the ''Silent Payments'' protocol.</ref>. This significantly reduces Bob's scanning requirement, makes light client support more feasible<ref name=\"using_all_inputs\">'''How does using all inputs help light clients?''' If Alice uses a random input for the tweak, Bob necessarily has to have access to and check all transaction inputs, which requires performing an ECC multiplication per input. If instead Alice performs the tweak with the sum of the input public keys, Bob only needs the summed 33 byte public key per transaction and only does one ECC multiplication per transaction. Bob can then use BIP158 block filters to determine if any of the outputs exist in a block and thus avoids downloading transactions which don't belong to him. It is still an open question as to how Bob can source the 32 bytes per transaction in a trustless manner, see [[#appendix-a-light-client-support|Appendix A: Light Client Support]] for more details.</ref>, and protects Alice's privacy in collaborative transaction protocols such as CoinJoin<ref name=\"\"all_inputs_and_coinjoin\">'''Why does using all inputs matter for CoinJoin?''' If Alice uses a random input to create the output for Bob, this necessarily reveals to Bob which input Alice has control of. If Alice is paying Bob as part of a CoinJoin, this would reveal which input belongs to her, degrading the anonymity set of the CoinJoin and giving Bob more information about Alice. If instead all inputs are used, Bob has no way of knowing which input(s) belong to Alice. This comes at the cost of increased complexity as the CoinJoin participants now need to coordinate to create the silent payment output and would need to use [https://gist.github.com/RubenSomsen/be7a4760dd4596d06963d67baf140406 Blind Diffie–Hellman] to prevent the other participants from learning who Alice is paying.</ref>.\n+\n+Alice performs the tweak with the sum of her input private keys in the following manner:\n+\n+* Let ''outpoints_hash = hash(txid<sub>0</sub> || vout<sub>0</sub> || … txid<sub>n</sub> || vout<sub>n</sub>)''\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>''\n+* Let ''P<sub>0</sub> = B + hash(outpoints_hash·a·B || 0)·G''\n+\n+''' Spend and Scan Key '''\n+\n+Since Bob needs his private key ''b'' to check for incoming payments, this requires ''b'' to be exposed to an online device. To minimize the risks involved, Bob can instead publish an address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)''. This allows Bob to keep ''b<sub>spend</sub>'' in offline cold storage and perform the scanning with the public key ''B<sub>spend</sub>'' and private key ''b<sub>scan</sub>''. Alice performs the tweak using both of Bob's public keys in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+Bob detects this payment by calculating ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)·G'' with his online device and can spend from his cold storage signing device using ''(b<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A)) mod p'' as the private key.\n+\n+''' Labels '''\n+\n+For a single silent payment address of the form ''(B<sub>scan</sub>, B<sub>spend</sub>)'', Bob may wish to differentiate incoming payments. Naively, Bob could publish multiple silent payment addresses, but this would require him to scan for each one, which becomes prohibitively expensive. Instead, Bob can label his spend public key ''B<sub>spend</sub>'' with an integer ''m'' in the following way:\n+\n+* Let ''B<sub>m</sub> = B<sub>spend</sub> + m·G''\n+* Publish ''(B<sub>scan</sub>, B<sub>0</sub>)'', ''(B<sub>scan</sub>, B<sub>1</sub>)'' etc.\n+\n+Alice performs the tweak as before using one of the published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pairs. Bob detects the labeled payment in the following manner:\n+\n+* Let ''P<sub>0</sub> = B<sub>spend</sub> + hash(outpoints_hash·b<sub>scan</sub>·A || 0)·G''\n+* Subtract ''P<sub>0</sub>'' from each of the transaction outputs and check if the remainder matches any of the labels (''1·G'', 2·G'' etc.) that the wallet has previously used\n+\n+It is important to note that an outside observer can easily deduce that each published ''(B<sub>scan</sub>, B<sub>m</sub>)'' pair is owned by the same entity as each published address will have ''B<sub>scan</sub>'' in common. As such, labels are not meant as a way for Bob to manage separate identities, but rather a way for Bob to determine the source of an incoming payment.\n+\n+''' Labels for change '''\n+\n+Bob can also use labels for managing his own change outputs. To do so, he can reserve a secret change label in the following manner:\n+\n+* Let ''B<sub>change</sub> = B<sub>spend</sub> + hash(b<sub>scan</sub>)·G''\n+\n+Now, whenever Bob is spending (to a silent payment address or otherwise), he can create a change output for himself using the silent payments protocol and his change label in the following manner:\n+\n+* Let ''a = a<sub>0</sub> + a<sub>1</sub> … + a<sub>n</sub>'' represent the private keys of the inputs Bob is using to fund the transaction\n+* Let ''P<sub>change</sub> = B<sub>change</sub> + hash(outpoints_hash·a·B<sub>scan</sub> || 0)·G''\n+\n+This gives Bob an alternative to using BIP32 for managing change, while still allowing him to know which of his unspent outputs were change when recovering his wallet from the master key. The change label needs to remain a secret in order to ensure nobody else can label payments as change.\n+\n+== Specification ==\n+\n+We use the following functions and conventions:\n+\n+* ''outpoint'' (36 bytes): the <code>COutPoint</code> of an input (32-byte txid, least significant byte first || 4-byte vout, least significant byte first)<ref name=\"why_little_endian\">'''Why are outpoints little-endian?''' Despite using big endian throughout the rest of the BIP, outpoints are sorted and hashed matching their transaction serialization, which is little-endian. This allows a wallet to parse a serialized transaction for use in silent payments without needing to re-order the bytes when computing the outpoint hash. Note: despite outpoints being stored and serialized as little-endian, the transaction hash (txid) is always displayed as big-endian.</ref>\n+* sort<sub>outpoints</sub>(v): sorts a vector ''v'' of ''outpoints'' in ascending order by doing a byte by byte comparison lexicographically.\n+* ser<sub>32</sub>(i): serializes a 32-bit unsigned integer ''i'' as a 4-byte sequence, most significant byte first.\n+* ser<sub>256</sub>(p): serializes the integer p as a 32-byte sequence, most significant byte first.\n+* ser<sub>P</sub>(P): serializes the coordinate pair P = (x,y) as a byte sequence using SEC1's compressed form: (0x02 or 0x03) || ser<sub>256</sub>(x), where the header byte depends on the parity of the omitted y coordinate.\n+\n+For everything not defined above, we use the notation from [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#specification BIP340].\n+\n+=== Versions ===\n+\n+This document defines ''Silent Payments v0''. Version is communicated through the address in the same way as Segwit addresses. Future upgrades to silent payments will require a new version. As much as possible, future upgrades should support receiving from older wallets (e.g. a silent payments v0 wallet can send to both v0 and v1 addresses). Any changes that break compatibility with older silent payment versions should be a new BIP.\n+\n+Future Silent Payments versions will use the following versioning scheme:\n+\n+{| class=\"wikitable\"\n+|-\n+!\n+!0\n+!1\n+!2\n+!3\n+!4\n+!5\n+!6\n+!7\n+!Compatibility\n+|-\n+!+0\n+|q||p||z||r||y||9||x||8||rowspan=\"4\" | backwards compatible\n+|-\n+!+8\n+|g||f||2||t||v||d||w||0\n+|-\n+!+16\n+|s||3||j||n||5||4||k||h\n+|-\n+!+24\n+|c||e||6||m||u||a||7|| -\n+|}\n+\n+''v31'' (l) is reserved for a backwards incompatible change, if needed. For ''Silent Payments v0'':\n+\n+* If the receiver's silent payment address version is:\n+** ''v0'': check that the data part is exactly 66-bytes. Otherwise, fail\n+** ''v1'' through ''v30'': read the first 66-bytes of the data part and discard the remaining bytes (if any)\n+** ''v31'': fail\n+* Receiver addresses are always [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot outputs<ref name=\"why_taproot\">'''Why only taproot outputs?''' Providing too much optionality for the protocol makes it difficult to implement and can be at odds with the goal of providing the best privacy. Limiting to taproot outputs helps simplify the implementation significantly while also putting users in the best eventual anonymity set.</ref>\n+* The sender should sign with one of the sighash flags ''DEFAULT'', ''ALL'', ''SINGLE'', ''NONE'' (''ANYONECANPAY'' is unsafe). It is strongly recommended implementations use ''SIGHASH_ALL'' (''SIGHASH_DEFAULT'' for taproot inputs) when possible<ref name=\"why_not_sighash_anyonecanpay\">'''Why is it unsafe to use ''SIGHASH_ANYONECANPAY''?''' Since the output address for the receiver is derived from from the sum of the [[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]] public keys, the inputs must not change once the sender has signed the transaction. If the inputs are allowed to change after the fact, the receiver will not be able to calculate the shared secret needed to find and spend the output. It is currently an open question on how a future version of silent payments could be made to work with new sighash flags such as ''SIGHASH_GROUP'' and ''SIGHASH_ANYPREVOUT''.</ref>\n+* Inputs used to derive the shared secret are from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+\n+=== Scanning transactions ===\n+\n+A transaction is a ''Silent Payments v0'' transaction and MUST be scanned if and only if all of the following are true:\n+\n+* The transaction contains at least one BIP341 taproot output\n+* The transaction has at least one input from the ''[[#inputs-for-shared-secret-derivation|Inputs For Shared Secret Derivation]]'' list\n+* The transaction does not spend a new, undefined output type (e.g. SegWit versions > 1)<ref name=\"skip_txs_with_unknown_prevouts\">'''Why skip transactions that spend unknown output scripts?''' Skipping transactions that spend unknown output scripts allows us to have a clean upgrade path for Silent Payments by avoiding the need to scan the same transaction multiple times with different rule sets. If a fancy new output type is added in the future and Silent Payments v1 is released with support, we would want to avoid having to first scan the transaction with the silent payment v0 rules and then again with the silent payment v1 rules. Note: this restriction only applies to the inputs of a transaction.</ref>",
      "path": "bip-0352.mediawiki",
      "position": null,
      "original_position": 194,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "478a5c54eae35a8fb54300a564d83c73cacf9ba1",
      "in_reply_to_id": 1285267239,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Great point, I think what we need here is a \"Forward compatibility\" section. As of today, we have the \"Inputs for shared secret derivation\" and then anything else can be spent in the transaction, except for Segwit version > 1. We skip these because they might eventually be added to the \"Inputs for shared secret derivation\" list for a future silent payments version. For everything else, it's fine to spend it in a transaction.\r\n\r\nBecause of this, we need to specify that if a future soft fork uses an OP_NOP (bare script) for a soft fork, this new output type cannot be added to a future version's \"Inputs for shared secret derivation\" list, unless using the v31 non-backward compatible upgrade. Additionally, future versions can only add to the \"Inputs for shared secret derivation\" list unless using the v31 non-backward compatible upgrade.",
      "created_at": "2023-08-09T09:09:13Z",
      "updated_at": "2023-08-09T09:09:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1288186883",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1288186883"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 194,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1313884815",
      "pull_request_review_id": 1608335822,
      "id": 1313884815,
      "node_id": "PRRC_kwDOAN28mc5OUEqP",
      "diff_hunk": "@@ -0,0 +1,477 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain<ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic-curve Diffie–Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (i.e. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we include an integer in the following manner:\n+\n+* Let ''k = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''k'' by one (''k++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''",
      "path": "bip-0352.mediawiki",
      "position": 70,
      "original_position": 70,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "in_reply_to_id": null,
      "user": {
        "login": "stevenroose",
        "id": 853468,
        "node_id": "MDQ6VXNlcjg1MzQ2OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/853468?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stevenroose",
        "html_url": "https://github.com/stevenroose",
        "followers_url": "https://api.github.com/users/stevenroose/followers",
        "following_url": "https://api.github.com/users/stevenroose/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stevenroose/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stevenroose/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stevenroose/subscriptions",
        "organizations_url": "https://api.github.com/users/stevenroose/orgs",
        "repos_url": "https://api.github.com/users/stevenroose/repos",
        "events_url": "https://api.github.com/users/stevenroose/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stevenroose/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You seem to be mixing k and n here? ",
      "created_at": "2023-09-02T16:03:42Z",
      "updated_at": "2023-09-07T18:44:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1313884815",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1313884815"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 70,
      "original_line": 70,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1313885038",
      "pull_request_review_id": 1608335822,
      "id": 1313885038,
      "node_id": "PRRC_kwDOAN28mc5OUEtu",
      "diff_hunk": "@@ -0,0 +1,477 @@\n+<pre>\n+  BIP: 352\n+  Layer: Applications\n+  Title: Silent Payments\n+  Author: josibake <josibake@protonmail.com>\n+          Ruben Somsen <rsomsen@gmail.com>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0352\n+  Status: Draft\n+  Type: Informational\n+  Created: 2023-03-09\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Introduction ==\n+\n+=== Abstract ===\n+\n+This document specifies a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications.\n+\n+=== Copyright ===\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+=== Motivation ===\n+\n+Using a new address for each Bitcoin transaction is a crucial aspect of maintaining privacy. This often requires a secure interaction between sender and receiver so that the receiver can hand out a fresh address, a batch of fresh addresses, or a method for the sender to generate addresses on-demand, such as an xpub.\n+\n+However, interaction is often infeasible and in many cases undesirable. To solve for this, various protocols have been proposed which use a static payment address and notifications sent via the blockchain<ref name=\"out_of_band_notifications\">'''Why not use out-of-band notifications''' Out of band notifications (e.g. using something other than the Bitcoin blockchain) have been proposed as a way of addressing the privacy and cost concerns of using the Bitcoin blockchain as a messaging layer. This, however, simply moves the privacy and cost concerns somewhere else and increases the risk of losing money due to a notification not being reliably delivered, or even censored, and makes this notification data critical for backup to recover funds.</ref>. These protocols eliminate the need for interaction, but at the expense of increased costs for one-time payments and a noticeable footprint in the blockchain, potentially revealing metadata about the sender and receiver. Notification schemes also allow the receiver to link all payments from the same sender, compromising sender privacy.\n+\n+This proposal aims to address the limitations of these current approaches by presenting a solution that eliminates the need for interaction, eliminates the need for notifications, and protects both sender and receiver privacy. These benefits come at the cost of requiring wallets to scan the blockchain in order to detect payments. This added requirement is generally feasible for full nodes but poses a challenge for light clients. While it is possible today to implement a privacy-preserving light client at the cost of increased bandwidth, light client support is considered an area of open research (see [[#appendix-a-light-client-support|Appendix A: Light Client Support]]).\n+\n+== Goals ==\n+\n+We aim to present a protocol which satisifies the following properties:\n+\n+* No increase in the size or cost of transactions\n+* Resulting transactions blend in with other bitcoin transactions and can't be distinguished\n+* Transactions can't be linked to a silent payment address by an outside observer\n+* No sender-receiver interaction required\n+* No linking of multiple payments to the same sender\n+* Each silent payment goes to a unique address, avoiding accidental address reuse\n+* Supports payment labeling\n+* Uses existing seed phrase or descriptor methods for backup and recovery\n+* Separates scanning and spending responsibilities\n+* Compatible with other spending protocols, such as CoinJoin\n+* Light client/SPV wallet support\n+* Protocol is upgradeable\n+\n+== Overview ==\n+\n+We first present an informal overview of the protocol. In what follows, uppercase letters represent public keys, lowercase letters represent private keys, ''||'' refers to byte concatenation, and ''G'' represents the generator point for ''secp256k1''. Each section of the overview is incomplete on its own and is meant to build on the previous section in order to introduce and briefly explain each aspect of the protocol. For the full protocol specification, see [[#specification|Specification]].\n+\n+''' Simple case '''\n+\n+Bob publishes a public key ''B'' as a silent payment address. Alice discovers Bob's silent payment address, selects a UTXO with private key ''a'', public key ''A'' and creates a destination output ''P'' for Bob in the following manner:\n+\n+* Let ''P = B + hash(a·B)·G''\n+* Encode ''P'' as a [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki BIP341] taproot output\n+\n+Since ''a·B == b·A'' ([https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman Elliptic-curve Diffie–Hellman]), Bob scans with his private key ''b'' by collecting the input public keys for each transaction with at least one unspent taproot output and performing the ECDH calculation until ''P'' is found (i.e. calculating ''P = B + hash(b·A)·G'' and seeing that ''P'' is present in the transaction outputs).\n+\n+''' Creating more than one output '''\n+\n+In order to allow Alice to create more than one output for Bob<ref name=\"why_more_than_one_output\">'''Why allow for more than one output?''' Allowing Alice to break her payment to Bob into multiple amounts opens up a number of privacy improving techniques for Alice, making the transaction look like a CoinJoin or better hiding the change amount by splitting both the payment and change outputs into multiple amounts. It also allows for Alice and Carol to both have their own unique output paying Bob in the event they are in a collaborative transaction and both paying Bob's silent payment address.</ref>, we include an integer in the following manner:\n+\n+* Let ''k = 0''\n+* Let ''P<sub>0</sub> = B + hash(a·B || n)·G''\n+* For additional outputs:\n+** Increment ''k'' by one (''k++'')\n+** Let ''P<sub>i</sub> = B + hash(a·B || n)·G''\n+\n+Bob detects this output the same as before by searching for ''P<sub>0</sub> = B + hash(b·A || 0)·G''. Once he detects the first output, he must:\n+\n+* Check for ''P<sub>1</sub> = B + hash(b·A || 1)·G''\n+* If ''P<sub>1</sub>'' is not found, stop\n+* If ''P<sub>1</sub>'' is found, continue to check for ''P<sub>2</sub>'' and so on until an additional output is not found\n+\n+Since Bob will only perform these subsequent checks after a transaction with at least one output paying him is found, the increase to his overall scanning requirement is negligible.\n+\n+''' Preventing address reuse '''\n+\n+If Alice were to use a different UTXO from the same public key ''A'' for a subsequent payment to Bob, she would end up deriving the same destination ''P''. To prevent this, Alice should include a hash of the outpoint in the following manner:\n+\n+* Let ''outpoint_hash = hash(txid || vout)''\n+* Let ''P<sub>0</sub> = B + hash(outpoint_hash·a·B || 0)·G''\n+\n+Bob must include the same ''outpoint_hash'' when scanning.",
      "path": "bip-0352.mediawiki",
      "position": 87,
      "original_position": 87,
      "commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "original_commit_id": "c55f80c53c98642357712c1839cfdc0551d531c4",
      "in_reply_to_id": null,
      "user": {
        "login": "stevenroose",
        "id": 853468,
        "node_id": "MDQ6VXNlcjg1MzQ2OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/853468?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stevenroose",
        "html_url": "https://github.com/stevenroose",
        "followers_url": "https://api.github.com/users/stevenroose/followers",
        "following_url": "https://api.github.com/users/stevenroose/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stevenroose/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stevenroose/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stevenroose/subscriptions",
        "organizations_url": "https://api.github.com/users/stevenroose/orgs",
        "repos_url": "https://api.github.com/users/stevenroose/repos",
        "events_url": "https://api.github.com/users/stevenroose/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stevenroose/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why multiply and not concatenate? ",
      "created_at": "2023-09-02T16:04:28Z",
      "updated_at": "2023-09-07T18:44:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1458#discussion_r1313885038",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1313885038"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1458"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 87,
      "original_line": 87,
      "side": "RIGHT"
    }
  ]
}