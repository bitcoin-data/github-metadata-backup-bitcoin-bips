{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/1421",
    "id": 1239606456,
    "node_id": "PR_kwDOAN28mc5J4uS4",
    "html_url": "https://github.com/bitcoin/bips/pull/1421",
    "diff_url": "https://github.com/bitcoin/bips/pull/1421.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/1421.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1421/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/de9ef59307f5d94883eefd2c6691c67d358d915a",
    "number": 1421,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Add OP_VAULT (BIP 345)",
    "user": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Pairs with the draft implementation in https://github.com/bitcoin-inquisition/bitcoin/pull/21.",
    "labels": [],
    "created_at": "2023-02-13T20:55:10Z",
    "updated_at": "2024-01-16T20:38:32Z",
    "mergeable": true,
    "mergeable_state": "clean",
    "merge_commit_sha": "e7e77b5e51c20a203995dbe1900db72a028d6ca7",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "jamesob:jamesob-23-02-opvault",
      "ref": "jamesob-23-02-opvault",
      "sha": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 96449859,
        "node_id": "MDEwOlJlcG9zaXRvcnk5NjQ0OTg1OQ==",
        "name": "bips",
        "full_name": "jamesob/bips",
        "owner": {
          "login": "jamesob",
          "id": 73197,
          "node_id": "MDQ6VXNlcjczMTk3",
          "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/jamesob",
          "html_url": "https://github.com/jamesob",
          "followers_url": "https://api.github.com/users/jamesob/followers",
          "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
          "organizations_url": "https://api.github.com/users/jamesob/orgs",
          "repos_url": "https://api.github.com/users/jamesob/repos",
          "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/jamesob/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/jamesob/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/jamesob/bips",
        "archive_url": "https://api.github.com/repos/jamesob/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/jamesob/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/jamesob/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/jamesob/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/jamesob/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/jamesob/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/jamesob/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/jamesob/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/jamesob/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/jamesob/bips/contributors",
        "deployments_url": "https://api.github.com/repos/jamesob/bips/deployments",
        "downloads_url": "https://api.github.com/repos/jamesob/bips/downloads",
        "events_url": "https://api.github.com/repos/jamesob/bips/events",
        "forks_url": "https://api.github.com/repos/jamesob/bips/forks",
        "git_commits_url": "https://api.github.com/repos/jamesob/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/jamesob/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/jamesob/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/jamesob/bips.git",
        "issue_comment_url": "https://api.github.com/repos/jamesob/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/jamesob/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/jamesob/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/jamesob/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/jamesob/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/jamesob/bips/languages",
        "merges_url": "https://api.github.com/repos/jamesob/bips/merges",
        "milestones_url": "https://api.github.com/repos/jamesob/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/jamesob/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/jamesob/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/jamesob/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:jamesob/bips.git",
        "stargazers_url": "https://api.github.com/repos/jamesob/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/jamesob/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/jamesob/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/jamesob/bips/subscription",
        "tags_url": "https://api.github.com/repos/jamesob/bips/tags",
        "teams_url": "https://api.github.com/repos/jamesob/bips/teams",
        "trees_url": "https://api.github.com/repos/jamesob/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/jamesob/bips.git",
        "hooks_url": "https://api.github.com/repos/jamesob/bips/hooks",
        "svn_url": "https://github.com/jamesob/bips",
        "homepage": "bitcoin.org",
        "language": "Wikitext",
        "forks_count": 3,
        "stargazers_count": 5,
        "watchers_count": 5,
        "size": 14057,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-01-03T21:12:09Z",
        "created_at": "2017-07-06T16:21:18Z",
        "updated_at": "2023-03-19T19:15:08Z"
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "e918b50731397872ad2922a1b08a5a4cd1d6d546",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5705,
        "stargazers_count": 8604,
        "watchers_count": 8604,
        "size": 13739,
        "default_branch": "master",
        "open_issues_count": 131,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2024-01-16T17:24:53Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2024-01-16T19:23:45Z"
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 1797,
    "deletions": 0,
    "changed_files": 5,
    "commits": 30,
    "review_comments": 116,
    "comments": 33
  },
  "events": [
    {
      "event": "head_ref_force_pushed",
      "id": 8508852346,
      "node_id": "HRFPE_lADOAN28mc5eW19HzwAAAAH7Ksh6",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8508852346",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-13T21:01:05Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8509999150,
      "node_id": "HRFPE_lADOAN28mc5eW19HzwAAAAH7PEgu",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8509999150",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-13T23:58:53Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGIzMGUzN2M4YTI2ZDZiMTg0MTU0MDZhNTY2NGFhZWY5OTI5YThhYzU",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "tree": {
        "sha": "f60079250173b2fd907f71d246c03655bbed6a23",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/f60079250173b2fd907f71d246c03655bbed6a23"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/1a632a38751b24bb18b5e20e65a4b07e4f46b4e0",
          "sha": "1a632a38751b24bb18b5e20e65a4b07e4f46b4e0",
          "html_url": "https://github.com/bitcoin/bips/commit/1a632a38751b24bb18b5e20e65a4b07e4f46b4e0"
        }
      ],
      "message": "Add OP_VAULT BIP",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-13T23:58:59Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-08T21:11:18Z"
      },
      "sha": "b30e37c8a26d6b18415406a5664aaef9929a8ac5"
    },
    {
      "event": "reviewed",
      "id": 1297180793,
      "node_id": "PRR_kwDOAN28mc5NUWh5",
      "url": null,
      "actor": null,
      "commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK! Looking forward to the merge into inquisition and prototyping with these opcodes.",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1297180793",
      "submitted_at": "2023-02-14T11:03:38Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "reviewed",
      "id": 1297360997,
      "node_id": "PRR_kwDOAN28mc5NVChl",
      "url": null,
      "actor": null,
      "commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1297360997",
      "submitted_at": "2023-02-14T11:22:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDQ3NmFlYTMxMDdiNjQ1OWFkNGU5Y2Y1ZDA2NDNiMWU5NTZmM2M1Y2I",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/476aea3107b6459ad4e9cf5d0643b1e956f3c5cb",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/476aea3107b6459ad4e9cf5d0643b1e956f3c5cb",
      "tree": {
        "sha": "7af9c13d3bcc580efc8a665d38e391dc7293a316",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/7af9c13d3bcc580efc8a665d38e391dc7293a316"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/b30e37c8a26d6b18415406a5664aaef9929a8ac5",
          "sha": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
          "html_url": "https://github.com/bitcoin/bips/commit/b30e37c8a26d6b18415406a5664aaef9929a8ac5"
        }
      ],
      "message": "fixup! typos and clarification\n\nfrom feedback by Gleb and Joost.",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-14T17:50:05Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-14T17:50:05Z"
      },
      "sha": "476aea3107b6459ad4e9cf5d0643b1e956f3c5cb"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8518345792,
      "node_id": "HRFPE_lADOAN28mc5eW19HzwAAAAH7u6RA",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8518345792",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-14T18:09:50Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDkxMjRmMjk0MGU2MzE1ZGVhYWVlNGFjYTkyYTgyNTBhZWFhM2FjYTc",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/9124f2940e6315deaaee4aca92a8250aeaa3aca7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/9124f2940e6315deaaee4aca92a8250aeaa3aca7",
      "tree": {
        "sha": "7e66031a45ff001296cd03f974333dfdbc5cecf0",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/7e66031a45ff001296cd03f974333dfdbc5cecf0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/476aea3107b6459ad4e9cf5d0643b1e956f3c5cb",
          "sha": "476aea3107b6459ad4e9cf5d0643b1e956f3c5cb",
          "html_url": "https://github.com/bitcoin/bips/commit/476aea3107b6459ad4e9cf5d0643b1e956f3c5cb"
        }
      ],
      "message": "fixup! image clarifications",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-14T18:10:03Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-14T18:07:22Z"
      },
      "sha": "9124f2940e6315deaaee4aca92a8250aeaa3aca7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGM1ODk0OTBmOThiYTFiMGM2MDZkMGUyMDMwNDYzZjFmZGU1NGI3ODY",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/c589490f98ba1b0c606d0e2030463f1fde54b786",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/c589490f98ba1b0c606d0e2030463f1fde54b786",
      "tree": {
        "sha": "a4477f593b1a08eb6d83b1662a1e52ddc40cadcc",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/a4477f593b1a08eb6d83b1662a1e52ddc40cadcc"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/9124f2940e6315deaaee4aca92a8250aeaa3aca7",
          "sha": "9124f2940e6315deaaee4aca92a8250aeaa3aca7",
          "html_url": "https://github.com/bitcoin/bips/commit/9124f2940e6315deaaee4aca92a8250aeaa3aca7"
        }
      ],
      "message": "vaults: make recovery transaction explicit\n\nInstead of implicitly detecting whether or not an OP_VAULT/OP_UNVAULT\nspend is a recovery spend by scanning outputs for matching\nscriptPubKeys, explicitly indicate recoveries by requiring a witness\nstack element that is either -1 in the case of no recovery OR\ncorresponds to an output index that is the recovery output.",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-15T18:56:22Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-15T18:56:22Z"
      },
      "sha": "c589490f98ba1b0c606d0e2030463f1fde54b786"
    },
    {
      "event": "commented",
      "id": 1433065779,
      "node_id": "IC_kwDOAN28mc5Vatkz",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1433065779",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T13:09:47Z",
      "updated_at": "2023-02-16T13:09:47Z",
      "author_association": "CONTRIBUTOR",
      "body": "Can this get a number assigned?",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1433065779",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T15:39:52Z",
      "updated_at": "2023-02-16T15:39:52Z",
      "source": {
        "issue": {
          "id": 1525874732,
          "node_id": "PR_kwDOABII585G_d-D",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26857",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26857/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26857/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26857/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/26857",
          "number": 26857,
          "state": "closed",
          "state_reason": null,
          "title": "OP_VAULT draft",
          "body": "This is a draft for a consensus change enabling on-chain vaults, as detailed in the BIP: https://github.com/bitcoin/bips/pull/1421\r\n\r\nIn short, it introduces two opcodes, `OP_VAULT` and `OP_UNVAULT`, that facilitate constructing vaults which\r\n\r\n- allow multiple deposits,\r\n- allow partial unvaultings and recursive re-vaults,\r\n- allow batch operations (recoveries and unvaultings) using vaults with compatible parameters,\r\n- support dynamic withdrawal target specification, and\r\n- support robust fee management.\r\n\r\nFor the last item, the proposal has a hard dependency on package relay and ephemeral anchors.\r\n\r\nThe code as-written here lacks specific activation mechanism, and there's probably some policy/wallet stuff missing,\r\n but in substance it is implemented and comes with some interesting functional tests.\r\n",
          "user": {
            "login": "jamesob",
            "id": 73197,
            "node_id": "MDQ6VXNlcjczMTk3",
            "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jamesob",
            "html_url": "https://github.com/jamesob",
            "followers_url": "https://api.github.com/users/jamesob/followers",
            "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
            "organizations_url": "https://api.github.com/users/jamesob/orgs",
            "repos_url": "https://api.github.com/users/jamesob/repos",
            "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jamesob/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 192202000,
              "node_id": "MDU6TGFiZWwxOTIyMDIwMDA=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Consensus",
              "name": "Consensus",
              "color": "009800",
              "default": false
            },
            {
              "id": 955867938,
              "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "description": "",
              "color": "cccccc",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 9,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26857",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/26857",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/26857.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/26857.patch"
          },
          "closed_at": "2023-03-21T16:41:32Z",
          "created_at": "2023-01-09T16:02:53Z",
          "updated_at": "2023-03-21T16:41:34Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T16:20:13Z",
      "updated_at": "2023-02-16T16:20:13Z",
      "source": {
        "issue": {
          "id": 1587988466,
          "node_id": "PR_kwDOHVjEp85KJYhi",
          "url": "https://api.github.com/repos/bitcoin-inquisition/bitcoin/issues/21",
          "repository_url": "https://api.github.com/repos/bitcoin-inquisition/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin-inquisition/bitcoin/issues/21/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-inquisition/bitcoin/issues/21/comments",
          "events_url": "https://api.github.com/repos/bitcoin-inquisition/bitcoin/issues/21/events",
          "html_url": "https://github.com/bitcoin-inquisition/bitcoin/pull/21",
          "number": 21,
          "state": "closed",
          "state_reason": null,
          "title": "Implement BIP 345 validation (OP_VAULT)",
          "body": "The usual cross-port process from https://github.com/bitcoin/bitcoin/pull/26857.\r\n\r\nBIP: https://github.com/bitcoin/bips/pull/1421",
          "user": {
            "login": "jamesob",
            "id": 73197,
            "node_id": "MDQ6VXNlcjczMTk3",
            "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jamesob",
            "html_url": "https://github.com/jamesob",
            "followers_url": "https://api.github.com/users/jamesob/followers",
            "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
            "organizations_url": "https://api.github.com/users/jamesob/orgs",
            "repos_url": "https://api.github.com/users/jamesob/repos",
            "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jamesob/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 5413528533,
              "node_id": "LA_kwDOHVjEp88AAAABQqvj1Q",
              "url": "https://api.github.com/repos/bitcoin-inquisition/bitcoin/labels/bip345",
              "name": "bip345",
              "description": "",
              "color": "E48F8C",
              "default": false
            },
            {
              "id": 5635511078,
              "node_id": "LA_kwDOHVjEp88AAAABT-cTJg",
              "url": "https://api.github.com/repos/bitcoin-inquisition/bitcoin/labels/Needs%20rebase",
              "name": "Needs rebase",
              "color": "ededed",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "NONE",
          "milestone": {
            "url": "https://api.github.com/repos/bitcoin-inquisition/bitcoin/milestones/3",
            "html_url": "https://github.com/bitcoin-inquisition/bitcoin/milestone/3",
            "labels_url": "https://api.github.com/repos/bitcoin-inquisition/bitcoin/milestones/3/labels",
            "id": 9856594,
            "node_id": "MI_kwDOHVjEp84AlmZS",
            "number": 3,
            "state": "open",
            "title": "25.x",
            "creator": {
              "login": "ajtowns",
              "id": 127186,
              "node_id": "MDQ6VXNlcjEyNzE4Ng==",
              "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/ajtowns",
              "html_url": "https://github.com/ajtowns",
              "followers_url": "https://api.github.com/users/ajtowns/followers",
              "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
              "organizations_url": "https://api.github.com/users/ajtowns/orgs",
              "repos_url": "https://api.github.com/users/ajtowns/repos",
              "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/ajtowns/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 1,
            "closed_issues": 8,
            "created_at": "2023-08-29T17:44:53Z",
            "updated_at": "2023-12-20T15:55:10Z"
          },
          "locked": false,
          "comments": 8,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin-inquisition/bitcoin/pulls/21",
            "html_url": "https://github.com/bitcoin-inquisition/bitcoin/pull/21",
            "diff_url": "https://github.com/bitcoin-inquisition/bitcoin/pull/21.diff",
            "patch_url": "https://github.com/bitcoin-inquisition/bitcoin/pull/21.patch"
          },
          "closed_at": "2023-12-20T15:55:09Z",
          "created_at": "2023-02-16T16:20:13Z",
          "updated_at": "2024-01-09T09:19:43Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1304487643,
      "node_id": "PRR_kwDOAN28mc5NwObb",
      "url": null,
      "actor": null,
      "commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1304487643",
      "submitted_at": "2023-02-18T07:39:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "reviewed",
      "id": 1304601446,
      "node_id": "PRR_kwDOAN28mc5NwqNm",
      "url": null,
      "actor": null,
      "commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1304601446",
      "submitted_at": "2023-02-18T14:40:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8573063955,
      "node_id": "HRFPE_lADOAN28mc5eW19HzwAAAAH-_pMT",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8573063955",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T16:46:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8573080017,
      "node_id": "HRFPE_lADOAN28mc5eW19HzwAAAAH-_tHR",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8573080017",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T16:48:25Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8573179475,
      "node_id": "HRFPE_lADOAN28mc5eW19HzwAAAAH_AFZT",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8573179475",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T16:59:23Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDU4Y2JjNGU5YjFjNzM5OTViOTk3MmIwNmI0NjY5M2EzMTNiMjZkZmE",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/58cbc4e9b1c73995b9972b06b46693a313b26dfa",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/58cbc4e9b1c73995b9972b06b46693a313b26dfa",
      "tree": {
        "sha": "1ff473fa8c62213926f6201215a331fb051f9e2b",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/1ff473fa8c62213926f6201215a331fb051f9e2b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/c589490f98ba1b0c606d0e2030463f1fde54b786",
          "sha": "c589490f98ba1b0c606d0e2030463f1fde54b786",
          "html_url": "https://github.com/bitcoin/bips/commit/c589490f98ba1b0c606d0e2030463f1fde54b786"
        }
      ],
      "message": "vaults: various feedback\n\nThanks to Vojtěch Strnad for most of this.",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-21T16:59:31Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-21T16:40:31Z"
      },
      "sha": "58cbc4e9b1c73995b9972b06b46693a313b26dfa"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDAyMDRjOWExZjlhOTA3NWYyNDgzNDUwZjFiYWIwMzRkNDUzMjcwYjc",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/0204c9a1f9a9075f2483450f1bab034d453270b7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/0204c9a1f9a9075f2483450f1bab034d453270b7",
      "tree": {
        "sha": "da9c6351466111c27644536aa7af030c3df82fea",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/da9c6351466111c27644536aa7af030c3df82fea"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/58cbc4e9b1c73995b9972b06b46693a313b26dfa",
          "sha": "58cbc4e9b1c73995b9972b06b46693a313b26dfa",
          "html_url": "https://github.com/bitcoin/bips/commit/58cbc4e9b1c73995b9972b06b46693a313b26dfa"
        }
      ],
      "message": "vaults: make recovery output structure a matter of policy\n\nSince constraints on unauthorized recovery transaction structure exist\nonly to avoid pinning, make them a matter of policy and not consensus.",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-21T16:59:36Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-21T16:58:11Z"
      },
      "sha": "0204c9a1f9a9075f2483450f1bab034d453270b7"
    },
    {
      "event": "reviewed",
      "id": 1307838931,
      "node_id": "PRR_kwDOAN28mc5N9AnT",
      "url": null,
      "actor": null,
      "commit_id": "0204c9a1f9a9075f2483450f1bab034d453270b7",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1307838931",
      "submitted_at": "2023-02-21T17:02:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "reviewed",
      "id": 1307840006,
      "node_id": "PRR_kwDOAN28mc5N9A4G",
      "url": null,
      "actor": null,
      "commit_id": "0204c9a1f9a9075f2483450f1bab034d453270b7",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Missing section on backward compatibility",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1307840006",
      "submitted_at": "2023-02-21T17:03:37Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDZmZjhlZmQzZDE5NWNmNDZiOTM1M2FmM2FkNDk4ODZhNTBlZGE3MzQ",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/6ff8efd3d195cf46b9353af3ad49886a50eda734",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/6ff8efd3d195cf46b9353af3ad49886a50eda734",
      "tree": {
        "sha": "d8034404524745b44496eeca718854ccf7fdf8cc",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/d8034404524745b44496eeca718854ccf7fdf8cc"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/0204c9a1f9a9075f2483450f1bab034d453270b7",
          "sha": "0204c9a1f9a9075f2483450f1bab034d453270b7",
          "html_url": "https://github.com/bitcoin/bips/commit/0204c9a1f9a9075f2483450f1bab034d453270b7"
        }
      ],
      "message": "vaults: blank deployment",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-21T21:08:23Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-21T21:08:23Z"
      },
      "sha": "6ff8efd3d195cf46b9353af3ad49886a50eda734"
    },
    {
      "event": "commented",
      "id": 1439099939,
      "node_id": "IC_kwDOAN28mc5Vxuwj",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1439099939",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T21:12:12Z",
      "updated_at": "2023-02-21T21:12:12Z",
      "author_association": "MEMBER",
      "body": "> Missing section on backward compatibility\r\n\r\nSimilar BIPs, like [BIP-0065](https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki), lack this section. I'm not sure what I would include in it because this just tightens validation rules around OP_SUCCESS187 and OP_SUCCESS188.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1439099939",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDI0MjQxZWUyNmJjNTlhM2QzZjA5NDE5MDAzMDg2NWQ5MjFmNTUzZjQ",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/24241ee26bc59a3d3f094190030865d921f553f4",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/24241ee26bc59a3d3f094190030865d921f553f4",
      "tree": {
        "sha": "9eaccd193d7be38f93e726215923db8676f723e8",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/9eaccd193d7be38f93e726215923db8676f723e8"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 9eaccd193d7be38f93e726215923db8676f723e8\nparent 6ff8efd3d195cf46b9353af3ad49886a50eda734\nauthor Jameson Lopp <jameson.lopp@gmail.com> 1677072423 -0600\ncommitter GitHub <noreply@github.com> 1677072423 -0600\n\ntypos / gramma cleanup",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj9hgnCRBK7hj4Ov3rIwAAKh0IABLKrzBliMLEW7q8fEz+TKRM\nS6fnHUwsU4P4FvLpNuQw8vONe1hRiewiMAd96O+FkcdjH2MrRik9Kqwk8iG/euts\nZG5bNaPu/n5ioB1q2I5+Sjx/RccAxghMRQggwR0oG1LjzgBTe5SjPgCGzKtLnPzL\nEJY8jcxftkQViM+b2F3Vit05DfdRekWMsRyMa3cmY1zOUwMc79a8NxLMjxKTpPw5\ngQBKs/JNeW8Bgkcu5qwpeTzCUv7xpmjVKWjZ2KRUxV94DLICvS6Qj6hZR51w09cV\nzD23ocBA9GbMaC767RlX3s9Hjb5fXHoDDoYxDoEEDIf6G+3mq2RZb+flo0y4sCI=\n=ABIa\n-----END PGP SIGNATURE-----\n"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/6ff8efd3d195cf46b9353af3ad49886a50eda734",
          "sha": "6ff8efd3d195cf46b9353af3ad49886a50eda734",
          "html_url": "https://github.com/bitcoin/bips/commit/6ff8efd3d195cf46b9353af3ad49886a50eda734"
        }
      ],
      "message": "typos / gramma cleanup",
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2023-02-22T13:27:03Z"
      },
      "author": {
        "name": "Jameson Lopp",
        "email": "jameson.lopp@gmail.com",
        "date": "2023-02-22T13:27:03Z"
      },
      "sha": "24241ee26bc59a3d3f094190030865d921f553f4"
    },
    {
      "event": "commented",
      "id": 1442718400,
      "node_id": "IC_kwDOAN28mc5V_iLA",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1442718400",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-24T02:42:41Z",
      "updated_at": "2023-02-24T02:42:41Z",
      "author_association": "MEMBER",
      "body": "In my book, it is perfectly fine (if it applies) to say that there are no backwards compatibility issues, especially if it is stated why that is the case (e.g. \"because the op-codes in question are OP_SUCCESSes\"). Not having a backwards compatibility section means the reader has to determine whether there are any, by themselves.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1442718400",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-24T05:41:50Z",
      "updated_at": "2023-02-24T05:41:50Z",
      "source": {
        "issue": {
          "id": 1395298183,
          "node_id": "PR_kwDOAN28mc5AFd1p",
          "url": "https://api.github.com/repos/bitcoin/bips/issues/1372",
          "repository_url": "https://api.github.com/repos/bitcoin/bips",
          "labels_url": "https://api.github.com/repos/bitcoin/bips/issues/1372/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1372/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bips/issues/1372/events",
          "html_url": "https://github.com/bitcoin/bips/pull/1372",
          "number": 1372,
          "state": "closed",
          "state_reason": null,
          "title": "Add BIP MuSig2",
          "body": "This PR adds a BIP for the MuSig2 protocol. We, the BIP authors, posted an initial draft version to the [bitcoin-dev mailing list in April](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-April/020198.html). Since then, we have addressed feedback from the mailing list and the development git repository (to the best of our knowledge, we didn't leave feedback unaddressed). We kept the resulting change log in the BIP draft. In the past weeks, we received no requests for major changes or features, which indicates that it is a good time to stabilize the BIP draft. The development git repo is archived at https://github.com/jonasnick/bips.\r\n\r\nThere are already multiple (experimental) implementations of the draft, such as:\r\n- the reference python implementation included in this PR (supports BIP version 1.0.0)\r\n- a [libsecp256k1-zkp module](https://github.com/ElementsProject/secp256k1-zkp/blob/master/include/secp256k1_musig.h) (currently supports BIP version 0.1.0)\r\n- [btcec](https://github.com/btcsuite/btcd/tree/master/btcec/schnorr/musig2) (currently supports BIP version 0.4.0)\r\n- [secp256kfun](https://github.com/LLFourn/secp256kfun/blob/master/schnorr_fun/src/musig.rs) (supports BIP version 1.0.0)\r\n- [nbitcoin](https://github.com/MetacoSA/NBitcoin/pull/1128) (supports BIP version 1.0.0)\r\n\r\n**TODO:**\r\n\r\n- [x] resolve https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-October/021000.html\r\n- [x] after BIP number is assigned, replace alias `bip-musig2` with `bip-<number>`\r\n\r\nCC @real-or-random @robot-dreams\r\n\r\n",
          "user": {
            "login": "jonasnick",
            "id": 2582071,
            "node_id": "MDQ6VXNlcjI1ODIwNzE=",
            "avatar_url": "https://avatars.githubusercontent.com/u/2582071?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jonasnick",
            "html_url": "https://github.com/jonasnick",
            "followers_url": "https://api.github.com/users/jonasnick/followers",
            "following_url": "https://api.github.com/users/jonasnick/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jonasnick/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jonasnick/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jonasnick/subscriptions",
            "organizations_url": "https://api.github.com/users/jonasnick/orgs",
            "repos_url": "https://api.github.com/users/jonasnick/repos",
            "events_url": "https://api.github.com/users/jonasnick/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jonasnick/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 21,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bips/pulls/1372",
            "html_url": "https://github.com/bitcoin/bips/pull/1372",
            "diff_url": "https://github.com/bitcoin/bips/pull/1372.diff",
            "patch_url": "https://github.com/bitcoin/bips/pull/1372.patch"
          },
          "closed_at": "2023-03-27T09:40:32Z",
          "created_at": "2022-10-03T20:35:31Z",
          "updated_at": "2023-03-27T09:43:03Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1446814696,
      "node_id": "IC_kwDOAN28mc5WPKPo",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1446814696",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-27T18:11:41Z",
      "updated_at": "2023-02-27T18:11:41Z",
      "author_association": "MEMBER",
      "body": "Can this get a number assigned please? Is there anything blocking?",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1446814696",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "commented",
      "id": 1449762403,
      "node_id": "IC_kwDOAN28mc5WaZ5j",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1449762403",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-01T10:04:26Z",
      "updated_at": "2023-03-01T10:04:26Z",
      "author_association": "MEMBER",
      "body": "Looking at this over the next few days. Please hold on.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1449762403",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "reviewed",
      "id": 1321173414,
      "node_id": "PRR_kwDOAN28mc5Ov4Gm",
      "url": null,
      "actor": null,
      "commit_id": "61dd727556d98e3fa983cf51e5eb2833f0cbe89d",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "One question: when I discussed a similar idea some years back -- https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015793.html -- I was told that it was not going to work, because it essentially incentivizes the attacker to kill the victim, in order to guarantee that the victim won't \"revoke\" or otherwise take back their coins within the \"grace\" (?) period. I admit I'm honestly not sure how this proposal addresses that particular concern.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1321173414",
      "submitted_at": "2023-03-02T07:44:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "commented",
      "id": 1451971770,
      "node_id": "IC_kwDOAN28mc5Wi1S6",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1451971770",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-02T14:39:00Z",
      "updated_at": "2023-03-02T14:49:54Z",
      "author_association": "MEMBER",
      "body": "> One question: when I discussed a similar idea some years back -- https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015793.html \r\n\r\nDidn't realize you had proposed something along these lines - will add to references.\r\n\r\n> I was told that it was not going to work, because it essentially incentivizes the attacker to kill the victim, in order to guarantee that the victim won't \"revoke\" or otherwise take back their coins within the \"grace\" (?) period. I admit I'm honestly not sure how this proposal addresses that particular concern.\r\n\r\nI want to be clear that I think most of the benefit of using vaults comes in addressing remote attacks, where someone compromises a key remotely from live infrastructure or has backdoored some hardware that you would otherwise be relying on. I think the potential benefit for individual users is plain, and if you ask basically any industrial custodian, they would be likely to tell you of the potential value of this capability.\r\n\r\nI thought the provable time delay was novel and interesting, but I can remove that section if it muddles the use of this proposal.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1451971770",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8650146606,
      "node_id": "HRFPE_lADOAN28mc5eW19HzwAAAAIDlsMu",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8650146606",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-02T14:41:52Z"
    },
    {
      "event": "commented",
      "id": 1452232914,
      "node_id": "IC_kwDOAN28mc5Wj1DS",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1452232914",
      "actor": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-02T17:17:35Z",
      "updated_at": "2023-03-02T17:17:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "> essentially incentivizes the attacker to kill the victim\r\n\r\nMaybe I misunderstand, but I believe this problem can be mitigated by setting up some form of dead man's switch using a watchtower service that would either initiate the recovery process itself (this involves some degree of trust) or notify a group of close individuals who possess the recovery data necessary (and may be better positioned to verify the legitimacy of the unvault). I imagine these setups will be quite ubiquitous for people using OP_VAULT or similar if we get it deployed.",
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1452232914",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "commented",
      "id": 1452332655,
      "node_id": "IC_kwDOAN28mc5WkNZv",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1452332655",
      "actor": {
        "login": "harding",
        "id": 61096,
        "node_id": "MDQ6VXNlcjYxMDk2",
        "avatar_url": "https://avatars.githubusercontent.com/u/61096?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/harding",
        "html_url": "https://github.com/harding",
        "followers_url": "https://api.github.com/users/harding/followers",
        "following_url": "https://api.github.com/users/harding/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/harding/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/harding/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/harding/subscriptions",
        "organizations_url": "https://api.github.com/users/harding/orgs",
        "repos_url": "https://api.github.com/users/harding/repos",
        "events_url": "https://api.github.com/users/harding/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/harding/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-02T18:19:24Z",
      "updated_at": "2023-03-02T18:19:24Z",
      "author_association": "CONTRIBUTOR",
      "body": "> it essentially incentivizes the attacker to kill the victim\r\n\r\nA discussion about that subject between sipa, kanzure, gmaxwell, maaku,\r\nand myself can be found at: \r\n\r\nhttps://gnusha.org/taproot-bip-review/2020-02-10.log\r\n\r\nThe details box below has a few quotes I thought were relevant (lightly edited):\r\n\r\n<details>\r\n<pre><code>\r\n13:54 < harding> If someone gets your private key but knows they can\r\nonly spend 1/nth of them before you're able to send the rest to cold\r\nstorage (or burn them), don't they then have a strong incentive to kill\r\nyou (or at least, hold you hostage away from your computer)?  It's like\r\na story I once heard of where, when anti-theft engine disablement\r\nmechanisms became popular in Russia, carjackings skyrocketed, leading to\r\nmore people being injured or dying (though the story didn't say how much\r\ncar theft was reduced).\r\n\r\n13:54 < gmaxwell> If someone kidnaps you and is going to hit you with a\r\n$5 wrench until you give them the coins, telling them you control no\r\ncoins that you can immediately move is just going to get you killed or\r\nseriously injured.\r\n\r\n13:57 < gmaxwell> kanzure: I think privacy is a much better protection\r\nvia technical means, in spite of its limitations.\r\n\r\n13:57 < kanzure> privacy is not robust... once you lose your privacy,\r\nyou can't get it back.\r\n\r\n13:58 < gmaxwell> kanzure: I'm saying that no matter what you do most\r\neveryone is already lying about their cold storage stratgy (including\r\nlying that they have one), so a prospective kidnapper would probably\r\njust ignore those claims and instead use absent privacy to choose\r\ntargets they are confident own enough coins to make their risks\r\nworthwhile.\r\n\r\n14:00 < kanzure> yes cage-until-expiration is something that requires\r\nyou to setup tripwires and deadman-whatevers before you get kidnapped\r\n\r\n14:05 < gmaxwell> The challenge with coersion is that if you're already\r\nassuming attackers who will kidnap-- you're better off yielding, and\r\nprecommiting to not yeald just carries a lot of risk of martyring\r\nyourself over some mere money.  particularly because it's fundimentally\r\nimpossible to prove that beating you harder won't get you to disclose\r\nsomething valuable, if not the keys for some specific outputs the keys\r\nfor some other unencoumbered outputs.\r\n\r\n14:08 < gmaxwell> one should also consider that a lot of kidnappers are\r\nnot the brightest builbs.  There are cases of educated metntally stable\r\nhighly socipathic kidnappers, but there are a lot of cases of drugged\r\nout idiots.  The former might be dissuaded by protective coloration...\r\nthe latter not so much.  Both are probably better defended against by\r\ntraditional security trappings...  locked fences, lights, cameras, guard\r\ndogs, security, etc.\r\n</code></pre>\r\n</details>",
      "user": {
        "login": "harding",
        "id": 61096,
        "node_id": "MDQ6VXNlcjYxMDk2",
        "avatar_url": "https://avatars.githubusercontent.com/u/61096?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/harding",
        "html_url": "https://github.com/harding",
        "followers_url": "https://api.github.com/users/harding/followers",
        "following_url": "https://api.github.com/users/harding/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/harding/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/harding/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/harding/subscriptions",
        "organizations_url": "https://api.github.com/users/harding/orgs",
        "repos_url": "https://api.github.com/users/harding/repos",
        "events_url": "https://api.github.com/users/harding/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/harding/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1452332655",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "commented",
      "id": 1452765390,
      "node_id": "IC_kwDOAN28mc5Wl3DO",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1452765390",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-03T00:29:12Z",
      "updated_at": "2023-03-03T00:29:12Z",
      "author_association": "CONTRIBUTOR",
      "body": "> I was told that it was not going to work, because it essentially incentivizes the attacker to kill the victim, in order to guarantee that the victim won't \"revoke\" or otherwise take back their coins within the \"grace\" (?) period. I admit I'm honestly not sure how this proposal addresses that particular concern.\r\n\r\na) The same argument applies to many things -- if you've sent a large lightning payment and received your receipt off-chain, instead of resolving the htlc off-chain you should kill/DoS your counterparty, wait for the timeout to complete, and claim a refund on-chain, getting both the goods and services and your money back. If you're dealing with amounts large enough to make kidnapping/murder worthwhile, you need to invest in personal security, not script hacks?\r\n\r\nb) If someone is aware of your utxos and able to kill you they could just demand you reveal your cold wallet/recovery key to them; then they can verify you gave them the correct private key, and claim all your funds immediately with no delay. That differs from the \"delay only\" paths in that here you can provably give them your bitcoin immediately in order to buy your freedom/life, so there's no incentive for them to kill you to avoid a race. I think this is a big difference between this and \"time lock and throw away the keys for any alterntive ways of spending\" approaches as far as this argument goes.\r\n\r\nc) You could increase the security of your bitcoin by having a third party sweep your funds to the recovery address if they see a withdrawal attempt and you don't do some out of band authentication, in which case killing you doesn't get them the bitcoins either.\r\n\r\n(I would have thought that sort of question would be better discussed on the list, not in the PR?)",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1452765390",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "commented",
      "id": 1452809232,
      "node_id": "IC_kwDOAN28mc5WmBwQ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1452809232",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-03T01:37:01Z",
      "updated_at": "2023-03-03T01:37:01Z",
      "author_association": "MEMBER",
      "body": "@jamesob \r\n\r\n> I thought the provable time delay was novel and interesting, but I can remove that section if it muddles the use of this proposal.\r\n\r\nNo, I think it's fine personally. As others have chimed in already, there are plenty of existing cases where this is the case.\r\n\r\n@ajtowns \r\n\r\n> (I would have thought that sort of question would be better discussed on the list, not in the PR?)\r\n\r\nYeah. I casually mentioned it thinking there was a \"D'oh, this is why\" answer in there that I didn't see.",
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1452809232",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "mentioned",
      "id": 8655421326,
      "node_id": "MEE_lADOAN28mc5eW19HzwAAAAID5z-O",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8655421326",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-03T01:37:01Z"
    },
    {
      "event": "subscribed",
      "id": 8655421334,
      "node_id": "SE_lADOAN28mc5eW19HzwAAAAID5z-W",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8655421334",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-03T01:37:01Z"
    },
    {
      "event": "mentioned",
      "id": 8655421342,
      "node_id": "MEE_lADOAN28mc5eW19HzwAAAAID5z-e",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8655421342",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-03T01:37:01Z"
    },
    {
      "event": "subscribed",
      "id": 8655421355,
      "node_id": "SE_lADOAN28mc5eW19HzwAAAAID5z-r",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8655421355",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-03T01:37:01Z"
    },
    {
      "event": "commented",
      "id": 1452814811,
      "node_id": "IC_kwDOAN28mc5WmDHb",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1452814811",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-03T01:43:52Z",
      "updated_at": "2023-03-03T01:43:52Z",
      "author_association": "MEMBER",
      "body": "Assigned BIP 345",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1452814811",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "renamed",
      "id": 8655496149,
      "node_id": "RTE_lADOAN28mc5eW19HzwAAAAID6GPV",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8655496149",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-03T01:55:28Z",
      "rename": {
        "from": "Add OP_VAULT BIP",
        "to": "Add OP_VAULT (BIP 345)"
      }
    },
    {
      "event": "reviewed",
      "id": 1329822398,
      "node_id": "PRR_kwDOAN28mc5PQ3q-",
      "url": null,
      "actor": null,
      "commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Reviewed so far until \"Specification\" excluded.",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1329822398",
      "submitted_at": "2023-03-08T02:08:57Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "reviewed",
      "id": 1335925575,
      "node_id": "PRR_kwDOAN28mc5PoJtH",
      "url": null,
      "actor": null,
      "commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1335925575",
      "submitted_at": "2023-03-11T20:28:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "commented",
      "id": 1480108541,
      "node_id": "IC_kwDOAN28mc5YOKn9",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1480108541",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-22T19:01:23Z",
      "updated_at": "2023-03-22T19:01:23Z",
      "author_association": "MEMBER",
      "body": "Oops; hadn't meant to push to this branch yet. Content here is currently in flux.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1480108541",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "comment_deleted",
      "id": 8822947544,
      "node_id": "CDE_lADOAN28mc5eW19HzwAAAAIN437Y",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8822947544",
      "actor": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-23T03:26:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8830164011,
      "node_id": "HRFPE_lADOAN28mc5eW19HzwAAAAIOUZwr",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8830164011",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-23T17:20:10Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8830204297,
      "node_id": "HRFPE_lADOAN28mc5eW19HzwAAAAIOUjmJ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8830204297",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-23T17:24:14Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDRmMDNhYWVhMmMxYTgzMGUwNjc2ODMwNzEzYzQ1NTc3ZjZmNDU5ODk",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/4f03aaea2c1a830e0676830713c45577f6f45989",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/4f03aaea2c1a830e0676830713c45577f6f45989",
      "tree": {
        "sha": "18e9358b41749cc94b8052c850e665402ae5a6ca",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/18e9358b41749cc94b8052c850e665402ae5a6ca"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/24241ee26bc59a3d3f094190030865d921f553f4",
          "sha": "24241ee26bc59a3d3f094190030865d921f553f4",
          "html_url": "https://github.com/bitcoin/bips/commit/24241ee26bc59a3d3f094190030865d921f553f4"
        }
      ],
      "message": "vaults: add backwards compatibility",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-03-23T17:24:17Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-23T13:57:45Z"
      },
      "sha": "4f03aaea2c1a830e0676830713c45577f6f45989"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDZkYzc2NmQ5MzdhMjBjZTNiYjBmNTY5NzljMjAzNTYyNTA4MTEyYTM",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/6dc766d937a20ce3bb0f56979c203562508112a3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/6dc766d937a20ce3bb0f56979c203562508112a3",
      "tree": {
        "sha": "d6df316f8397849c90e6eb7e53b8bba91ccbfbd8",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/d6df316f8397849c90e6eb7e53b8bba91ccbfbd8"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/4f03aaea2c1a830e0676830713c45577f6f45989",
          "sha": "4f03aaea2c1a830e0676830713c45577f6f45989",
          "html_url": "https://github.com/bitcoin/bips/commit/4f03aaea2c1a830e0676830713c45577f6f45989"
        }
      ],
      "message": "vaults: add Corey Haddad reference",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-03-23T17:24:17Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-02-23T14:14:15Z"
      },
      "sha": "6dc766d937a20ce3bb0f56979c203562508112a3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGYzMGZiNTJiYmIxNjU5ODI4MjNmOGFmMTMxYzhmZjZmZmI1NmViYTY",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/f30fb52bbb165982823f8af131c8ff6ffb56eba6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/f30fb52bbb165982823f8af131c8ff6ffb56eba6",
      "tree": {
        "sha": "433a0add258dd7136314407087b495f0f4814ae0",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/433a0add258dd7136314407087b495f0f4814ae0"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/6dc766d937a20ce3bb0f56979c203562508112a3",
          "sha": "6dc766d937a20ce3bb0f56979c203562508112a3",
          "html_url": "https://github.com/bitcoin/bips/commit/6dc766d937a20ce3bb0f56979c203562508112a3"
        }
      ],
      "message": "date fix\n\ncopypasta FTW",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-03-23T17:24:17Z"
      },
      "author": {
        "name": "Jameson Lopp",
        "email": "jameson.lopp@gmail.com",
        "date": "2023-02-28T20:59:11Z"
      },
      "sha": "f30fb52bbb165982823f8af131c8ff6ffb56eba6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDk5N2U0ZjRmMGU5MmNjYmM1ZjVjZGYzNGMyNjVjN2U1ZTQxZmE0YmM",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/997e4f4f0e92ccbc5f5cdf34c265c7e5e41fa4bc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/997e4f4f0e92ccbc5f5cdf34c265c7e5e41fa4bc",
      "tree": {
        "sha": "e018a9ae0addff37f015ae425cb706cd6f010305",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/e018a9ae0addff37f015ae425cb706cd6f010305"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/f30fb52bbb165982823f8af131c8ff6ffb56eba6",
          "sha": "f30fb52bbb165982823f8af131c8ff6ffb56eba6",
          "html_url": "https://github.com/bitcoin/bips/commit/f30fb52bbb165982823f8af131c8ff6ffb56eba6"
        }
      ],
      "message": "Update bip-vaults.mediawiki\n\nCo-authored-by: kallewoof <kalle.alm@gmail.com>",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-03-23T17:24:17Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "wild-github@au92.org",
        "date": "2023-03-02T14:35:01Z"
      },
      "sha": "997e4f4f0e92ccbc5f5cdf34c265c7e5e41fa4bc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDkxNWVkZTMyN2FmMTFlN2ZlNDEwNDFkOThjODhlMTUxMTc2M2ZkZTU",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/915ede327af11e7fe41041d98c88e1511763fde5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/915ede327af11e7fe41041d98c88e1511763fde5",
      "tree": {
        "sha": "1f1dad6372e2cd2b4819ff362ac2c28ffc88e011",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/1f1dad6372e2cd2b4819ff362ac2c28ffc88e011"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/997e4f4f0e92ccbc5f5cdf34c265c7e5e41fa4bc",
          "sha": "997e4f4f0e92ccbc5f5cdf34c265c7e5e41fa4bc",
          "html_url": "https://github.com/bitcoin/bips/commit/997e4f4f0e92ccbc5f5cdf34c265c7e5e41fa4bc"
        }
      ],
      "message": "fixup! add Kalle reference",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-03-23T17:24:17Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-03-02T14:41:15Z"
      },
      "sha": "915ede327af11e7fe41041d98c88e1511763fde5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDQ3YTI1ZDE1NDAzYmM1MGJhMGM1Yjk5MzgyZTBlYmQ5MDI5ZmNjOGQ",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/47a25d15403bc50ba0c5b99382e0ebd9029fcc8d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/47a25d15403bc50ba0c5b99382e0ebd9029fcc8d",
      "tree": {
        "sha": "c61e4884541b139bd01460fb41116c87a54a155c",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/c61e4884541b139bd01460fb41116c87a54a155c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/915ede327af11e7fe41041d98c88e1511763fde5",
          "sha": "915ede327af11e7fe41041d98c88e1511763fde5",
          "html_url": "https://github.com/bitcoin/bips/commit/915ede327af11e7fe41041d98c88e1511763fde5"
        }
      ],
      "message": "fixup! FLUification\n\nAdds AJ and Greg as co-authors",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-03-27T13:56:57Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-03-22T18:32:01Z"
      },
      "sha": "47a25d15403bc50ba0c5b99382e0ebd9029fcc8d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGEwYjQzMzQ3MWRmYTRhZGZiMzk4NDQyNzRiZjUyMTU5ZTQ1NzRjZjY",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/a0b433471dfa4adfb39844274bf52159e4574cf6",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/a0b433471dfa4adfb39844274bf52159e4574cf6",
      "tree": {
        "sha": "11e8f4e19d8a5cac7de63b83e192ee13c1bbb235",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/11e8f4e19d8a5cac7de63b83e192ee13c1bbb235"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/47a25d15403bc50ba0c5b99382e0ebd9029fcc8d",
          "sha": "47a25d15403bc50ba0c5b99382e0ebd9029fcc8d",
          "html_url": "https://github.com/bitcoin/bips/commit/47a25d15403bc50ba0c5b99382e0ebd9029fcc8d"
        }
      ],
      "message": "fixup! rename vaults BIP",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-03-27T13:57:13Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-03-23T17:23:08Z"
      },
      "sha": "a0b433471dfa4adfb39844274bf52159e4574cf6"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGE2NDUyZWFmMWE3ZmNhNjk3NDZmNzM5MzE4NTJiMDM4YzcwODEyM2U",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/a6452eaf1a7fca69746f73931852b038c708123e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/a6452eaf1a7fca69746f73931852b038c708123e",
      "tree": {
        "sha": "914e39ebf36c329ba8593d317fc115f111fd20dc",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/914e39ebf36c329ba8593d317fc115f111fd20dc"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/a0b433471dfa4adfb39844274bf52159e4574cf6",
          "sha": "a0b433471dfa4adfb39844274bf52159e4574cf6",
          "html_url": "https://github.com/bitcoin/bips/commit/a0b433471dfa4adfb39844274bf52159e4574cf6"
        }
      ],
      "message": "fixup! add TLUV references",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-03-27T13:57:13Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-03-23T17:31:22Z"
      },
      "sha": "a6452eaf1a7fca69746f73931852b038c708123e"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8854214756,
      "node_id": "HRFPE_lADOAN28mc5eW19HzwAAAAIPwJhk",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8854214756",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-27T13:58:23Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGUwOGY2YWQ0ZGZlZDFjYTY3ZGU5OTgzZDM3NWE5M2QxNDgxZDE2NDQ",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/e08f6ad4dfed1ca67de9983d375a93d1481d1644",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/e08f6ad4dfed1ca67de9983d375a93d1481d1644",
      "tree": {
        "sha": "d8200299fe6258532793783aa8266fd9dacb68ac",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/d8200299fe6258532793783aa8266fd9dacb68ac"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/a6452eaf1a7fca69746f73931852b038c708123e",
          "sha": "a6452eaf1a7fca69746f73931852b038c708123e",
          "html_url": "https://github.com/bitcoin/bips/commit/a6452eaf1a7fca69746f73931852b038c708123e"
        }
      ],
      "message": "few word changes",
      "committer": {
        "name": "Greg Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2023-03-28T16:13:45Z"
      },
      "author": {
        "name": "Greg Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2023-03-28T15:51:21Z"
      },
      "sha": "e08f6ad4dfed1ca67de9983d375a93d1481d1644"
    },
    {
      "event": "commented",
      "id": 1487229641,
      "node_id": "IC_kwDOAN28mc5YpVLJ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1487229641",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-28T16:18:11Z",
      "updated_at": "2023-03-28T16:18:11Z",
      "author_association": "MEMBER",
      "body": "To allow for batch validation of ec mults when computing the spk that needs to match `triggerOut`, I think the most natural place to smuggle in a parity bit is `trigger-vout-idx`, having the number's sign-ness the that parity bit. This would interfere with uses were the forwarded leaf is being *entirely* predetermined except for the `revault-vout-idx`, but I suppose in that extreme case one could put some conditionals in it to work around that issue, committing to both versions and choosing which one at spend time to use.\r\n\r\nIf we want to allow \"no trigger output\" for a revault-only action, maybe we can also allow  `trigger-vout-idx` to be out of bounds(exactly equal to number of outputs in tx?) and still pass validation. Currently I don't think that's allowed might disallow quick consolidations when many outputs with the same spk exist.\r\n\r\n",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1487229641",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDhiYWQ3MDNlZDgzOTFhNzM1ZTlkMWFkYmEyYmE5MmQ4OWEwYjA2ZTc",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/8bad703ed8391a735e9d1adba2ba92d89a0b06e7",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/8bad703ed8391a735e9d1adba2ba92d89a0b06e7",
      "tree": {
        "sha": "86a899d8eb90dce5ffa2aa4f675b5980b1424788",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/86a899d8eb90dce5ffa2aa4f675b5980b1424788"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/e08f6ad4dfed1ca67de9983d375a93d1481d1644",
          "sha": "e08f6ad4dfed1ca67de9983d375a93d1481d1644",
          "html_url": "https://github.com/bitcoin/bips/commit/e08f6ad4dfed1ca67de9983d375a93d1481d1644"
        }
      ],
      "message": "why n-pushes",
      "committer": {
        "name": "Greg Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2023-03-28T16:33:37Z"
      },
      "author": {
        "name": "Greg Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2023-03-28T16:30:36Z"
      },
      "sha": "8bad703ed8391a735e9d1adba2ba92d89a0b06e7"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDhiZjViODY5ZTU4NDBmYzU1NjRlMDFmNjJiZGJhYmM4YjhmZmNhYjI",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/8bf5b869e5840fc5564e01f62bdbabc8b8ffcab2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/8bf5b869e5840fc5564e01f62bdbabc8b8ffcab2",
      "tree": {
        "sha": "edd058f5461bc73329113eef9e1850d3fa3ba712",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/edd058f5461bc73329113eef9e1850d3fa3ba712"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/8bad703ed8391a735e9d1adba2ba92d89a0b06e7",
          "sha": "8bad703ed8391a735e9d1adba2ba92d89a0b06e7",
          "html_url": "https://github.com/bitcoin/bips/commit/8bad703ed8391a735e9d1adba2ba92d89a0b06e7"
        }
      ],
      "message": "remove vestigial reference in applications section",
      "committer": {
        "name": "Greg Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2023-03-28T16:39:03Z"
      },
      "author": {
        "name": "Greg Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2023-03-28T16:39:03Z"
      },
      "sha": "8bf5b869e5840fc5564e01f62bdbabc8b8ffcab2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDI5MzQ1YTEwZjBlOTkxZThmMjIzYmViOWE5Mjk4NGU3Njc5MTFhYzI",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/29345a10f0e991e8f223beb9a92984e767911ac2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/29345a10f0e991e8f223beb9a92984e767911ac2",
      "tree": {
        "sha": "a17ca89090501c8b594bb31d0f86b87a55d895c4",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/a17ca89090501c8b594bb31d0f86b87a55d895c4"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/8bf5b869e5840fc5564e01f62bdbabc8b8ffcab2",
          "sha": "8bf5b869e5840fc5564e01f62bdbabc8b8ffcab2",
          "html_url": "https://github.com/bitcoin/bips/commit/8bf5b869e5840fc5564e01f62bdbabc8b8ffcab2"
        }
      ],
      "message": "Be explicit about tapleaf version forwarding",
      "committer": {
        "name": "Greg Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2023-03-28T16:42:48Z"
      },
      "author": {
        "name": "Greg Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2023-03-28T16:42:48Z"
      },
      "sha": "29345a10f0e991e8f223beb9a92984e767911ac2"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDBiMDY3NGM1NDZlYmEwNzU4M2RhODdkMDI5ZjQyYTVkYTU1MWFmNDI",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/0b0674c546eba07583da87d029f42a5da551af42",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/0b0674c546eba07583da87d029f42a5da551af42",
      "tree": {
        "sha": "10b1ae30e61de520141b888e17c5f3ed450041cd",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/10b1ae30e61de520141b888e17c5f3ed450041cd"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/29345a10f0e991e8f223beb9a92984e767911ac2",
          "sha": "29345a10f0e991e8f223beb9a92984e767911ac2",
          "html_url": "https://github.com/bitcoin/bips/commit/29345a10f0e991e8f223beb9a92984e767911ac2"
        }
      ],
      "message": "few fixups",
      "committer": {
        "name": "Greg Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2023-03-28T19:08:03Z"
      },
      "author": {
        "name": "Greg Sanders",
        "email": "gsanders87@gmail.com",
        "date": "2023-03-28T19:08:03Z"
      },
      "sha": "0b0674c546eba07583da87d029f42a5da551af42"
    },
    {
      "event": "reviewed",
      "id": 1362273369,
      "node_id": "PRR_kwDOAN28mc5RMqRZ",
      "url": null,
      "actor": null,
      "commit_id": "0b0674c546eba07583da87d029f42a5da551af42",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "19861826",
        "id": 124975449,
        "node_id": "U_kgDOB3L5WQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/124975449?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/19861826",
        "html_url": "https://github.com/19861826",
        "followers_url": "https://api.github.com/users/19861826/followers",
        "following_url": "https://api.github.com/users/19861826/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/19861826/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/19861826/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/19861826/subscriptions",
        "organizations_url": "https://api.github.com/users/19861826/orgs",
        "repos_url": "https://api.github.com/users/19861826/repos",
        "events_url": "https://api.github.com/users/19861826/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/19861826/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1362273369",
      "submitted_at": "2023-03-29T05:25:38Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "reviewed",
      "id": 1362275728,
      "node_id": "PRR_kwDOAN28mc5RMq2Q",
      "url": null,
      "actor": null,
      "commit_id": "0b0674c546eba07583da87d029f42a5da551af42",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "19861826",
        "id": 124975449,
        "node_id": "U_kgDOB3L5WQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/124975449?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/19861826",
        "html_url": "https://github.com/19861826",
        "followers_url": "https://api.github.com/users/19861826/followers",
        "following_url": "https://api.github.com/users/19861826/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/19861826/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/19861826/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/19861826/subscriptions",
        "organizations_url": "https://api.github.com/users/19861826/orgs",
        "repos_url": "https://api.github.com/users/19861826/repos",
        "events_url": "https://api.github.com/users/19861826/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/19861826/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1362275728",
      "submitted_at": "2023-03-29T05:28:26Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "reviewed",
      "id": 1363221045,
      "node_id": "PRR_kwDOAN28mc5RQRo1",
      "url": null,
      "actor": null,
      "commit_id": "0b0674c546eba07583da87d029f42a5da551af42",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1363221045",
      "submitted_at": "2023-03-29T14:13:37Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "reviewed",
      "id": 1386289238,
      "node_id": "PRR_kwDOAN28mc5SoRhW",
      "url": null,
      "actor": null,
      "commit_id": "0b0674c546eba07583da87d029f42a5da551af42",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1386289238",
      "submitted_at": "2023-04-15T01:46:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDcxMTJmMzA4YjM1NmNkZjBjNTFkOTE3ZGJkYzFiOThlMzA2MjFmODA",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/7112f308b356cdf0c51d917dbdc1b98e30621f80",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/7112f308b356cdf0c51d917dbdc1b98e30621f80",
      "tree": {
        "sha": "15ce975c01c65d8f9a14a2836d2b3f57c00e327c",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/15ce975c01c65d8f9a14a2836d2b3f57c00e327c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/0b0674c546eba07583da87d029f42a5da551af42",
          "sha": "0b0674c546eba07583da87d029f42a5da551af42",
          "html_url": "https://github.com/bitcoin/bips/commit/0b0674c546eba07583da87d029f42a5da551af42"
        }
      ],
      "message": "minor wording updates",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-04-17T13:40:57Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-04-17T13:40:57Z"
      },
      "sha": "7112f308b356cdf0c51d917dbdc1b98e30621f80"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-18T03:59:03Z",
      "updated_at": "2023-04-18T03:59:03Z",
      "source": {
        "issue": {
          "id": 1672306902,
          "node_id": "I_kwDOH9QDkc5jrWDW",
          "url": "https://api.github.com/repos/ariard/bitcoin-contracting-primitives-wg/issues/39",
          "repository_url": "https://api.github.com/repos/ariard/bitcoin-contracting-primitives-wg",
          "labels_url": "https://api.github.com/repos/ariard/bitcoin-contracting-primitives-wg/issues/39/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/ariard/bitcoin-contracting-primitives-wg/issues/39/comments",
          "events_url": "https://api.github.com/repos/ariard/bitcoin-contracting-primitives-wg/issues/39/events",
          "html_url": "https://github.com/ariard/bitcoin-contracting-primitives-wg/issues/39",
          "number": 39,
          "state": "closed",
          "state_reason": "completed",
          "title": "Contracting Primitives WG Session 2023/04/18",
          "body": "The meeting will take place on Tuesday 2023/04/18 (the third Tuesday of the month) at 6:00 pm UTC on Libera Chat IRC #bitcoin-contracting-primitives-wg.\r\n\r\n# Primitives Seeking Review\r\n\r\nThis section contains contracting primitives and protocols waiting reviews.\r\n\r\n- [ ] [BIP 118 - SIGHASH_ANYPREVOUT](https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki)\r\n- [ ] [BIP 345 - OP_VAULT](https://github.com/bitcoin/bips/pull/1421)\r\n\r\n# Use-Cases Seeking Review\r\n\r\n- [ ] [vault protocol](https://jameso.be/vaults.pdf)\r\n- [ ] [Eltoo channels](https://github.com/users/instagibbs/projects/1/views/1)\r\n- [ ] [payments pools](https://coinpool.dev/v0.1.pdf)/[channel factories](https://github.com/JohnLaw2/ln-efficient-factories)\r\n\r\nFeel free to comment to add any subject you would like to be discussed during this upcoming meeting as format is \"freewheel\". ",
          "user": {
            "login": "ariard",
            "id": 23310655,
            "node_id": "MDQ6VXNlcjIzMzEwNjU1",
            "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/ariard",
            "html_url": "https://github.com/ariard",
            "followers_url": "https://api.github.com/users/ariard/followers",
            "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
            "organizations_url": "https://api.github.com/users/ariard/orgs",
            "repos_url": "https://api.github.com/users/ariard/repos",
            "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/ariard/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "OWNER",
          "locked": false,
          "comments": 0,
          "closed_at": "2023-05-01T17:52:22Z",
          "created_at": "2023-04-18T03:59:03Z",
          "updated_at": "2023-05-01T17:52:22Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1515337355,
      "node_id": "IC_kwDOAN28mc5aUjaL",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1515337355",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-19T20:28:22Z",
      "updated_at": "2023-04-19T20:28:22Z",
      "author_association": "MEMBER",
      "body": "Content here no longer in flux. Spec review is welcome!",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1515337355",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "commented",
      "id": 1517818084,
      "node_id": "IC_kwDOAN28mc5aeBDk",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1517818084",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-21T13:12:41Z",
      "updated_at": "2023-04-21T13:12:41Z",
      "author_association": "MEMBER",
      "body": "Interesting proposal. The writeup is very clear, thanks for that.\r\n\r\nYou recommend to use `CTV` in order to commit to the withdrawal transaction that should eventually be used. But the transaction hash is unauthenticated since it is passed in the witness. This means anyone on the network (most likely a miner) can change the committed withdrawal transaction at trigger time.\r\nNow, sure, you still got the recovery mechanism. But:\r\n- I think the value of this proposal is that it can be thought of as defense in depth, as in it's only \"additional security\": if your watchtower(s) fail you your security level falls back to what it was without using the vault. But since the withdrawal transaction commitment can be replaced by anyone, it's actually not: if your watchtower(s) fail you and a miner put their own withdrawal transaction when mining your trigger, it's game over.\r\n- Even if you assume your watchtower won't fail you (i don't think it is reasonable), it's just a very trivial DOS anybody can perform at no cost. And it gets worse since you probably want to recover all your coins if you trigger recovery on one of them?\r\n\r\nMaybe this could be fixed by using an `ANYPREVOUT | ANYSCRIPT` signature to commit to the withdrawal instead? It's a bit more malleable, but at least it's authenticated.\r\nIt does not get rid of all the complexity though. You want the private key that will sign using `APOAS` the withdrawal transaction to live on the signing device (and have the user verify its outputs there), otherwise it's again a degradation in security: access to the hot laptop + failing watchtowers allows to steal.",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1517818084",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "commented",
      "id": 1517829515,
      "node_id": "IC_kwDOAN28mc5aeD2L",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1517829515",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-21T13:23:03Z",
      "updated_at": "2023-04-21T13:23:03Z",
      "author_association": "MEMBER",
      "body": "> You recommend to use CTV in order to commit to the withdrawal transaction that should eventually be used. But the transaction hash is unauthenticated since it is passed in the witness. This means anyone on the network (most likely a miner) can change the committed withdrawal transaction at trigger time.\r\n\r\nThis is not the case. Recall that the CTV hash is committed to in the trigger output tapleaf, so if an observer changes the CTV hash given in the witness, making it mismatch the one given in the trigger output, the spend will be invalid.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1517829515",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "commented",
      "id": 1517836473,
      "node_id": "IC_kwDOAN28mc5aeFi5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1517836473",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-21T13:28:56Z",
      "updated_at": "2023-04-21T13:28:56Z",
      "author_association": "MEMBER",
      "body": "Right, note that you *could* construct a vault with no trigger authentication easily, it just seems unwise to me. But that's up to the end wallet developer.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1517836473",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "commented",
      "id": 1519054258,
      "node_id": "IC_kwDOAN28mc5aiu2y",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1519054258",
      "actor": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-23T12:19:30Z",
      "updated_at": "2023-04-23T12:19:30Z",
      "author_association": "CONTRIBUTOR",
      "body": "I still think @vostrnad's [comment](https://github.com/bitcoin/bips/pull/1421#discussion_r1110810372) hasn't fully been addressed on keeping proposed changes to default policy out of this BIP (a consensus change proposal) and referencing separate BIPs/draft BIPs on proposed default policy changes where necessary. If they don't yet exist then perhaps a  temporary statement that you're waiting on new BIP(s) outlining these changes. In the extreme case that other default policy BIPs don't cover the changes needed for this proposal a new BIP can be drafted in parallel with this one. This might seem overly finicky but I'd like to see policy prerequisites for this proposal hammered out in the V3 discussion and ideally implemented and active prior to considering any consensus change activation attempt on mainnet for this. I'm not sure what others' views on this are but I think the consensus change activation attempt should be the very last step.\r\n\r\n> Originally, this proposal had a hard dependency on reformed transaction\r\nnVersion=3 policies, including ephemeral anchors, but it has since been revised\r\nto simply benefit from these changes in policy as well as other potential fee\r\nmanagement mechanisms.\r\n\r\nI'm not sure what this means. There is no longer a hard dependency on V3? Or there is still a hard dependency on V3 but the relevant parts of V3 haven't been included in this BIP? Would you recommend OP_VAULT be used if V3 was never implemented or does it require V3 before you would give that recommendation?",
      "user": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1519054258",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "mentioned",
      "id": 9074818060,
      "node_id": "MEE_lADOAN28mc5eW19HzwAAAAIc5rwM",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9074818060",
      "actor": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-23T12:19:30Z"
    },
    {
      "event": "subscribed",
      "id": 9074818063,
      "node_id": "SE_lADOAN28mc5eW19HzwAAAAIc5rwP",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9074818063",
      "actor": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-23T12:19:30Z"
    },
    {
      "event": "reviewed",
      "id": 1418554476,
      "node_id": "PRR_kwDOAN28mc5UjWxs",
      "url": null,
      "actor": null,
      "commit_id": "7112f308b356cdf0c51d917dbdc1b98e30621f80",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "Bigdoe41",
        "id": 123813335,
        "node_id": "U_kgDOB2E91w",
        "avatar_url": "https://avatars.githubusercontent.com/u/123813335?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Bigdoe41",
        "html_url": "https://github.com/Bigdoe41",
        "followers_url": "https://api.github.com/users/Bigdoe41/followers",
        "following_url": "https://api.github.com/users/Bigdoe41/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Bigdoe41/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Bigdoe41/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Bigdoe41/subscriptions",
        "organizations_url": "https://api.github.com/users/Bigdoe41/orgs",
        "repos_url": "https://api.github.com/users/Bigdoe41/repos",
        "events_url": "https://api.github.com/users/Bigdoe41/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Bigdoe41/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1418554476",
      "submitted_at": "2023-05-09T12:50:36Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9666666778,
      "node_id": "HRFPE_lADOAN28mc5eW19HzwAAAAJALaEa",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9666666778",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-06-28T16:03:18Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGNiNTA0NDZhNjVjYjg1MDQ0OTllMWViZGVkMjI1MzkxODg2MTJiYjM",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/cb50446a65cb8504499e1ebded22539188612bb3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/cb50446a65cb8504499e1ebded22539188612bb3",
      "tree": {
        "sha": "b7c678d19f0e3f752ef0b5f7f587f2f64d8dbb26",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/b7c678d19f0e3f752ef0b5f7f587f2f64d8dbb26"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/7112f308b356cdf0c51d917dbdc1b98e30621f80",
          "sha": "7112f308b356cdf0c51d917dbdc1b98e30621f80",
          "html_url": "https://github.com/bitcoin/bips/commit/7112f308b356cdf0c51d917dbdc1b98e30621f80"
        }
      ],
      "message": "fixup! add <revault-amount> and clarify deferred checks\n\nThis change makes the amount being revaulted (if any) explicit to avoid\nissues surfaced by AJ Towns (e.g. multiple compatible vault inputs\nduplicating triggers and revaults to confuse the old deferred check\nlogic).\n\nPseudocode is also provided for the deferred checks, and their inline\nvalidation description has been changed to be more faithful to the\nimplementation - we make mention of queueing deferred checks, and then\nlater describe the algorithm used to aggregate and perform them.",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-06-28T16:03:58Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-06-14T20:36:43Z"
      },
      "sha": "cb50446a65cb8504499e1ebded22539188612bb3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGUyZmYyM2IzZjA3MjE1NDUwZTc1Nzc5ZjdmOTQ0ZDI0NjYwYTlkNDc",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/e2ff23b3f07215450e75779f7f944d24660a9d47",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/e2ff23b3f07215450e75779f7f944d24660a9d47",
      "tree": {
        "sha": "96345a7f6735bae2b91e1f41614da7b90df5749a",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/96345a7f6735bae2b91e1f41614da7b90df5749a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/cb50446a65cb8504499e1ebded22539188612bb3",
          "sha": "cb50446a65cb8504499e1ebded22539188612bb3",
          "html_url": "https://github.com/bitcoin/bips/commit/cb50446a65cb8504499e1ebded22539188612bb3"
        }
      ],
      "message": "fiuxp! allow larger trigger/recovery output amounts\n\nAllow trigger/recovery output nValues to exceed the amounts supplied by\nconstituent vault inputs. This allows future compatibility for e.g.\ntrigger collateral.",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-06-28T16:06:35Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-06-28T16:06:35Z"
      },
      "sha": "e2ff23b3f07215450e75779f7f944d24660a9d47"
    },
    {
      "event": "commented",
      "id": 1655712335,
      "node_id": "IC_kwDOAN28mc5isCpP",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1655712335",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-28T13:46:41Z",
      "updated_at": "2023-07-28T13:46:41Z",
      "author_association": "MEMBER",
      "body": "I think this might be ready for fixup/merge. Is there any outstanding feedback to address?",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1655712335",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "commented",
      "id": 1655917349,
      "node_id": "IC_kwDOAN28mc5is0sl",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1655917349",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-28T15:52:12Z",
      "updated_at": "2023-07-28T15:52:12Z",
      "author_association": "MEMBER",
      "body": "> If they don't yet exist then perhaps a temporary statement that you're waiting on new BIP(s) outlining these changes. \r\n\r\nUnless we have a hard and fast rule about consensus and policy changes living in disparate BIPs, I actually don't think a separate BIP necessary to outline the proposed policy changes here. The policy changes outlined in this BIP are fairly minimal, and fragmenting them over to a separate BIP seems unnecessary.\r\n\r\nI've always found the timelock BIPs (BIP-65, -68, -112, -113) cumbersome to reread because of what feels like unnecessary fragmentation - I can never remember what is in which BIP.\r\n\r\n> There is no longer a hard dependency on V3?\r\n\r\nThere is not. \r\n\r\n> Would you recommend OP_VAULT be used if V3 was never implemented or does it require V3 before you would give that recommendation?\r\n\r\nOP_VAULT is practically usable today without V3 transactions provided it's used with authenticated recovery, which allows unrelated inputs and outputs to be mixed into vault operations for fee management. I'll remove mention of V3 in the BIP text for clarity.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1655917349",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "commented",
      "id": 1655930505,
      "node_id": "IC_kwDOAN28mc5is36J",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1655930505",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-28T15:58:04Z",
      "updated_at": "2023-07-28T15:58:04Z",
      "author_association": "MEMBER",
      "body": "I lean towards just removing all policy carveouts, since it's secure as-is with authentication at each step, and future mempool updates make make unauthenticated recovery paths safe as well. ",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1655930505",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-31T17:34:37Z",
      "updated_at": "2023-07-31T17:34:37Z",
      "source": {
        "issue": {
          "id": 1827113829,
          "node_id": "PR_kwDOAN28mc5WsRh2",
          "url": "https://api.github.com/repos/bitcoin/bips/issues/1482",
          "repository_url": "https://api.github.com/repos/bitcoin/bips",
          "labels_url": "https://api.github.com/repos/bitcoin/bips/issues/1482/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1482/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bips/issues/1482/events",
          "html_url": "https://github.com/bitcoin/bips/pull/1482",
          "number": 1482,
          "state": "closed",
          "state_reason": null,
          "title": "Add James O'Beirne to 119 Author List",
          "body": "I'd like to propose that James O'Beirne be added as an author to BIP-119. James has done extensive research on covenants, including 119, and is actively involved in Bitcoin Development. Since I am no longer actively involved in Development, adding James as an author will give the the BIP an active steward for any changes required going forward.",
          "user": {
            "login": "JeremyRubin",
            "id": 886523,
            "node_id": "MDQ6VXNlcjg4NjUyMw==",
            "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/JeremyRubin",
            "html_url": "https://github.com/JeremyRubin",
            "followers_url": "https://api.github.com/users/JeremyRubin/followers",
            "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
            "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
            "repos_url": "https://api.github.com/users/JeremyRubin/repos",
            "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 5,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bips/pulls/1482",
            "html_url": "https://github.com/bitcoin/bips/pull/1482",
            "diff_url": "https://github.com/bitcoin/bips/pull/1482.diff",
            "patch_url": "https://github.com/bitcoin/bips/pull/1482.patch"
          },
          "closed_at": "2023-08-16T13:49:21Z",
          "created_at": "2023-07-28T21:37:25Z",
          "updated_at": "2023-08-16T13:49:22Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1605919360,
      "node_id": "PRR_kwDOAN28mc5fuGKA",
      "url": null,
      "actor": null,
      "commit_id": "e2ff23b3f07215450e75779f7f944d24660a9d47",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1605919360",
      "submitted_at": "2023-09-01T01:57:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "reviewed",
      "id": 1606026327,
      "node_id": "PRR_kwDOAN28mc5fugRX",
      "url": null,
      "actor": null,
      "commit_id": "e2ff23b3f07215450e75779f7f944d24660a9d47",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "Thank you. Apparently I can't multi task when coding ",
      "user": {
        "login": "Axxel2323",
        "id": 140521154,
        "node_id": "U_kgDOCGAuwg",
        "avatar_url": "https://avatars.githubusercontent.com/u/140521154?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Axxel2323",
        "html_url": "https://github.com/Axxel2323",
        "followers_url": "https://api.github.com/users/Axxel2323/followers",
        "following_url": "https://api.github.com/users/Axxel2323/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Axxel2323/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Axxel2323/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Axxel2323/subscriptions",
        "organizations_url": "https://api.github.com/users/Axxel2323/orgs",
        "repos_url": "https://api.github.com/users/Axxel2323/repos",
        "events_url": "https://api.github.com/users/Axxel2323/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Axxel2323/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1606026327",
      "submitted_at": "2023-09-01T02:06:22Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDRhYWU3MjZiZTk2MTBhNjc1YjM2MmU2NmY1MzljZTBkNWY5MDNhNWY",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/4aae726be9610a675b362e66f539ce0d5f903a5f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/4aae726be9610a675b362e66f539ce0d5f903a5f",
      "tree": {
        "sha": "9ec9d655d8f39e7ee5c494eafc02cbf154000804",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/9ec9d655d8f39e7ee5c494eafc02cbf154000804"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/e2ff23b3f07215450e75779f7f944d24660a9d47",
          "sha": "e2ff23b3f07215450e75779f7f944d24660a9d47",
          "html_url": "https://github.com/bitcoin/bips/commit/e2ff23b3f07215450e75779f7f944d24660a9d47"
        }
      ],
      "message": "fixup! fix off-by-one and revault-idx malleability\n\nCo-authored-by: sanket1729 <sanket1729@gmail.com>",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-09-01T14:12:38Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-09-01T14:12:38Z"
      },
      "sha": "4aae726be9610a675b362e66f539ce0d5f903a5f"
    },
    {
      "event": "commented",
      "id": 1706720409,
      "node_id": "IC_kwDOAN28mc5lunyZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1706720409",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T14:21:36Z",
      "updated_at": "2023-09-05T14:21:36Z",
      "author_association": "MEMBER",
      "body": "Given that this spec requires an ec mult, I think each OP_VAULT invocation should be counted in the sigops budget in taproot? Lack of batch validation possibility is also a bit of a downer, maybe recost it in light of that?",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1706720409",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "commented",
      "id": 1706848717,
      "node_id": "IC_kwDOAN28mc5lvHHN",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1706848717",
      "actor": {
        "login": "ChrisMartl",
        "id": 125733092,
        "node_id": "U_kgDOB36I5A",
        "avatar_url": "https://avatars.githubusercontent.com/u/125733092?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ChrisMartl",
        "html_url": "https://github.com/ChrisMartl",
        "followers_url": "https://api.github.com/users/ChrisMartl/followers",
        "following_url": "https://api.github.com/users/ChrisMartl/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ChrisMartl/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ChrisMartl/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ChrisMartl/subscriptions",
        "organizations_url": "https://api.github.com/users/ChrisMartl/orgs",
        "repos_url": "https://api.github.com/users/ChrisMartl/repos",
        "events_url": "https://api.github.com/users/ChrisMartl/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ChrisMartl/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T15:33:20Z",
      "updated_at": "2023-09-05T15:33:20Z",
      "author_association": "NONE",
      "body": "@jamesob \r\nCould you please provide an analysis statement, which effects or how this proposal could increment the exploit exposure for the Bitcoin system due to the loose flexibility of Bitcoin’s script (predicative processing)?\r\n\r\nBitcoin has this predicate issue (since genesis) and it is necessary to perform a risk analysis about this for every proposed change.",
      "user": {
        "login": "ChrisMartl",
        "id": 125733092,
        "node_id": "U_kgDOB36I5A",
        "avatar_url": "https://avatars.githubusercontent.com/u/125733092?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ChrisMartl",
        "html_url": "https://github.com/ChrisMartl",
        "followers_url": "https://api.github.com/users/ChrisMartl/followers",
        "following_url": "https://api.github.com/users/ChrisMartl/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ChrisMartl/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ChrisMartl/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ChrisMartl/subscriptions",
        "organizations_url": "https://api.github.com/users/ChrisMartl/orgs",
        "repos_url": "https://api.github.com/users/ChrisMartl/repos",
        "events_url": "https://api.github.com/users/ChrisMartl/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ChrisMartl/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1706848717",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "mentioned",
      "id": 10285263629,
      "node_id": "MEE_lADOAN28mc5eW19HzwAAAAJlDKsN",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10285263629",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T15:33:20Z"
    },
    {
      "event": "subscribed",
      "id": 10285263651,
      "node_id": "SE_lADOAN28mc5eW19HzwAAAAJlDKsj",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10285263651",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-05T15:33:20Z"
    },
    {
      "event": "commented",
      "id": 1714731304,
      "node_id": "IC_kwDOAN28mc5mNLko",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1714731304",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T23:21:37Z",
      "updated_at": "2023-09-11T23:21:37Z",
      "author_association": "CONTRIBUTOR",
      "body": "@instagibbs, agreed. The costing seems to be an important missing component in the BIP. Rereading BIP341, footnote 12, I don't think that batch validation was considered while costing the 50 execution budget for CHECKSIG. \r\n\r\nI think that having a fixed (50 ?) execution budget for this also makes sense. Note that this operation also consists hashing potentially 127*32 bytes (maximum length of control block). \r\n\r\n1) One option is to cost this dynamically we can cost this operation dynamically based on control block size. I don't like this because we introduce more complexity with this. \r\n2) Another option is to argue that this is similar to checksig operator which already does a similar computation for sighash value. And this is no different than it. However, sighash values are cached, but we cannot thing being hashed here. If we argue it this way, we can keep a simple 50 cost rule. For most (useful) cases, The stack would consist of \r\n```md\r\n                    // Stack: Example for CTV vault\r\n                    //  - <flu-script>   -------  3 bytes \r\n                    //  - <n-pushes>  ------- 1 byte\r\n                    //  [ n items ... ]   ------- 2 items: 1 + 32\r\n                    //  - <trigger-vout-idx> --- min 1 byte \r\n                    //  - <revault-vout-idx> --- min 1 byte\r\n                    //  - <revault-amount> ---- min 1 byte\r\n```\r\n total cost per OP_VAULT = 3 + 1 + (1 + 32) + 1 + 1 + 1 + = 41 bytes + 7 (one per each element for varint len prefix) + 1(op_vault itself) = 49 bytes. Or 50 bytes if people want to withdraw more than 127 sats(1 byte CScriptNum). \r\n \r\nAllocating 50 budget is also good because people don't need any sort of witness stuffing of any sort to make sure of multiple op_vault in a same transaction input. And this is also consistent with signature costing model. Normal sighash hashes computation takes about 300 bytes (assuming pre-computed data), but a tree with depth 128 would do a hash of 4kb and a ec tweak operation. \r\n\r\nI don't think this is a big cost as compared to schnorr signature verification, but this should be benchmarked to make sure that this is within the same ballpark. \r\n1) Regular checksig operation that calls schnorrsigverify.\r\n2) A max length control block with CTV vault operation.\r\n\r\nAnother point to note is that this operation is similar to signing, not verification. I would expect this is benchmark to be faster than checksig verification because we have access to precomputed G values. So, there is even an argument to cost this at a smaller budget(25?) instead of 50. \r\n\r\n###  Summary\r\n\r\nTo recap my opinion,\r\n\r\na) There should be some cost. We should avoid a potential dos vector where an user can dup all input elements and call op_vault multiple times.\r\nb) Having a fixed cost is easy to implement and reason about instead of a dynamic cost based on control block size. The cost is dominated by formula `cost_hashing(control_block_len) + cost_x_only_add`. \r\nc) Verify that the cost is dominated by cost_x_only_add for max control block size(128 * 32) and compute a cost number by comparing this cost with checksigschnorr in tapscript. \r\nd) Verify that common use-cases don't have to any sort of witness stuffing to make them useful.  ",
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1714731304",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "mentioned",
      "id": 10339803447,
      "node_id": "MEE_lADOAN28mc5eW19HzwAAAAJoTOE3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10339803447",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T23:21:37Z"
    },
    {
      "event": "subscribed",
      "id": 10339803453,
      "node_id": "SE_lADOAN28mc5eW19HzwAAAAJoTOE9",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10339803453",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-11T23:21:37Z"
    },
    {
      "event": "commented",
      "id": 1715647622,
      "node_id": "IC_kwDOAN28mc5mQrSG",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1715647622",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-12T12:39:43Z",
      "updated_at": "2023-09-12T12:39:43Z",
      "author_association": "MEMBER",
      "body": "> d) Verify that common use-cases don't have to any sort of witness stuffing to make them useful.\r\n\r\nThe only use-cases I've seen involve 1 or 2 invocations, with the second invocation often being the same destination which would allow caching",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1715647622",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "commented",
      "id": 1715776940,
      "node_id": "IC_kwDOAN28mc5mRK2s",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1715776940",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-12T13:55:53Z",
      "updated_at": "2023-09-12T13:56:05Z",
      "author_association": "MEMBER",
      "body": "> The costing seems to be an important missing component in the BIP.\r\n\r\nThanks for the analysis, @sanket1729. Indeed this is an important part of the proposal that I'd missed.\r\n\r\n> I think that having a fixed (50 ?) execution budget for this also makes sense.\r\n\r\nI agree. As Greg noted, most uses of OP_VAULT should be a single evaluation per input - there's really no reason to do more aside from a speculative use ([collateral lockup](https://github.com/jamesob/bips/pull/4)) that would require other changes (i.e. reworking OP_VAULT to leave residual revault CAmount on the stack).\r\n\r\nSo I am comfortable \"overcosting\" OP_VAULT, since I think any use beyond a single invocation per input is worthless, at least as written right now. My only concern would be (as you mention) providing enough headroom so that the common use (OP_VAULT gated by a CHECKSIG) doesn't require witness stuffing (i.e. inflating the witness unnaturally to add the necessary sigops budget, since budget is determined by input witness length in [BIP-342](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#resource-limits)).\r\n\r\nI agree with everyone else that a static cost is the way to go for simplicity's sake.\r\n\r\nBut if as you say the marginal witness data for the OP_VAULT stack in this usage is at or above 50 bytes, then I think we should be okay costing OP_VAULT at 50 and still leaving enough headroom for a CHECKSIG beforehand.\r\n\r\n> I don't think this is a big cost as compared to schnorr signature verification, but this should be benchmarked to make sure that this is within the same ballpark.\r\n\r\nI suspect that the EC mult to verify the output taptweak will dominate all the hashing (and be less expensive than a Schnorr verification) but I will work on writing this benchmark.\r\n\r\nIt is also worth noting that there cannot be different valid OP_VAULT invocations (in terms of hash/taptweak check) for the same output, so I think that limits the DoSability a good deal. In other words, a lot is cachable or limited by output size.\r\n\r\nYou could maybe play games by varying the revault parameters, but the hashing/taptweaking will be the same, since varying revault only changes the deferred amount checks that are queued in the case of successful input evaluation.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1715776940",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "mentioned",
      "id": 10347292343,
      "node_id": "MEE_lADOAN28mc5eW19HzwAAAAJovya3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10347292343",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-12T13:55:53Z"
    },
    {
      "event": "subscribed",
      "id": 10347292363,
      "node_id": "SE_lADOAN28mc5eW19HzwAAAAJovybL",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10347292363",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-12T13:55:53Z"
    },
    {
      "event": "reviewed",
      "id": 1625440098,
      "node_id": "PRR_kwDOAN28mc5g4j9i",
      "url": null,
      "actor": null,
      "commit_id": "4aae726be9610a675b362e66f539ce0d5f903a5f",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "twhit223",
        "id": 6600711,
        "node_id": "MDQ6VXNlcjY2MDA3MTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6600711?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/twhit223",
        "html_url": "https://github.com/twhit223",
        "followers_url": "https://api.github.com/users/twhit223/followers",
        "following_url": "https://api.github.com/users/twhit223/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/twhit223/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/twhit223/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/twhit223/subscriptions",
        "organizations_url": "https://api.github.com/users/twhit223/orgs",
        "repos_url": "https://api.github.com/users/twhit223/repos",
        "events_url": "https://api.github.com/users/twhit223/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/twhit223/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1625440098",
      "submitted_at": "2023-09-13T20:56:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "reviewed",
      "id": 1625445582,
      "node_id": "PRR_kwDOAN28mc5g4lTO",
      "url": null,
      "actor": null,
      "commit_id": "4aae726be9610a675b362e66f539ce0d5f903a5f",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "twhit223",
        "id": 6600711,
        "node_id": "MDQ6VXNlcjY2MDA3MTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6600711?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/twhit223",
        "html_url": "https://github.com/twhit223",
        "followers_url": "https://api.github.com/users/twhit223/followers",
        "following_url": "https://api.github.com/users/twhit223/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/twhit223/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/twhit223/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/twhit223/subscriptions",
        "organizations_url": "https://api.github.com/users/twhit223/orgs",
        "repos_url": "https://api.github.com/users/twhit223/repos",
        "events_url": "https://api.github.com/users/twhit223/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/twhit223/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1625445582",
      "submitted_at": "2023-09-13T21:00:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "reviewed",
      "id": 1625471528,
      "node_id": "PRR_kwDOAN28mc5g4roo",
      "url": null,
      "actor": null,
      "commit_id": "4aae726be9610a675b362e66f539ce0d5f903a5f",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "twhit223",
        "id": 6600711,
        "node_id": "MDQ6VXNlcjY2MDA3MTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6600711?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/twhit223",
        "html_url": "https://github.com/twhit223",
        "followers_url": "https://api.github.com/users/twhit223/followers",
        "following_url": "https://api.github.com/users/twhit223/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/twhit223/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/twhit223/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/twhit223/subscriptions",
        "organizations_url": "https://api.github.com/users/twhit223/orgs",
        "repos_url": "https://api.github.com/users/twhit223/repos",
        "events_url": "https://api.github.com/users/twhit223/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/twhit223/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1625471528",
      "submitted_at": "2023-09-13T21:22:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "commented",
      "id": 1731746343,
      "node_id": "IC_kwDOAN28mc5nOFon",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1731746343",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-22T16:58:39Z",
      "updated_at": "2023-09-22T17:00:52Z",
      "author_association": "MEMBER",
      "body": "@sanket1729 @instagibbs \r\n\r\nReporting back on costing.\r\n\r\nI've written a benchmark (https://github.com/bitcoin-inquisition/bitcoin/pull/21/commits/dcf14426971908f7fbdcd06b3f884d4232fac8da) that simulates the relative cost of an OP_VAULT invocation vs. a successful Schnorr verification, and I was surprised to find that the taptweak check (including the necessary hashing) with a max-length control block is actually about as expensive as a good Schnorr verification; in fact, it's about 5% slower!\r\n\r\n| relative |           ns/verify |            verify/s |    err% |      ins/verify |     bra/verify |   miss% |     total | benchmark\r\n|---------:|--------------------:|--------------------:|--------:|----------------:|---------------:|--------:|----------:|:----------\r\n|   100.0% |           39,301.34 |           25,444.43 |    0.1% |      419,357.03 |      13,067.01 |    0.0% |      0.54 | `opvault-tweak`\r\n|   883.6% |            4,447.92 |          224,824.24 |    0.0% |       41,841.00 |         242.00 |    0.0% |      0.54 | `schnorr-bad-verify`\r\n|   106.4% |           36,938.11 |           27,072.31 |    0.1% |      405,222.03 |       3,905.01 |    0.0% |      0.53 | `schnorr-good-verify`\r\n\r\nI did some profiling and generated a flamegraph ([full interactive graph here](http://img.jameso.be/2023/opvault-bench-flamegraph.svg)); perhaps as expected, most time is spent on the secp256k tweak_add operation, but I was surprised that a substantial amount of time is spent on `ComputeTapbranchHash`. \r\n\r\n![image](https://github.com/bitcoin/bips/assets/73197/312a2431-4553-4c2e-8224-e57640463345)\r\n\r\nAs mentioned earlier, some of the midstate can probably be cached there. But to be conservative, I've costed OP_VAULT at 60 (vs. 50 for successful Schnorr verification) (https://github.com/bitcoin-inquisition/bitcoin/pull/21/commits/207b33e7912a19175b943f570efba8b837ae9eb7). I've verified that all existing testcases pass, and (given requisite [witness sizes](https://gist.github.com/jamesob/ad7e9b7096388eb0c8bfd34715bb87e9)) I have to bump the cost much higher to encounter any issues running out of budget during expected use.\r\n\r\nIf 60 sounds like a fine cost to everyone, I'll update the BIP. And then I think we're in okay shape to merge?",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1731746343",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "mentioned",
      "id": 10449502616,
      "node_id": "MEE_lADOAN28mc5eW19HzwAAAAJu1sGY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10449502616",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-22T16:58:40Z"
    },
    {
      "event": "subscribed",
      "id": 10449502623,
      "node_id": "SE_lADOAN28mc5eW19HzwAAAAJu1sGf",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10449502623",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-22T16:58:40Z"
    },
    {
      "event": "mentioned",
      "id": 10449502639,
      "node_id": "MEE_lADOAN28mc5eW19HzwAAAAJu1sGv",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10449502639",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-22T16:58:40Z"
    },
    {
      "event": "subscribed",
      "id": 10449502647,
      "node_id": "SE_lADOAN28mc5eW19HzwAAAAJu1sG3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10449502647",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-22T16:58:40Z"
    },
    {
      "event": "commented",
      "id": 1732416286,
      "node_id": "IC_kwDOAN28mc5nQpMe",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1732416286",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-23T21:48:19Z",
      "updated_at": "2023-09-23T21:48:19Z",
      "author_association": "CONTRIBUTOR",
      "body": "@jamesob, interesting. I spend some time digesting the numbers that you wrote. I have a small piece of rust code also produces the similar result. The performance is worse for me because I don't have AVX/sha-ni intrinsic. \r\n\r\nI am not informed enough to make this choice across different architectures with various CPU features, but at least for my somewhat old system it puts the number closer to 90/95. Given that \r\n1) prior budgeting of hash values was probably done with sha2 intrinsic machines, \r\n2) and most modern machines have sha-ni support, \r\nI am inclined to set a 60 limit to be consistent with the precedent. \r\n\r\n```\r\n| relative |           ns/verify |            verify/s |    err% |     total | benchmark\r\n|---------:|--------------------:|--------------------:|--------:|----------:|:----------\r\n|   100.0% |           93,845.36 |           10,655.83 |    4.4% |      0.01 | `opvault-tweak`\r\n| 1,711.3% |            5,483.97 |          182,349.53 |    1.8% |      0.01 | `schnorr-bad-verify`\r\n|   195.2% |           48,076.90 |           20,800.01 |    6.7% |      0.01 | :wavy_dash: `schnorr-good-verify` (Unstable with ~19.7 iters. Increase `minEpochIterations` to e.g. 197)\r\n```\r\n\r\nI also reproduced with similar results using rust-bitcoin software. https://github.com/sanket1729/rust-bitcoin/tree/vault_bench\r\n\r\n> If 60 sounds like a fine cost to everyone, I'll update the BIP. And then I think we're in okay shape to merge?\r\n\r\nIt sounds fine to me. I would be great if one of BIP342 authors provide more input on specific number. \r\n\r\nI think this is in okay shape to merge. Excited to play with this after this is merged in inquisition and might have more feedback based on it. ",
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1732416286",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "mentioned",
      "id": 10454083588,
      "node_id": "MEE_lADOAN28mc5eW19HzwAAAAJvHKgE",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10454083588",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-23T21:48:20Z"
    },
    {
      "event": "subscribed",
      "id": 10454083593,
      "node_id": "SE_lADOAN28mc5eW19HzwAAAAJvHKgJ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10454083593",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-23T21:48:20Z"
    },
    {
      "event": "commented",
      "id": 1732572523,
      "node_id": "IC_kwDOAN28mc5nRPVr",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1732572523",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-24T13:37:49Z",
      "updated_at": "2023-09-24T13:37:49Z",
      "author_association": "MEMBER",
      "body": "@sanket1729 for what it's worth, you can experiment with OP_VAULT pretty conveniently right now on regtest using this repo: https://github.com/jamesob/opvault-demo. I'm hoping it's very easy to set up if you've already got Docker installed on your machine.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1732572523",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "mentioned",
      "id": 10455250857,
      "node_id": "MEE_lADOAN28mc5eW19HzwAAAAJvLnep",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10455250857",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-24T13:37:49Z"
    },
    {
      "event": "subscribed",
      "id": 10455250863,
      "node_id": "SE_lADOAN28mc5eW19HzwAAAAJvLnev",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10455250863",
      "actor": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-24T13:37:49Z"
    },
    {
      "event": "commented",
      "id": 1732627907,
      "node_id": "IC_kwDOAN28mc5nRc3D",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1732627907",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-24T17:40:38Z",
      "updated_at": "2023-09-24T17:40:38Z",
      "author_association": "CONTRIBUTOR",
      "body": "> It sounds fine to me. I would be great if one of BIP342 authors provide more input on specific number.\r\n\r\nThe 50 figure mostly just matches the ratio between MAX_BLOCK_SIGOPS_COST and MAX_BLOCK_WEIGHT. When testing, it seemed that filling a block with the various possible slow opcodes all ended up with similar performance: 3,000,000 \"1000 OP_ROLL\"  took about 4.3s, a block full of \"OP_3DUP OP_HASH256 OP_DROP OP_HASH256 OP_DROP OP_HASH256\" took about 3.6s, and those were roughly the same as 80k checksigs. Obviously this varies across different hardware.",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1732627907",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "commented",
      "id": 1732645716,
      "node_id": "IC_kwDOAN28mc5nRhNU",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1732645716",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-24T19:04:51Z",
      "updated_at": "2023-09-24T19:04:51Z",
      "author_association": "MEMBER",
      "body": "Assuming the client caches each `OP_VAULT`'s computed p2tr outputs, I think this means that the worst would be that each invocation results in a different output script, which means they must pay for 34*4=136WU per invocation. An attack seems pretty self-limiting, as a single block can only contain ~23,250 p2tr outputs, excluding everything else.\r\n\r\nNot sure what number this results in exactly, but perhaps this is useful for analysis. ",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1732645716",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10511352388,
      "node_id": "HRFPE_lADOAN28mc5eW19HzwAAAAJyhoJE",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10511352388",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-29T13:18:02Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDAxNGI4MzJlMDdkM2JlM2M2YWZmMTIzMGQ1NjBmY2Y3MDMyZjA0OTU",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/014b832e07d3be3c6aff1230d560fcf7032f0495",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/014b832e07d3be3c6aff1230d560fcf7032f0495",
      "tree": {
        "sha": "7bf9b606791cb480125a9a81a816c04f4ff59212",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/7bf9b606791cb480125a9a81a816c04f4ff59212"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/4aae726be9610a675b362e66f539ce0d5f903a5f",
          "sha": "4aae726be9610a675b362e66f539ce0d5f903a5f",
          "html_url": "https://github.com/bitcoin/bips/commit/4aae726be9610a675b362e66f539ce0d5f903a5f"
        }
      ],
      "message": "BIP-345: add sigops cost of 60",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-09-29T13:19:15Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-09-29T13:17:32Z"
      },
      "sha": "014b832e07d3be3c6aff1230d560fcf7032f0495"
    },
    {
      "event": "commented",
      "id": 1740890308,
      "node_id": "IC_kwDOAN28mc5nw-DE",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1740890308",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-09-29T13:22:04Z",
      "updated_at": "2023-09-29T13:22:04Z",
      "author_association": "MEMBER",
      "body": "I've updated the BIP to give `OP_VAULT` a sigops cost of 60. Is there anything else we should wait for here before merging? ",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1740890308",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-10-01T20:38:48Z",
      "updated_at": "2023-10-01T20:38:48Z",
      "source": {
        "issue": {
          "id": 1920962660,
          "node_id": "I_kwDOKBf4ls5yf5Bk",
          "url": "https://api.github.com/repos/Merkleize/bitcoin/issues/2",
          "repository_url": "https://api.github.com/repos/Merkleize/bitcoin",
          "labels_url": "https://api.github.com/repos/Merkleize/bitcoin/issues/2/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/Merkleize/bitcoin/issues/2/comments",
          "events_url": "https://api.github.com/repos/Merkleize/bitcoin/issues/2/events",
          "html_url": "https://github.com/Merkleize/bitcoin/issues/2",
          "number": 2,
          "state": "closed",
          "state_reason": "completed",
          "title": "Implement `CTV_FLAG_DEDUCT_OUTPUT_AMOUNT`",
          "body": "Idea: add a new flag to the [current specs](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-July/021827.html) for `OP_CHECKCONTRACTVERIFY` used with outputs (so without `CCV_FLAG_CHECK_INPUT`):\r\n\r\nCurrently, there are only two possible behaviors defined for CCV for an output (that is, the when `CCV_FLAG_CHECK_INPUT` is not in the `flags`):\r\n\r\n- `CCV_FLAG_IGNORE_OUTPUT_AMOUNT`: no check on the amount\r\n- _default_: the output must account for the amount of the input; if multiple inputs have a CCV towards the same output (and without `CCV_FLAG_IGNORE_OUTPUT_AMOUNT`), the output' s amount must be at least equal to their sum\r\n\r\nWe can make the opcode more flexible by adding an additional flag: `CCV_DEDUCT_OUTPUT_AMOUNT = 4` (incompatible with `CCV_FLAG_IGNORE_OUTPUT_AMOUNT`).\r\n\r\nIf present, then:\r\n- the amount of the output must be no less than the amount of the input.\r\n- the amount is subtracted from the input amount, and the difference is used for deferred checks if future calls to `OP_CHECKCONTRACTVERIFY` are performed in the same script.\r\n\r\nTo be defined: should the deducted amount persist across inputs, or only stored during the current input's evaluation? It does not seem to matter for the use cases I have in mind (vaults and CoinPools unilateral exits), so it might suffice to keep the semantics simpler and per-input.\r\n\r\n## Vaults\r\n\r\n[OP_VAULT](https://github.com/bitcoin/bips/pull/1421) allows to instantly \"revault\" part of the input amounts, so that it is available for spending without waiting for the timelock. \r\n\r\nThe current vault implementation [here](https://github.com/bigspider/pymatt/blob/master/vault_contracts.py) does not support this feature.\r\n`CCV_DEDUCT_OUTPUT_AMOUNT` allows to implement this missing feature, allowing CCV-based vaults that are a drop-in replacement for OP_VAULT.\r\n\r\n```\r\n<0: skip data tweak>\r\n<revault_output_index>\r\n<-1: current internal key>\r\n<-1: current taptree>\r\n<CCV_DEDUCT_OUTPUT_AMOUNT> OP_CHECKCONTRACTVERIFY\r\n\r\n<ctv_hash (coming from the witness)>\r\n<unvaulting_output_index>\r\n<unvaulting_output_pubkey (or NUMS)>\r\n<unvaulting_output_taptree>\r\n<0: default flags> OP_CHECKCONTRACTVERIFY\r\n```\r\n\r\n## CoinPools\r\nIn protocols like [CoinPools](https://coinpool.dev/), it is necessary that a party is able to unilaterally withdraw from the pool, by subtracting their balance from the UTXO. `CCV_DEDUCT_OUTPUT_AMOUNT` would allow to support this use cases without worrying about 64-bit arithmetics in Script.",
          "user": {
            "login": "bigspider",
            "id": 6681844,
            "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bigspider",
            "html_url": "https://github.com/bigspider",
            "followers_url": "https://api.github.com/users/bigspider/followers",
            "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
            "organizations_url": "https://api.github.com/users/bigspider/orgs",
            "repos_url": "https://api.github.com/users/bigspider/repos",
            "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/bigspider/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 1,
          "closed_at": "2023-10-16T10:48:28Z",
          "created_at": "2023-10-01T20:38:47Z",
          "updated_at": "2023-10-16T10:48:29Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1657249307,
      "node_id": "PRR_kwDOAN28mc5ix54b",
      "url": null,
      "actor": null,
      "commit_id": "014b832e07d3be3c6aff1230d560fcf7032f0495",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1657249307",
      "submitted_at": "2023-10-04T10:55:25Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "reviewed",
      "id": 1657479607,
      "node_id": "PRR_kwDOAN28mc5iyyG3",
      "url": null,
      "actor": null,
      "commit_id": "014b832e07d3be3c6aff1230d560fcf7032f0495",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1657479607",
      "submitted_at": "2023-10-04T13:01:47Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-10-04T13:08:03Z",
      "updated_at": "2023-10-04T13:08:03Z",
      "source": {
        "issue": {
          "id": 1918077405,
          "node_id": "PR_kwDOABII585beW4M",
          "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28550",
          "repository_url": "https://api.github.com/repos/bitcoin/bitcoin",
          "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28550/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28550/comments",
          "events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/28550/events",
          "html_url": "https://github.com/bitcoin/bitcoin/pull/28550",
          "number": 28550,
          "state": "open",
          "state_reason": null,
          "title": "Covenant tools softfork",
          "body": "**Conceptual discussion here:** https://delvingbitcoin.org/t/covenant-tools-softfork/98\r\n\r\nThis draft is a patch that activates the consensus changes outlined in\r\n\r\n- [BIP-118](https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki) (SIGHASH_ANYPREVOUT for Taproot Scripts)\r\n- [BIP-119](https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki) (CHECKTEMPLATEVERIFY)\r\n- [BIP-345](https://github.com/jamesob/bips/blob/jamesob-23-02-opvault/bip-0345.mediawiki) (OP_VAULT)\r\n\r\nThese changes make possible a number of use-cases that are broadly beneficial to users of Bitcoin, including\r\n\r\n- [vaults](https://bitcoinops.org/en/topics/vaults/) (reactive custodial security),\r\n- [LN-Symmetry](https://bitcoinops.org/en/topics/eltoo/),\r\n- efficient implementations of [DLCs](https://bitcoinops.org/en/topics/discreet-log-contracts/),\r\n- [non-interactive channel openings](https://utxos.org/uses/non-interactive-channels/),\r\n- [congestion control](https://utxos.org/uses/scaling/),\r\n- decentralized mining pools (via [CTV compression in coinbase payouts](https://utxos.org/uses/miningpools/)),\r\n- various [Lightning efficiency improvements](https://twitter.com/roasbeef/status/1692589689939579259),\r\n- using [covenant based timeout-trees](https://bitcoinops.org/en/newsletters/2023/09/27/) to scale Lightning, and more generally enabling [channel factories](https://bitcoinops.org/en/topics/channel-factories/).\r\n\r\nWe also see that many speculative scaling solutions (e.g. [Ark](https://arkpill.me/), [Spacechains](https://gist.github.com/RubenSomsen/c9f0a92493e06b0e29acced61ca9f49a#spacechains)) require locking coins to be spent to a particular set of outputs without any additional authorization (i.e. CTV, or APO’s emulation of it).\r\n\r\n### Scope of discussion\r\n\r\nTo prevent this thread from becoming overrun, please keep high-level, conceptual discussion to the [related Delving Bitcoin thread](https://delvingbitcoin.org/t/covenant-tools-softfork/98). At this point in time, code nits probably aren't going to be useful either.\r\n\r\nThis draft has been posted to provide a tangible example of a softfork we might pursue, and a representation of the necessary code changes.\r\n\r\n### Activation method and parameters\r\n\r\nSpecific activation parameters have not been specified here (or are marked FIXME) to avoid putting the consensus cart before the horse. The activation method here has defaulted to the one used for BIP-0341 and might change pending discussion.",
          "user": {
            "login": "jamesob",
            "id": 73197,
            "node_id": "MDQ6VXNlcjczMTk3",
            "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jamesob",
            "html_url": "https://github.com/jamesob",
            "followers_url": "https://api.github.com/users/jamesob/followers",
            "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
            "organizations_url": "https://api.github.com/users/jamesob/orgs",
            "repos_url": "https://api.github.com/users/jamesob/repos",
            "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jamesob/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 192202000,
              "node_id": "MDU6TGFiZWwxOTIyMDIwMDA=",
              "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Consensus",
              "name": "Consensus",
              "color": "009800",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "MEMBER",
          "locked": false,
          "comments": 9,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/28550",
            "html_url": "https://github.com/bitcoin/bitcoin/pull/28550",
            "diff_url": "https://github.com/bitcoin/bitcoin/pull/28550.diff",
            "patch_url": "https://github.com/bitcoin/bitcoin/pull/28550.patch"
          },
          "created_at": "2023-09-28T18:42:45Z",
          "updated_at": "2024-01-15T05:15:50Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 10594167666,
      "node_id": "HRFPE_lADOAN28mc5eW19HzwAAAAJ3dity",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10594167666",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-10-09T18:07:37Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGViM2ZiNzI3YzMxZGQzNDhhNjM5OTJkMjJhMzU1NThlMDMxMTc0Zjk",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/eb3fb727c31dd348a63992d22a35558e031174f9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/eb3fb727c31dd348a63992d22a35558e031174f9",
      "tree": {
        "sha": "c3cd0df1bcadad983586accfdd28060ceed80792",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/c3cd0df1bcadad983586accfdd28060ceed80792"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/014b832e07d3be3c6aff1230d560fcf7032f0495",
          "sha": "014b832e07d3be3c6aff1230d560fcf7032f0495",
          "html_url": "https://github.com/bitcoin/bips/commit/014b832e07d3be3c6aff1230d560fcf7032f0495"
        }
      ],
      "message": "BIP-0345: restrict trigger output to v1 witness\n\nCo-authored-by: Antoine Poinsot <darosior@protonmail.com>",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-10-09T18:09:01Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2023-10-09T18:07:19Z"
      },
      "sha": "eb3fb727c31dd348a63992d22a35558e031174f9"
    },
    {
      "event": "reviewed",
      "id": 1675754288,
      "node_id": "PRR_kwDOAN28mc5j4fsw",
      "url": null,
      "actor": null,
      "commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1675754288",
      "submitted_at": "2023-10-13T05:41:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "reviewed",
      "id": 1675762428,
      "node_id": "PRR_kwDOAN28mc5j4hr8",
      "url": null,
      "actor": null,
      "commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1675762428",
      "submitted_at": "2023-10-13T06:27:58Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "reviewed",
      "id": 1700084752,
      "node_id": "PRR_kwDOAN28mc5lVTwQ",
      "url": null,
      "actor": null,
      "commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1700084752",
      "submitted_at": "2023-10-26T16:39:53Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "bitschmidty",
        "id": 1615772,
        "node_id": "MDQ6VXNlcjE2MTU3NzI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1615772?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitschmidty",
        "html_url": "https://github.com/bitschmidty",
        "followers_url": "https://api.github.com/users/bitschmidty/followers",
        "following_url": "https://api.github.com/users/bitschmidty/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitschmidty/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitschmidty/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitschmidty/subscriptions",
        "organizations_url": "https://api.github.com/users/bitschmidty/orgs",
        "repos_url": "https://api.github.com/users/bitschmidty/repos",
        "events_url": "https://api.github.com/users/bitschmidty/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitschmidty/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-10-31T15:48:45Z",
      "updated_at": "2023-10-31T15:48:45Z",
      "source": {
        "issue": {
          "id": 1969254700,
          "node_id": "PR_kwDOCCK3eM5eKxEg",
          "url": "https://api.github.com/repos/bitcoinops/bitcoinops.github.io/issues/1375",
          "repository_url": "https://api.github.com/repos/bitcoinops/bitcoinops.github.io",
          "labels_url": "https://api.github.com/repos/bitcoinops/bitcoinops.github.io/issues/1375/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoinops/bitcoinops.github.io/issues/1375/comments",
          "events_url": "https://api.github.com/repos/bitcoinops/bitcoinops.github.io/issues/1375/events",
          "html_url": "https://github.com/bitcoinops/bitcoinops.github.io/pull/1375",
          "number": 1375,
          "state": "closed",
          "state_reason": null,
          "title": "Newsletters: add 275 (2023-11-01)",
          "body": "- [x] Lede, releases/RCs, topic entries @harding \r\n- [x] Bitcoin Core 28685 @glozow \r\n- [x] Bitcoin Core 28651 @murchandamus \r\n- [x] Bitcoin Core 28565 @bitschmidty ",
          "user": {
            "login": "harding",
            "id": 61096,
            "node_id": "MDQ6VXNlcjYxMDk2",
            "avatar_url": "https://avatars.githubusercontent.com/u/61096?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/harding",
            "html_url": "https://github.com/harding",
            "followers_url": "https://api.github.com/users/harding/followers",
            "following_url": "https://api.github.com/users/harding/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/harding/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/harding/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/harding/subscriptions",
            "organizations_url": "https://api.github.com/users/harding/orgs",
            "repos_url": "https://api.github.com/users/harding/repos",
            "events_url": "https://api.github.com/users/harding/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/harding/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 2,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoinops/bitcoinops.github.io/pulls/1375",
            "html_url": "https://github.com/bitcoinops/bitcoinops.github.io/pull/1375",
            "diff_url": "https://github.com/bitcoinops/bitcoinops.github.io/pull/1375.diff",
            "patch_url": "https://github.com/bitcoinops/bitcoinops.github.io/pull/1375.patch"
          },
          "closed_at": "2023-11-01T10:11:17Z",
          "created_at": "2023-10-30T21:27:53Z",
          "updated_at": "2023-11-02T14:27:18Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "dgpv",
        "id": 43240089,
        "node_id": "MDQ6VXNlcjQzMjQwMDg5",
        "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dgpv",
        "html_url": "https://github.com/dgpv",
        "followers_url": "https://api.github.com/users/dgpv/followers",
        "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
        "organizations_url": "https://api.github.com/users/dgpv/orgs",
        "repos_url": "https://api.github.com/users/dgpv/repos",
        "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dgpv/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-11-14T12:57:26Z",
      "updated_at": "2023-11-14T12:57:26Z",
      "source": {
        "issue": {
          "id": 1942996365,
          "node_id": "I_kwDOJ8iBVc5zz8WN",
          "url": "https://api.github.com/repos/dgpv/bsst/issues/14",
          "repository_url": "https://api.github.com/repos/dgpv/bsst",
          "labels_url": "https://api.github.com/repos/dgpv/bsst/issues/14/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/dgpv/bsst/issues/14/comments",
          "events_url": "https://api.github.com/repos/dgpv/bsst/issues/14/events",
          "html_url": "https://github.com/dgpv/bsst/issues/14",
          "number": 14,
          "state": "closed",
          "state_reason": "completed",
          "title": "Add ability to analyze dynamic arguments for opcodes like ROLL",
          "body": "Currently, if an opcode uses one of its arguments as an index on the stack, we require this argument to be static.\r\n\r\nThere are possible practical scripts that can use dynamic stack indexes, so having ability to analyze these seem to be valuable.\r\n\r\nHere's the link to relevant discussion on delvingbitcoin: https://delvingbitcoin.org/t/bsst-plugins-for-covenant-opcodes/137/2\r\n\r\nFor convenience, I copy here parts of conversation from there:\r\n\r\ndgpv:\r\n> Each value of <n> for ROLL will require its own execution path. bsst could put some upper limit on <n>, generate that many execution paths, analyze them one by one, and then show them in the report as ‘branches’ with conditions like <n> = 1, <n> = 2, etc.\r\n> \r\n> But if <n> could happen to be above this limit, the analysis will be incomplete. The report can show a warning, something like “argument for PICK can be above the limit, analysis is incomplete”. This warning will be shown in each execution path generated for each value of <n>.\r\n> \r\n> If there are more than one such place in the script with non-static arg for PICK or ROLL, you will get a lot of execution paths in the report :-). I guess there needs to be an upper limit for the number of exec paths, too.\r\n\r\najtowns:\r\n\r\n> I was looking at [OP_VAULT](https://github.com/bitcoin/bips/pull/1421) which pops n+5 elements off the stack, one of which is n. (In particular: I wanted to DUP one of the items deepest in the stack, and do so automatically by DUP’ing n first)\r\n> \r\n> ...\r\n> \r\n> Being able to specify $n in [1,2,3,4,5] as a constraint in the file (ie pretending there was DUP 3 NUMEQUALVERIFY just prior to the ROLL or PICK for each value in the range) and just rerunning the analysis multiple times would work fine (and put the burden of the combinatorial explosion onto the user). I ended up just reframing my question to avoid the problem though, and that worked fine too.\r\n",
          "user": {
            "login": "dgpv",
            "id": 43240089,
            "node_id": "MDQ6VXNlcjQzMjQwMDg5",
            "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/dgpv",
            "html_url": "https://github.com/dgpv",
            "followers_url": "https://api.github.com/users/dgpv/followers",
            "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
            "organizations_url": "https://api.github.com/users/dgpv/orgs",
            "repos_url": "https://api.github.com/users/dgpv/repos",
            "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/dgpv/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 5744711337,
              "node_id": "LA_kwDOJ8iBVc8AAAABVmlWqQ",
              "url": "https://api.github.com/repos/dgpv/bsst/labels/enhancement",
              "name": "enhancement",
              "description": "New feature or request",
              "color": "a2eeef",
              "default": true
            }
          ],
          "assignees": [],
          "author_association": "OWNER",
          "milestone": {
            "url": "https://api.github.com/repos/dgpv/bsst/milestones/1",
            "html_url": "https://github.com/dgpv/bsst/milestone/1",
            "labels_url": "https://api.github.com/repos/dgpv/bsst/milestones/1/labels",
            "id": 10185595,
            "node_id": "MI_kwDOJ8iBVc4Am2t7",
            "number": 1,
            "state": "open",
            "title": "version 0.1.2",
            "description": "",
            "creator": {
              "login": "dgpv",
              "id": 43240089,
              "node_id": "MDQ6VXNlcjQzMjQwMDg5",
              "avatar_url": "https://avatars.githubusercontent.com/u/43240089?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/dgpv",
              "html_url": "https://github.com/dgpv",
              "followers_url": "https://api.github.com/users/dgpv/followers",
              "following_url": "https://api.github.com/users/dgpv/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/dgpv/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/dgpv/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/dgpv/subscriptions",
              "organizations_url": "https://api.github.com/users/dgpv/orgs",
              "repos_url": "https://api.github.com/users/dgpv/repos",
              "events_url": "https://api.github.com/users/dgpv/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/dgpv/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 0,
            "closed_issues": 5,
            "created_at": "2023-11-14T12:55:56Z",
            "updated_at": "2024-01-14T11:52:00Z"
          },
          "locked": false,
          "comments": 4,
          "closed_at": "2024-01-14T11:51:59Z",
          "created_at": "2023-10-14T05:36:54Z",
          "updated_at": "2024-01-14T11:52:00Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGMyY2VjNjU5Mzc4ODExMzFiY2FhNDViNTJkZTZlMWZiY2U1NDMzZDU",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/c2cec65937881131bcaa45b52de6e1fbce5433d5",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/c2cec65937881131bcaa45b52de6e1fbce5433d5",
      "tree": {
        "sha": "b3f8c40de59122a619535075a3dd2e9a1d7d4187",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/b3f8c40de59122a619535075a3dd2e9a1d7d4187"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/eb3fb727c31dd348a63992d22a35558e031174f9",
          "sha": "eb3fb727c31dd348a63992d22a35558e031174f9",
          "html_url": "https://github.com/bitcoin/bips/commit/eb3fb727c31dd348a63992d22a35558e031174f9"
        }
      ],
      "message": "fixup! rename `n-pushes` -> `push-count`",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2024-01-03T20:33:50Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2024-01-03T20:33:50Z"
      },
      "sha": "c2cec65937881131bcaa45b52de6e1fbce5433d5"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDMyNzAyNWIzNjllYTVjMTYyM2U3Njk1ZTRiN2I3OWQ0YTc5ZTczM2U",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/327025b369ea5c1623e7695e4b7b79d4a79e733e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/327025b369ea5c1623e7695e4b7b79d4a79e733e",
      "tree": {
        "sha": "2b170cc2e6e5065ccb5953bc6c6a91f88ccd3d5f",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/2b170cc2e6e5065ccb5953bc6c6a91f88ccd3d5f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/c2cec65937881131bcaa45b52de6e1fbce5433d5",
          "sha": "c2cec65937881131bcaa45b52de6e1fbce5433d5",
          "html_url": "https://github.com/bitcoin/bips/commit/c2cec65937881131bcaa45b52de6e1fbce5433d5"
        }
      ],
      "message": "fixup! misc. feedback from AJ and twhit223",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2024-01-03T21:11:50Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2024-01-03T21:11:50Z"
      },
      "sha": "327025b369ea5c1623e7695e4b7b79d4a79e733e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGRlOWVmNTkzMDdmNWQ5NDg4M2VlZmQyYzY2OTFjNjdkMzU4ZDkxNWE",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/de9ef59307f5d94883eefd2c6691c67d358d915a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/de9ef59307f5d94883eefd2c6691c67d358d915a",
      "tree": {
        "sha": "6c555a2443bf146ee3610d7527b98c394d96c136",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/6c555a2443bf146ee3610d7527b98c394d96c136"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/327025b369ea5c1623e7695e4b7b79d4a79e733e",
          "sha": "327025b369ea5c1623e7695e4b7b79d4a79e733e",
          "html_url": "https://github.com/bitcoin/bips/commit/327025b369ea5c1623e7695e4b7b79d4a79e733e"
        }
      ],
      "message": "fixup! remove unused diagram",
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2024-01-03T21:12:29Z"
      },
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@pm.me",
        "date": "2024-01-03T21:12:17Z"
      },
      "sha": "de9ef59307f5d94883eefd2c6691c67d358d915a"
    },
    {
      "event": "reviewed",
      "id": 1803029353,
      "node_id": "PRR_kwDOAN28mc5reAtp",
      "url": null,
      "actor": null,
      "commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "I think I've at least responded to all outstanding feedback.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1803029353",
      "submitted_at": "2024-01-03T21:12:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "reviewed",
      "id": 1805275987,
      "node_id": "PRR_kwDOAN28mc5rmlNT",
      "url": null,
      "actor": null,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "illesdavid",
        "id": 121698016,
        "node_id": "U_kgDOB0D24A",
        "avatar_url": "https://avatars.githubusercontent.com/u/121698016?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/illesdavid",
        "html_url": "https://github.com/illesdavid",
        "followers_url": "https://api.github.com/users/illesdavid/followers",
        "following_url": "https://api.github.com/users/illesdavid/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/illesdavid/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/illesdavid/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/illesdavid/subscriptions",
        "organizations_url": "https://api.github.com/users/illesdavid/orgs",
        "repos_url": "https://api.github.com/users/illesdavid/repos",
        "events_url": "https://api.github.com/users/illesdavid/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/illesdavid/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#pullrequestreview-1805275987",
      "submitted_at": "2024-01-05T02:33:31Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
    },
    {
      "event": "commented",
      "id": 1894476516,
      "node_id": "IC_kwDOAN28mc5w62rk",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1894476516",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2024-01-16T20:38:31Z",
      "updated_at": "2024-01-16T20:38:31Z",
      "author_association": "MEMBER",
      "body": "Is there anything else required for merge here?",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1421#issuecomment-1894476516",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1421"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105535651",
      "pull_request_review_id": 1297180793,
      "id": 1105535651,
      "node_id": "PRRC_kwDOAN28mc5B5SKj",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 73,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1. typo\r\n2. it's unclear what \"hostage situation\" means.",
      "created_at": "2023-02-14T09:38:15Z",
      "updated_at": "2023-02-14T11:03:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1105535651",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105535651"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105541332",
      "pull_request_review_id": 1297180793,
      "id": 1105541332,
      "node_id": "PRRC_kwDOAN28mc5B5TjU",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 103,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "duplicate of `coin loss follows if a vault address is reused,`?",
      "created_at": "2023-02-14T09:42:54Z",
      "updated_at": "2023-02-14T11:03:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1105541332",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105541332"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105544087",
      "pull_request_review_id": 1297180793,
      "id": 1105544087,
      "node_id": "PRRC_kwDOAN28mc5B5UOX",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 119,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "hard to tell what the circles are supposed to mean :)",
      "created_at": "2023-02-14T09:45:03Z",
      "updated_at": "2023-02-14T11:03:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1105544087",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105544087"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105559718",
      "pull_request_review_id": 1297180793,
      "id": 1105559718,
      "node_id": "PRRC_kwDOAN28mc5B5YCm",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 154,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1. It would help adding more arrow pointers to the dashed lines, because it's hard to tell in which directions some of them go (e.g., the one from the trigger tx to the right)\r\n2. [outputs controlled by recovery keys] should emphasize when they are chosen.",
      "created_at": "2023-02-14T09:58:01Z",
      "updated_at": "2023-02-14T11:03:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1105559718",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105559718"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105561007",
      "pull_request_review_id": 1297180793,
      "id": 1105561007,
      "node_id": "PRRC_kwDOAN28mc5B5YWv",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> outputs into one compatible <code>OP_UNVAULT</code> output, which broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 160,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "what does \"compatible\" mean?",
      "created_at": "2023-02-14T09:59:08Z",
      "updated_at": "2023-02-14T11:03:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1105561007",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105561007"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105564897",
      "pull_request_review_id": 1297180793,
      "id": 1105564897,
      "node_id": "PRRC_kwDOAN28mc5B5ZTh",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> outputs into one compatible <code>OP_UNVAULT</code> output, which broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> inputs into a compatible set of final withdrawal outputs per the target hash. The only authorization for this spend is the content hash of the withdrawal outputs.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 162,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "should mention a delay?",
      "created_at": "2023-02-14T10:02:21Z",
      "updated_at": "2023-02-14T11:03:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1105564897",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105564897"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 162,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105571464",
      "pull_request_review_id": 1297180793,
      "id": 1105571464,
      "node_id": "PRRC_kwDOAN28mc5B5a6I",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> outputs into one compatible <code>OP_UNVAULT</code> output, which broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> inputs into a compatible set of final withdrawal outputs per the target hash. The only authorization for this spend is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 189,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Are you implying an additional preimage/hash pair here, or maybe it is sufficient to use the recovery destination alone as a secret (it's already hashed in taproot fashion)?",
      "created_at": "2023-02-14T10:08:05Z",
      "updated_at": "2023-02-14T11:03:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1105571464",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105571464"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105572450",
      "pull_request_review_id": 1297180793,
      "id": 1105572450,
      "node_id": "PRRC_kwDOAN28mc5B5bJi",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> outputs into one compatible <code>OP_UNVAULT</code> output, which broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> inputs into a compatible set of final withdrawal outputs per the target hash. The only authorization for this spend is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 197,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "since the `OP_VAULT` was mined, i assume?",
      "created_at": "2023-02-14T10:08:58Z",
      "updated_at": "2023-02-14T11:03:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1105572450",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105572450"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105591592",
      "pull_request_review_id": 1297180793,
      "id": 1105591592,
      "node_id": "PRRC_kwDOAN28mc5B5f0o",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> outputs into one compatible <code>OP_UNVAULT</code> output, which broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> inputs into a compatible set of final withdrawal outputs per the target hash. The only authorization for this spend is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Check for recovery ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. If an output in the spending transaction is\n+found whose scriptPubKey hashes to the recovery sPK hash (the\n+first component of <code><recovery-params></code>), the interpreter will\n+evaluate for recovery. Otherwise, the interpreter will evaluate assuming a withdrawal\n+is being triggered.\n+\n+In pseudocode:\n+\n+<source lang=\"python\">\n+is_recovery = False\n+recovery_out: Optional[CTxOut] = None\n+\n+for out in spending_tx.vout:\n+    if tagged_hash(\"VaultRecoverySPK\", out.scriptPubKey) == recovery_sPK_hash:\n+        is_recovery = True\n+        recovery_out = out\n+\n+if is_recovery:\n+    eval_for_recovery()\n+else:\n+    eval_for_withdrawal_trigger()\n+</source>\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 310,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm confused, how this transaction is supposed to pay the fee?",
      "created_at": "2023-02-14T10:25:52Z",
      "updated_at": "2023-02-14T11:03:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1105591592",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105591592"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 310,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105594633",
      "pull_request_review_id": 1297180793,
      "id": 1105594633,
      "node_id": "PRRC_kwDOAN28mc5B5gkJ",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> outputs into one compatible <code>OP_UNVAULT</code> output, which broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> inputs into a compatible set of final withdrawal outputs per the target hash. The only authorization for this spend is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Check for recovery ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. If an output in the spending transaction is\n+found whose scriptPubKey hashes to the recovery sPK hash (the\n+first component of <code><recovery-params></code>), the interpreter will\n+evaluate for recovery. Otherwise, the interpreter will evaluate assuming a withdrawal\n+is being triggered.\n+\n+In pseudocode:\n+\n+<source lang=\"python\">\n+is_recovery = False\n+recovery_out: Optional[CTxOut] = None\n+\n+for out in spending_tx.vout:\n+    if tagged_hash(\"VaultRecoverySPK\", out.scriptPubKey) == recovery_sPK_hash:\n+        is_recovery = True\n+        recovery_out = out\n+\n+if is_recovery:\n+    eval_for_recovery()\n+else:\n+    eval_for_withdrawal_trigger()\n+</source>\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.\n+** Note that in the draft implementation, this is facilitated by a \"deferred check\" which is queued by the script interpreter, but executed after the script interpreter has finished, in other validation code.<ref>'''Why does this proposal require a \"deferred checks\" framework for correct script evaluation?''' The deferred checks framework is an augmentation to execution of the Bitcoin script interpreter. Currently, the validity of each input is checked in an order-indepdendent manner across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>\n+* The script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], nor\n+*# the version of the recovery transaction has an nVersion equal to 3.\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the recovery authorization witness program, if any.\n+\n+* If the ''recovery authorization sPK'' is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+* else (if the recovery is allowed to be unauthorized):\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output not the recovery output is not an ephemeral anchor, the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 323,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ephemeral anchors come up very unexpectedly here.... so this is how the fee is paid?",
      "created_at": "2023-02-14T10:28:32Z",
      "updated_at": "2023-02-14T11:03:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1105594633",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105594633"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 323,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105599157",
      "pull_request_review_id": 1297180793,
      "id": 1105599157,
      "node_id": "PRRC_kwDOAN28mc5B5hq1",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> outputs into one compatible <code>OP_UNVAULT</code> output, which broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> inputs into a compatible set of final withdrawal outputs per the target hash. The only authorization for this spend is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Check for recovery ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. If an output in the spending transaction is\n+found whose scriptPubKey hashes to the recovery sPK hash (the\n+first component of <code><recovery-params></code>), the interpreter will\n+evaluate for recovery. Otherwise, the interpreter will evaluate assuming a withdrawal\n+is being triggered.\n+\n+In pseudocode:\n+\n+<source lang=\"python\">\n+is_recovery = False\n+recovery_out: Optional[CTxOut] = None\n+\n+for out in spending_tx.vout:\n+    if tagged_hash(\"VaultRecoverySPK\", out.scriptPubKey) == recovery_sPK_hash:\n+        is_recovery = True\n+        recovery_out = out\n+\n+if is_recovery:\n+    eval_for_recovery()\n+else:\n+    eval_for_withdrawal_trigger()\n+</source>\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.\n+** Note that in the draft implementation, this is facilitated by a \"deferred check\" which is queued by the script interpreter, but executed after the script interpreter has finished, in other validation code.<ref>'''Why does this proposal require a \"deferred checks\" framework for correct script evaluation?''' The deferred checks framework is an augmentation to execution of the Bitcoin script interpreter. Currently, the validity of each input is checked in an order-indepdendent manner across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>\n+* The script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], nor\n+*# the version of the recovery transaction has an nVersion equal to 3.\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the recovery authorization witness program, if any.\n+\n+* If the ''recovery authorization sPK'' is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+* else (if the recovery is allowed to be unauthorized):\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output not the recovery output is not an ephemeral anchor, the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+\n+(Note: the above rules imply that if all inputs have a recovery authorization sPK specified, the structure of the recovery transaction is \"free form,\" and the only requirement is that for each <code>OP_VAULT</code>/<code>OP_UNVAULT</code> input, there exists a compatible ''recovery output'' which preserves its full <code>nValue</code>.)\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+==== <code>OP_VAULT</code> evaluation for withdrawal trigger ====\n+\n+Else, if it has been determined that the spend is not within a recovery\n+transaction, it must be evaluated for eligibility as a withdrawal trigger\n+spend.\n+\n+===== Witness stack =====\n+\n+There must be at least 4 items on the stack (shown top to bottom):\n+\n+<source>\n+<trigger-vout-idx>\n+<target-outputs-hash>\n+<trigger-sPK>\n+<trigger witness stack item 1> [...] <item n>\n+</source>\n+\n+If the witness stack consists of fewer than four items the script MUST fail and\n+terminate immediately.\n+\n+(Note: in practice, the witness stack will have included the other items necessary to reveal \n+a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)\n+\n+The items on the stack must be validated as follows:\n+\n+* <code><trigger-vout-idx></code> is a <code>CScriptNum</code> of up to 4 bytes.\n+** It indicates the vout index of this input's corresponding <code>OP_UNVAULT</code> output.\n+*** Validation rules for this output are described below.\n+** If this value does not decode as a valid CScriptNum value, the script MUST fail and terminate immediately.\n+** If this value does not correspond to a valid output in the spending transaction, the script MUST fail and terminate immediately.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 359,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Do you simply mean there is fewer outputs than idx?",
      "created_at": "2023-02-14T10:32:31Z",
      "updated_at": "2023-02-14T11:03:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1105599157",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105599157"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 359,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105610676",
      "pull_request_review_id": 1297180793,
      "id": 1105610676,
      "node_id": "PRRC_kwDOAN28mc5B5ke0",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> outputs into one compatible <code>OP_UNVAULT</code> output, which broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> inputs into a compatible set of final withdrawal outputs per the target hash. The only authorization for this spend is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Check for recovery ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. If an output in the spending transaction is\n+found whose scriptPubKey hashes to the recovery sPK hash (the\n+first component of <code><recovery-params></code>), the interpreter will\n+evaluate for recovery. Otherwise, the interpreter will evaluate assuming a withdrawal\n+is being triggered.\n+\n+In pseudocode:\n+\n+<source lang=\"python\">\n+is_recovery = False\n+recovery_out: Optional[CTxOut] = None\n+\n+for out in spending_tx.vout:\n+    if tagged_hash(\"VaultRecoverySPK\", out.scriptPubKey) == recovery_sPK_hash:\n+        is_recovery = True\n+        recovery_out = out\n+\n+if is_recovery:\n+    eval_for_recovery()\n+else:\n+    eval_for_withdrawal_trigger()\n+</source>\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.\n+** Note that in the draft implementation, this is facilitated by a \"deferred check\" which is queued by the script interpreter, but executed after the script interpreter has finished, in other validation code.<ref>'''Why does this proposal require a \"deferred checks\" framework for correct script evaluation?''' The deferred checks framework is an augmentation to execution of the Bitcoin script interpreter. Currently, the validity of each input is checked in an order-indepdendent manner across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>\n+* The script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], nor\n+*# the version of the recovery transaction has an nVersion equal to 3.\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the recovery authorization witness program, if any.\n+\n+* If the ''recovery authorization sPK'' is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+* else (if the recovery is allowed to be unauthorized):\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output not the recovery output is not an ephemeral anchor, the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+\n+(Note: the above rules imply that if all inputs have a recovery authorization sPK specified, the structure of the recovery transaction is \"free form,\" and the only requirement is that for each <code>OP_VAULT</code>/<code>OP_UNVAULT</code> input, there exists a compatible ''recovery output'' which preserves its full <code>nValue</code>.)\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+==== <code>OP_VAULT</code> evaluation for withdrawal trigger ====\n+\n+Else, if it has been determined that the spend is not within a recovery\n+transaction, it must be evaluated for eligibility as a withdrawal trigger\n+spend.\n+\n+===== Witness stack =====\n+\n+There must be at least 4 items on the stack (shown top to bottom):\n+\n+<source>\n+<trigger-vout-idx>\n+<target-outputs-hash>\n+<trigger-sPK>\n+<trigger witness stack item 1> [...] <item n>\n+</source>\n+\n+If the witness stack consists of fewer than four items the script MUST fail and\n+terminate immediately.\n+\n+(Note: in practice, the witness stack will have included the other items necessary to reveal \n+a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)\n+\n+The items on the stack must be validated as follows:\n+\n+* <code><trigger-vout-idx></code> is a <code>CScriptNum</code> of up to 4 bytes.\n+** It indicates the vout index of this input's corresponding <code>OP_UNVAULT</code> output.\n+*** Validation rules for this output are described below.\n+** If this value does not decode as a valid CScriptNum value, the script MUST fail and terminate immediately.\n+** If this value does not correspond to a valid output in the spending transaction, the script MUST fail and terminate immediately.\n+\n+* <code><target-outputs-hash></code> is a 32 byte data push.\n+** It is the hash of the proposed withdrawal target output set, defined by <code>target_outputs_hash(outputs)</code> below. Note that this value is duplicated here.<ref>'''Why, when spending an OP_VAULT output into a trigger, does the target hash need to be duplicated on the witness stack?''' The target hash exists in the <code>OP_UNVAULT</code> output script, likely behind a taproot pubkey. Its presence is required on the witness stack also so that the expected taproot pubkey for the <code>OP_UNVAULT</code> output can be constructed for comparison.</ref>",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 362,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`here` doesn't point to a location, but rather to a description of the location.\r\nThe rationale is hard to comprehend too.",
      "created_at": "2023-02-14T10:43:07Z",
      "updated_at": "2023-02-14T11:03:39Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1105610676",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105610676"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 362,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105659012",
      "pull_request_review_id": 1297360997,
      "id": 1105659012,
      "node_id": "PRRC_kwDOAN28mc5B5wSE",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 93,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": null,
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Link incorrect",
      "created_at": "2023-02-14T11:22:50Z",
      "updated_at": "2023-02-14T11:22:51Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1105659012",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1105659012"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 93,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106108701",
      "pull_request_review_id": 1298030443,
      "id": 1106108701,
      "node_id": "PRRC_kwDOAN28mc5B7eEd",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> outputs into one compatible <code>OP_UNVAULT</code> output, which broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> inputs into a compatible set of final withdrawal outputs per the target hash. The only authorization for this spend is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 189,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": 1105571464,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, it's the latter - in the case of unauthorized recovery, knowledge of the recovery path itself serves as authorization.",
      "created_at": "2023-02-14T17:03:46Z",
      "updated_at": "2023-02-14T17:03:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1106108701",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106108701"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106109085",
      "pull_request_review_id": 1298031048,
      "id": 1106109085,
      "node_id": "PRRC_kwDOAN28mc5B7eKd",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> outputs into one compatible <code>OP_UNVAULT</code> output, which broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> inputs into a compatible set of final withdrawal outputs per the target hash. The only authorization for this spend is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Check for recovery ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. If an output in the spending transaction is\n+found whose scriptPubKey hashes to the recovery sPK hash (the\n+first component of <code><recovery-params></code>), the interpreter will\n+evaluate for recovery. Otherwise, the interpreter will evaluate assuming a withdrawal\n+is being triggered.\n+\n+In pseudocode:\n+\n+<source lang=\"python\">\n+is_recovery = False\n+recovery_out: Optional[CTxOut] = None\n+\n+for out in spending_tx.vout:\n+    if tagged_hash(\"VaultRecoverySPK\", out.scriptPubKey) == recovery_sPK_hash:\n+        is_recovery = True\n+        recovery_out = out\n+\n+if is_recovery:\n+    eval_for_recovery()\n+else:\n+    eval_for_withdrawal_trigger()\n+</source>\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.\n+** Note that in the draft implementation, this is facilitated by a \"deferred check\" which is queued by the script interpreter, but executed after the script interpreter has finished, in other validation code.<ref>'''Why does this proposal require a \"deferred checks\" framework for correct script evaluation?''' The deferred checks framework is an augmentation to execution of the Bitcoin script interpreter. Currently, the validity of each input is checked in an order-indepdendent manner across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>\n+* The script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], nor\n+*# the version of the recovery transaction has an nVersion equal to 3.\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the recovery authorization witness program, if any.\n+\n+* If the ''recovery authorization sPK'' is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+* else (if the recovery is allowed to be unauthorized):\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output not the recovery output is not an ephemeral anchor, the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+\n+(Note: the above rules imply that if all inputs have a recovery authorization sPK specified, the structure of the recovery transaction is \"free form,\" and the only requirement is that for each <code>OP_VAULT</code>/<code>OP_UNVAULT</code> input, there exists a compatible ''recovery output'' which preserves its full <code>nValue</code>.)\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+==== <code>OP_VAULT</code> evaluation for withdrawal trigger ====\n+\n+Else, if it has been determined that the spend is not within a recovery\n+transaction, it must be evaluated for eligibility as a withdrawal trigger\n+spend.\n+\n+===== Witness stack =====\n+\n+There must be at least 4 items on the stack (shown top to bottom):\n+\n+<source>\n+<trigger-vout-idx>\n+<target-outputs-hash>\n+<trigger-sPK>\n+<trigger witness stack item 1> [...] <item n>\n+</source>\n+\n+If the witness stack consists of fewer than four items the script MUST fail and\n+terminate immediately.\n+\n+(Note: in practice, the witness stack will have included the other items necessary to reveal \n+a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)\n+\n+The items on the stack must be validated as follows:\n+\n+* <code><trigger-vout-idx></code> is a <code>CScriptNum</code> of up to 4 bytes.\n+** It indicates the vout index of this input's corresponding <code>OP_UNVAULT</code> output.\n+*** Validation rules for this output are described below.\n+** If this value does not decode as a valid CScriptNum value, the script MUST fail and terminate immediately.\n+** If this value does not correspond to a valid output in the spending transaction, the script MUST fail and terminate immediately.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 359,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": 1105599157,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Or if the given CScriptNum is negative.",
      "created_at": "2023-02-14T17:04:06Z",
      "updated_at": "2023-02-14T17:04:06Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1106109085",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106109085"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 359,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106158294",
      "pull_request_review_id": 1298103000,
      "id": 1106158294,
      "node_id": "PRRC_kwDOAN28mc5B7qLW",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> outputs into one compatible <code>OP_UNVAULT</code> output, which broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> inputs into a compatible set of final withdrawal outputs per the target hash. The only authorization for this spend is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Check for recovery ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. If an output in the spending transaction is\n+found whose scriptPubKey hashes to the recovery sPK hash (the\n+first component of <code><recovery-params></code>), the interpreter will\n+evaluate for recovery. Otherwise, the interpreter will evaluate assuming a withdrawal\n+is being triggered.\n+\n+In pseudocode:\n+\n+<source lang=\"python\">\n+is_recovery = False\n+recovery_out: Optional[CTxOut] = None\n+\n+for out in spending_tx.vout:\n+    if tagged_hash(\"VaultRecoverySPK\", out.scriptPubKey) == recovery_sPK_hash:\n+        is_recovery = True\n+        recovery_out = out\n+\n+if is_recovery:\n+    eval_for_recovery()\n+else:\n+    eval_for_withdrawal_trigger()\n+</source>\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 310,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": 1105591592,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Adding a rationale footnote for this.",
      "created_at": "2023-02-14T17:47:57Z",
      "updated_at": "2023-02-14T17:47:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1106158294",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106158294"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 310,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106161212",
      "pull_request_review_id": 1298109252,
      "id": 1106161212,
      "node_id": "PRRC_kwDOAN28mc5B7q48",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 93,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": 1105659012,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed, thanks.",
      "created_at": "2023-02-14T17:50:39Z",
      "updated_at": "2023-02-14T17:50:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1106161212",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106161212"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 93,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106162380",
      "pull_request_review_id": 1298111885,
      "id": 1106162380,
      "node_id": "PRRC_kwDOAN28mc5B7rLM",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 73,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": 1105535651,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed. I'm calling this the $5 wrench attack instead, and linking to relevant source material. ;)",
      "created_at": "2023-02-14T17:51:48Z",
      "updated_at": "2023-02-14T17:51:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1106162380",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106162380"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106163733",
      "pull_request_review_id": 1298114909,
      "id": 1106163733,
      "node_id": "PRRC_kwDOAN28mc5B7rgV",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 103,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": 1105541332,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think so; these are separate problems. Requiring an expensive set-up ceremony for each deposit is a different problem than the unaddressable risk of burning coins by reusing a presigned vault address.",
      "created_at": "2023-02-14T17:53:07Z",
      "updated_at": "2023-02-14T17:53:07Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1106163733",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106163733"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106182516",
      "pull_request_review_id": 1298150224,
      "id": 1106182516,
      "node_id": "PRRC_kwDOAN28mc5B7wF0",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 119,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": 1105544087,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've clarified the images a bit; let me know if still unclear.",
      "created_at": "2023-02-14T18:10:17Z",
      "updated_at": "2023-02-14T18:10:17Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1106182516",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106182516"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106183572",
      "pull_request_review_id": 1298152299,
      "id": 1106183572,
      "node_id": "PRRC_kwDOAN28mc5B7wWU",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> outputs into one compatible <code>OP_UNVAULT</code> output, which broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> inputs into a compatible set of final withdrawal outputs per the target hash. The only authorization for this spend is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 197,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": 1105572450,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, since it was spent into an OP_UNVAULT, which is the output that has to mature for `spend-delay`.",
      "created_at": "2023-02-14T18:11:11Z",
      "updated_at": "2023-02-14T18:11:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1106183572",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1106183572"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 197,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1110748234",
      "pull_request_review_id": 1304487643,
      "id": 1110748234,
      "node_id": "PRRC_kwDOAN28mc5CNKxK",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the $5 wrench attack =====\n+\n+This proposal uniquely provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** Note that in the draft implementation, this is facilitated by a \"deferred check\" which is queued by the script interpreter, but executed after the script interpreter has finished, in other validation code.<ref>'''Why does this proposal require a \"deferred checks\" framework for correct script evaluation?''' The deferred checks framework is an augmentation to execution of the Bitcoin script interpreter. Currently, the validity of each input is checked in an order-indepdendent manner across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>\n+* The script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], nor\n+*# the version of the recovery transaction has an nVersion equal to 3.\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the recovery authorization witness program, if any.\n+\n+* If the ''recovery authorization sPK'' is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+* else (if the recovery is allowed to be unauthorized):\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output not the recovery output is not an ephemeral anchor, the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+\n+(Note: the above rules imply that if all inputs have a recovery authorization sPK specified, the structure of the recovery transaction is \"free form,\" and the only requirement is that for each <code>OP_VAULT</code>/<code>OP_UNVAULT</code> input, there exists a compatible ''recovery output'' which preserves its full <code>nValue</code>.)\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+==== <code>OP_VAULT</code> evaluation for withdrawal trigger ====\n+\n+Else, if it has been determined that the spend is not within a recovery\n+transaction, it must be evaluated for eligibility as a withdrawal trigger\n+spend.\n+\n+===== Witness stack =====\n+\n+There must be at least 4 items on the stack (shown top to bottom):\n+\n+<source>\n+<trigger-vout-idx>\n+<target-outputs-hash>\n+<trigger-sPK>\n+<trigger witness stack item 1> [...] <item n>\n+</source>\n+\n+If the witness stack consists of fewer than four items the script MUST fail and\n+terminate immediately.\n+\n+(Note: in practice, the witness stack will have included the other items necessary to reveal \n+a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)\n+\n+The items on the stack must be validated as follows:\n+\n+* <code><trigger-vout-idx></code> is a <code>CScriptNum</code> of up to 4 bytes.\n+** It indicates the vout index of this input's corresponding <code>OP_UNVAULT</code> output.\n+*** Validation rules for this output are described below.\n+** If this value does not decode as a valid CScriptNum value, the script MUST fail and terminate immediately.\n+** If this value does not correspond to a valid output in the spending transaction, the script MUST fail and terminate immediately.\n+\n+* <code><target-outputs-hash></code> is a 32 byte data push.\n+** It is the hash of the proposed withdrawal target output set, defined by <code>target_outputs_hash(outputs)</code> below. Note that this value is duplicated here.<ref>'''Why, when spending an OP_VAULT output into a trigger, does the target hash need to be duplicated on the witness stack?''' The target hash exists in the <code>OP_UNVAULT</code> output script, likely behind a taproot pubkey. Its presence is required on the witness stack also so that the expected taproot pubkey for the <code>OP_UNVAULT</code> output can be constructed for comparison.</ref>\n+** If this value is not 32 bytes, the script MUST fail and terminate immediately.\n+\n+* <code><trigger-sPK></code> is a variable length data push.\n+** It must be the scriptPubKey that is the preimage to the <code><trigger-sPK-hash></code> specified in the spent <code>OP_VAULT</code> input.\n+** If this value does not tagged-hash to <code><trigger-sPK-hash></code> supplied by the <code>OP_VAULT</code> parameter, the script MUST fail and terminate immediately.\n+*** Verify <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>) == <trigger-sPK-hash></code>\n+** If this value does not correspond to a valid witness program, the script MUST fail and terminate immediately.\n+\n+* the remaining elements serve as the witness stack to satisfy the <code><trigger-sPK></code> witness program.\n+** If <code>VerifyWitnessProgram(<remaining stack elements>, <trigger-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the withdrawal trigger has been authorized.)\n+\n+===== Transaction outputs validation =====\n+\n+Once the contents of the witness stack have been parsed and validated, the transaction outputs must be checked.\n+\n+First, we must check for a ''revault output'': an output in the trigger transaction whose\n+scriptPubKey exactly matches that of the <code>OP_VAULT</code> input being\n+spent. Its presence is optional.\n+\n+For each vault input citing a particular <code><trigger-vout-idx></code>, the output \n+located at <code>vout[<trigger-vout-idx>]</code> (the \"trigger output\") must:\n+\n+* have as its scriptPubKey a witness program version 1 with a single <code>OP_UNVAULT</code> tapscript, having the internal key <code>lift_x(0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)</code>, per the NUMS point mentioned in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Design BIP-0341].<ref>'''Why must the OP_UNVAULT taproot use a NUMS point as its internal key?''' This ensures that an OP_UNVAULT trigger output is verifiable as expected. It also ensures that it is spendable only by the conditions of the vault.</ref>",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 381,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Suggested edits:\r\n\r\n* Remove `lift_x` because the internal taproot key is a 32-byte array (x-only key), not a point.\r\n* Change BIP341 link to point to the actual section where this NUMS point is mentioned.\r\n* Change \"a NUMS point\" to \"a predefined NUMS point\". The former would only need to be justified by the second footnote sentence (and wouldn't really need to be required by consensus as implementations could freely supply this or any other NUMS point). The verification requirement means the point must be predefined, hence the clarification.\r\n\r\n```suggestion\r\n* have as its scriptPubKey a witness program version 1 with a single <code>OP_UNVAULT</code> tapscript, having the internal key <code>0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code>, per the NUMS point mentioned in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP-0341].<ref>'''Why must the OP_UNVAULT taproot use a predefined NUMS point as its internal key?''' This ensures that an OP_UNVAULT trigger output is verifiable as expected. It also ensures that it is spendable only by the conditions of the vault.</ref>\r\n```",
      "created_at": "2023-02-18T06:53:14Z",
      "updated_at": "2023-02-18T07:39:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1110748234",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1110748234"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 381,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1110764291",
      "pull_request_review_id": 1304487643,
      "id": 1110764291,
      "node_id": "PRRC_kwDOAN28mc5CNOsD",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the $5 wrench attack =====",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 71,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Since the section already mentions the $5 wrench attack, the title itself could be something more descriptive, such as \"Provably non-bypassable timelocks\".",
      "created_at": "2023-02-18T07:05:30Z",
      "updated_at": "2023-02-18T07:39:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1110764291",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1110764291"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 71,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1110767218",
      "pull_request_review_id": 1304487643,
      "id": 1110767218,
      "node_id": "PRRC_kwDOAN28mc5CNPZy",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the $5 wrench attack =====\n+\n+This proposal uniquely provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 138,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\r\n```",
      "created_at": "2023-02-18T07:07:48Z",
      "updated_at": "2023-02-18T07:39:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1110767218",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1110767218"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 138,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1110776558",
      "pull_request_review_id": 1304487643,
      "id": 1110776558,
      "node_id": "PRRC_kwDOAN28mc5CNRru",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the $5 wrench attack =====\n+\n+This proposal uniquely provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 148,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"Future transaction versions\" is unnecessarily broad. Also fixing the ephemeral anchors link.\r\n```suggestion\r\nThis proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\r\n```",
      "created_at": "2023-02-18T07:15:04Z",
      "updated_at": "2023-02-18T07:39:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1110776558",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1110776558"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 148,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1110810372",
      "pull_request_review_id": 1304487643,
      "id": 1110810372,
      "node_id": "PRRC_kwDOAN28mc5CNZ8E",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the $5 wrench attack =====\n+\n+This proposal uniquely provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** Note that in the draft implementation, this is facilitated by a \"deferred check\" which is queued by the script interpreter, but executed after the script interpreter has finished, in other validation code.<ref>'''Why does this proposal require a \"deferred checks\" framework for correct script evaluation?''' The deferred checks framework is an augmentation to execution of the Bitcoin script interpreter. Currently, the validity of each input is checked in an order-indepdendent manner across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>\n+* The script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 307,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The core (consensus-critical) specification should probably only include consensus rules and not recommended standardness/policy rules (which should perhaps not be included at all, just like they aren't in BIP341).",
      "created_at": "2023-02-18T07:37:27Z",
      "updated_at": "2023-02-18T07:39:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1110810372",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1110810372"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 307,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1110813029",
      "pull_request_review_id": 1304487643,
      "id": 1110813029,
      "node_id": "PRRC_kwDOAN28mc5CNall",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the $5 wrench attack =====\n+\n+This proposal uniquely provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** Note that in the draft implementation, this is facilitated by a \"deferred check\" which is queued by the script interpreter, but executed after the script interpreter has finished, in other validation code.<ref>'''Why does this proposal require a \"deferred checks\" framework for correct script evaluation?''' The deferred checks framework is an augmentation to execution of the Bitcoin script interpreter. Currently, the validity of each input is checked in an order-indepdendent manner across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>\n+* The script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], nor\n+*# the version of the recovery transaction has an nVersion equal to 3.\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the recovery authorization witness program, if any.\n+\n+* If the ''recovery authorization sPK'' is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+* else (if the recovery is allowed to be unauthorized):\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output not the recovery output is not an ephemeral anchor, the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+\n+(Note: the above rules imply that if all inputs have a recovery authorization sPK specified, the structure of the recovery transaction is \"free form,\" and the only requirement is that for each <code>OP_VAULT</code>/<code>OP_UNVAULT</code> input, there exists a compatible ''recovery output'' which preserves its full <code>nValue</code>.)\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+==== <code>OP_VAULT</code> evaluation for withdrawal trigger ====\n+\n+Else, if it has been determined that the spend is not within a recovery\n+transaction, it must be evaluated for eligibility as a withdrawal trigger\n+spend.\n+\n+===== Witness stack =====\n+\n+There must be at least 4 items on the stack (shown top to bottom):\n+\n+<source>\n+<trigger-vout-idx>\n+<target-outputs-hash>\n+<trigger-sPK>\n+<trigger witness stack item 1> [...] <item n>\n+</source>\n+\n+If the witness stack consists of fewer than four items the script MUST fail and\n+terminate immediately.\n+\n+(Note: in practice, the witness stack will have included the other items necessary to reveal \n+a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)\n+\n+The items on the stack must be validated as follows:\n+\n+* <code><trigger-vout-idx></code> is a <code>CScriptNum</code> of up to 4 bytes.\n+** It indicates the vout index of this input's corresponding <code>OP_UNVAULT</code> output.\n+*** Validation rules for this output are described below.\n+** If this value does not decode as a valid CScriptNum value, the script MUST fail and terminate immediately.\n+** If this value does not correspond to a valid output in the spending transaction, the script MUST fail and terminate immediately.\n+\n+* <code><target-outputs-hash></code> is a 32 byte data push.\n+** It is the hash of the proposed withdrawal target output set, defined by <code>target_outputs_hash(outputs)</code> below. Note that this value is duplicated here.<ref>'''Why, when spending an OP_VAULT output into a trigger, does the target hash need to be duplicated on the witness stack?''' The target hash exists in the <code>OP_UNVAULT</code> output script, likely behind a taproot pubkey. Its presence is required on the witness stack also so that the expected taproot pubkey for the <code>OP_UNVAULT</code> output can be constructed for comparison.</ref>\n+** If this value is not 32 bytes, the script MUST fail and terminate immediately.\n+\n+* <code><trigger-sPK></code> is a variable length data push.\n+** It must be the scriptPubKey that is the preimage to the <code><trigger-sPK-hash></code> specified in the spent <code>OP_VAULT</code> input.\n+** If this value does not tagged-hash to <code><trigger-sPK-hash></code> supplied by the <code>OP_VAULT</code> parameter, the script MUST fail and terminate immediately.\n+*** Verify <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>) == <trigger-sPK-hash></code>\n+** If this value does not correspond to a valid witness program, the script MUST fail and terminate immediately.\n+\n+* the remaining elements serve as the witness stack to satisfy the <code><trigger-sPK></code> witness program.\n+** If <code>VerifyWitnessProgram(<remaining stack elements>, <trigger-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the withdrawal trigger has been authorized.)\n+\n+===== Transaction outputs validation =====\n+\n+Once the contents of the witness stack have been parsed and validated, the transaction outputs must be checked.\n+\n+First, we must check for a ''revault output'': an output in the trigger transaction whose\n+scriptPubKey exactly matches that of the <code>OP_VAULT</code> input being\n+spent. Its presence is optional.\n+\n+For each vault input citing a particular <code><trigger-vout-idx></code>, the output \n+located at <code>vout[<trigger-vout-idx>]</code> (the \"trigger output\") must:\n+\n+* have as its scriptPubKey a witness program version 1 with a single <code>OP_UNVAULT</code> tapscript, having the internal key <code>lift_x(0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)</code>, per the NUMS point mentioned in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Design BIP-0341].<ref>'''Why must the OP_UNVAULT taproot use a NUMS point as its internal key?''' This ensures that an OP_UNVAULT trigger output is verifiable as expected. It also ensures that it is spendable only by the conditions of the vault.</ref>\n+** If the witness program has a version less than 1, the script MUST fail and terminate immediately.\n+** If the scriptPubKey of the output does not match the expected scriptPubKey, as computed by creating a taproot output using the cited NUMS point and a single tapscript spend condition of the form<br /><code><recovery-params-from-stack> <spend-delay-from-stack> <target-outputs-hash-from-stack> OP_UNVAULT</code>,<br />the script MUST fail and terminate immediately.\n+** Witness versions greater than 1 are allowed for upgradeability.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 384,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "in_reply_to_id": null,
      "user": {
        "login": "vostrnad",
        "id": 43024885,
        "node_id": "MDQ6VXNlcjQzMDI0ODg1",
        "avatar_url": "https://avatars.githubusercontent.com/u/43024885?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vostrnad",
        "html_url": "https://github.com/vostrnad",
        "followers_url": "https://api.github.com/users/vostrnad/followers",
        "following_url": "https://api.github.com/users/vostrnad/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vostrnad/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vostrnad/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vostrnad/subscriptions",
        "organizations_url": "https://api.github.com/users/vostrnad/orgs",
        "repos_url": "https://api.github.com/users/vostrnad/repos",
        "events_url": "https://api.github.com/users/vostrnad/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vostrnad/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The parent bullet point requires version 1, so which is it?",
      "created_at": "2023-02-18T07:39:25Z",
      "updated_at": "2023-02-18T07:39:46Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1110813029",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1110813029"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 384,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1111044538",
      "pull_request_review_id": 1304601446,
      "id": 1111044538,
      "node_id": "PRRC_kwDOAN28mc5COTG6",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the $5 wrench attack =====\n+\n+This proposal uniquely provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 126,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "in_reply_to_id": null,
      "user": {
        "login": "apoelstra",
        "id": 1351933,
        "node_id": "MDQ6VXNlcjEzNTE5MzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1351933?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/apoelstra",
        "html_url": "https://github.com/apoelstra",
        "followers_url": "https://api.github.com/users/apoelstra/followers",
        "following_url": "https://api.github.com/users/apoelstra/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/apoelstra/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/apoelstra/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/apoelstra/subscriptions",
        "organizations_url": "https://api.github.com/users/apoelstra/orgs",
        "repos_url": "https://api.github.com/users/apoelstra/repos",
        "events_url": "https://api.github.com/users/apoelstra/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/apoelstra/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "FWIW we did a demo in 2016: https://blog.blockstream.com/en-covenants-in-elements-alpha/\r\n\r\nWe would definitely not take this approach today unless we really had to. The script is really complex and I had to write custom ad-hoc analysis code to convince myself that the construction was okay.\r\n\r\nWe have a more modern covenant design in [elements-miniscirpt](https://github.com/ElementsProject/elements-miniscript/blob/master/doc/extension_spec.md) which we believe would be **significantly** simpler, and be possible to analyze without unholy means, but so far we've only implemented non-recursive covenants, not vaults.",
      "created_at": "2023-02-18T14:40:24Z",
      "updated_at": "2023-02-18T14:41:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1111044538",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1111044538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1111430652",
      "pull_request_review_id": 1305028593,
      "id": 1111430652,
      "node_id": "PRRC_kwDOAN28mc5CPxX8",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the $5 wrench attack =====\n+\n+This proposal uniquely provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** Note that in the draft implementation, this is facilitated by a \"deferred check\" which is queued by the script interpreter, but executed after the script interpreter has finished, in other validation code.<ref>'''Why does this proposal require a \"deferred checks\" framework for correct script evaluation?''' The deferred checks framework is an augmentation to execution of the Bitcoin script interpreter. Currently, the validity of each input is checked in an order-indepdendent manner across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>\n+* The script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 307,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "in_reply_to_id": 1110810372,
      "user": {
        "login": "harding",
        "id": 61096,
        "node_id": "MDQ6VXNlcjYxMDk2",
        "avatar_url": "https://avatars.githubusercontent.com/u/61096?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/harding",
        "html_url": "https://github.com/harding",
        "followers_url": "https://api.github.com/users/harding/followers",
        "following_url": "https://api.github.com/users/harding/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/harding/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/harding/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/harding/subscriptions",
        "organizations_url": "https://api.github.com/users/harding/orgs",
        "repos_url": "https://api.github.com/users/harding/repos",
        "events_url": "https://api.github.com/users/harding/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/harding/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I also didn't like the mixing of consensus and policy rules in the spec.  I think work on different layers has previously been dealt with by using different BIPs, e.g. BIPs 13 vs 16, or BIPs 141/143 vs 144.\r\n\r\nThat said, if separate BIPs is just too annoying, maybe the rules for policy could just be moved to a different section.",
      "created_at": "2023-02-20T03:49:40Z",
      "updated_at": "2023-02-20T03:49:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1111430652",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1111430652"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 307,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113314341",
      "pull_request_review_id": 1307797556,
      "id": 1113314341,
      "node_id": "PRRC_kwDOAN28mc5CW9Ql",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the $5 wrench attack =====\n+\n+This proposal uniquely provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 126,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "in_reply_to_id": 1111044538,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks! Will include.",
      "created_at": "2023-02-21T16:38:30Z",
      "updated_at": "2023-02-21T16:38:30Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1113314341",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113314341"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113319001",
      "pull_request_review_id": 1307804530,
      "id": 1113319001,
      "node_id": "PRRC_kwDOAN28mc5CW-ZZ",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the $5 wrench attack =====\n+\n+This proposal uniquely provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** Note that in the draft implementation, this is facilitated by a \"deferred check\" which is queued by the script interpreter, but executed after the script interpreter has finished, in other validation code.<ref>'''Why does this proposal require a \"deferred checks\" framework for correct script evaluation?''' The deferred checks framework is an augmentation to execution of the Bitcoin script interpreter. Currently, the validity of each input is checked in an order-indepdendent manner across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>\n+* The script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], nor\n+*# the version of the recovery transaction has an nVersion equal to 3.\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the recovery authorization witness program, if any.\n+\n+* If the ''recovery authorization sPK'' is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+* else (if the recovery is allowed to be unauthorized):\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output not the recovery output is not an ephemeral anchor, the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+\n+(Note: the above rules imply that if all inputs have a recovery authorization sPK specified, the structure of the recovery transaction is \"free form,\" and the only requirement is that for each <code>OP_VAULT</code>/<code>OP_UNVAULT</code> input, there exists a compatible ''recovery output'' which preserves its full <code>nValue</code>.)\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+==== <code>OP_VAULT</code> evaluation for withdrawal trigger ====\n+\n+Else, if it has been determined that the spend is not within a recovery\n+transaction, it must be evaluated for eligibility as a withdrawal trigger\n+spend.\n+\n+===== Witness stack =====\n+\n+There must be at least 4 items on the stack (shown top to bottom):\n+\n+<source>\n+<trigger-vout-idx>\n+<target-outputs-hash>\n+<trigger-sPK>\n+<trigger witness stack item 1> [...] <item n>\n+</source>\n+\n+If the witness stack consists of fewer than four items the script MUST fail and\n+terminate immediately.\n+\n+(Note: in practice, the witness stack will have included the other items necessary to reveal \n+a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)\n+\n+The items on the stack must be validated as follows:\n+\n+* <code><trigger-vout-idx></code> is a <code>CScriptNum</code> of up to 4 bytes.\n+** It indicates the vout index of this input's corresponding <code>OP_UNVAULT</code> output.\n+*** Validation rules for this output are described below.\n+** If this value does not decode as a valid CScriptNum value, the script MUST fail and terminate immediately.\n+** If this value does not correspond to a valid output in the spending transaction, the script MUST fail and terminate immediately.\n+\n+* <code><target-outputs-hash></code> is a 32 byte data push.\n+** It is the hash of the proposed withdrawal target output set, defined by <code>target_outputs_hash(outputs)</code> below. Note that this value is duplicated here.<ref>'''Why, when spending an OP_VAULT output into a trigger, does the target hash need to be duplicated on the witness stack?''' The target hash exists in the <code>OP_UNVAULT</code> output script, likely behind a taproot pubkey. Its presence is required on the witness stack also so that the expected taproot pubkey for the <code>OP_UNVAULT</code> output can be constructed for comparison.</ref>\n+** If this value is not 32 bytes, the script MUST fail and terminate immediately.\n+\n+* <code><trigger-sPK></code> is a variable length data push.\n+** It must be the scriptPubKey that is the preimage to the <code><trigger-sPK-hash></code> specified in the spent <code>OP_VAULT</code> input.\n+** If this value does not tagged-hash to <code><trigger-sPK-hash></code> supplied by the <code>OP_VAULT</code> parameter, the script MUST fail and terminate immediately.\n+*** Verify <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>) == <trigger-sPK-hash></code>\n+** If this value does not correspond to a valid witness program, the script MUST fail and terminate immediately.\n+\n+* the remaining elements serve as the witness stack to satisfy the <code><trigger-sPK></code> witness program.\n+** If <code>VerifyWitnessProgram(<remaining stack elements>, <trigger-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the withdrawal trigger has been authorized.)\n+\n+===== Transaction outputs validation =====\n+\n+Once the contents of the witness stack have been parsed and validated, the transaction outputs must be checked.\n+\n+First, we must check for a ''revault output'': an output in the trigger transaction whose\n+scriptPubKey exactly matches that of the <code>OP_VAULT</code> input being\n+spent. Its presence is optional.\n+\n+For each vault input citing a particular <code><trigger-vout-idx></code>, the output \n+located at <code>vout[<trigger-vout-idx>]</code> (the \"trigger output\") must:\n+\n+* have as its scriptPubKey a witness program version 1 with a single <code>OP_UNVAULT</code> tapscript, having the internal key <code>lift_x(0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)</code>, per the NUMS point mentioned in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Design BIP-0341].<ref>'''Why must the OP_UNVAULT taproot use a NUMS point as its internal key?''' This ensures that an OP_UNVAULT trigger output is verifiable as expected. It also ensures that it is spendable only by the conditions of the vault.</ref>",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 381,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "in_reply_to_id": 1110748234,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good feedback; fixed in ca12c526ab11b0e7bf2b2da693405cf8ac350bfa, thanks. ",
      "created_at": "2023-02-21T16:42:32Z",
      "updated_at": "2023-02-21T16:42:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1113319001",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113319001"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 381,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113321151",
      "pull_request_review_id": 1307807668,
      "id": 1113321151,
      "node_id": "PRRC_kwDOAN28mc5CW-6_",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the $5 wrench attack =====\n+\n+This proposal uniquely provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** Note that in the draft implementation, this is facilitated by a \"deferred check\" which is queued by the script interpreter, but executed after the script interpreter has finished, in other validation code.<ref>'''Why does this proposal require a \"deferred checks\" framework for correct script evaluation?''' The deferred checks framework is an augmentation to execution of the Bitcoin script interpreter. Currently, the validity of each input is checked in an order-indepdendent manner across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>\n+* The script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 307,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "in_reply_to_id": 1110810372,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've moved this provision into a policy section (ca12c526ab11b0e7bf2b2da693405cf8ac350bfa), and will likely make recovery transaction structure (for unauthorized vs. authorized) a matter of policy as well, since the distinction only exists there to prevent pinning.",
      "created_at": "2023-02-21T16:44:25Z",
      "updated_at": "2023-02-21T16:44:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1113321151",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113321151"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 307,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113321527",
      "pull_request_review_id": 1307808219,
      "id": 1113321527,
      "node_id": "PRRC_kwDOAN28mc5CW_A3",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the $5 wrench attack =====\n+\n+This proposal uniquely provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** Note that in the draft implementation, this is facilitated by a \"deferred check\" which is queued by the script interpreter, but executed after the script interpreter has finished, in other validation code.<ref>'''Why does this proposal require a \"deferred checks\" framework for correct script evaluation?''' The deferred checks framework is an augmentation to execution of the Bitcoin script interpreter. Currently, the validity of each input is checked in an order-indepdendent manner across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>\n+* The script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], nor\n+*# the version of the recovery transaction has an nVersion equal to 3.\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the recovery authorization witness program, if any.\n+\n+* If the ''recovery authorization sPK'' is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+* else (if the recovery is allowed to be unauthorized):\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output not the recovery output is not an ephemeral anchor, the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+\n+(Note: the above rules imply that if all inputs have a recovery authorization sPK specified, the structure of the recovery transaction is \"free form,\" and the only requirement is that for each <code>OP_VAULT</code>/<code>OP_UNVAULT</code> input, there exists a compatible ''recovery output'' which preserves its full <code>nValue</code>.)\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+==== <code>OP_VAULT</code> evaluation for withdrawal trigger ====\n+\n+Else, if it has been determined that the spend is not within a recovery\n+transaction, it must be evaluated for eligibility as a withdrawal trigger\n+spend.\n+\n+===== Witness stack =====\n+\n+There must be at least 4 items on the stack (shown top to bottom):\n+\n+<source>\n+<trigger-vout-idx>\n+<target-outputs-hash>\n+<trigger-sPK>\n+<trigger witness stack item 1> [...] <item n>\n+</source>\n+\n+If the witness stack consists of fewer than four items the script MUST fail and\n+terminate immediately.\n+\n+(Note: in practice, the witness stack will have included the other items necessary to reveal \n+a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)\n+\n+The items on the stack must be validated as follows:\n+\n+* <code><trigger-vout-idx></code> is a <code>CScriptNum</code> of up to 4 bytes.\n+** It indicates the vout index of this input's corresponding <code>OP_UNVAULT</code> output.\n+*** Validation rules for this output are described below.\n+** If this value does not decode as a valid CScriptNum value, the script MUST fail and terminate immediately.\n+** If this value does not correspond to a valid output in the spending transaction, the script MUST fail and terminate immediately.\n+\n+* <code><target-outputs-hash></code> is a 32 byte data push.\n+** It is the hash of the proposed withdrawal target output set, defined by <code>target_outputs_hash(outputs)</code> below. Note that this value is duplicated here.<ref>'''Why, when spending an OP_VAULT output into a trigger, does the target hash need to be duplicated on the witness stack?''' The target hash exists in the <code>OP_UNVAULT</code> output script, likely behind a taproot pubkey. Its presence is required on the witness stack also so that the expected taproot pubkey for the <code>OP_UNVAULT</code> output can be constructed for comparison.</ref>\n+** If this value is not 32 bytes, the script MUST fail and terminate immediately.\n+\n+* <code><trigger-sPK></code> is a variable length data push.\n+** It must be the scriptPubKey that is the preimage to the <code><trigger-sPK-hash></code> specified in the spent <code>OP_VAULT</code> input.\n+** If this value does not tagged-hash to <code><trigger-sPK-hash></code> supplied by the <code>OP_VAULT</code> parameter, the script MUST fail and terminate immediately.\n+*** Verify <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>) == <trigger-sPK-hash></code>\n+** If this value does not correspond to a valid witness program, the script MUST fail and terminate immediately.\n+\n+* the remaining elements serve as the witness stack to satisfy the <code><trigger-sPK></code> witness program.\n+** If <code>VerifyWitnessProgram(<remaining stack elements>, <trigger-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the withdrawal trigger has been authorized.)\n+\n+===== Transaction outputs validation =====\n+\n+Once the contents of the witness stack have been parsed and validated, the transaction outputs must be checked.\n+\n+First, we must check for a ''revault output'': an output in the trigger transaction whose\n+scriptPubKey exactly matches that of the <code>OP_VAULT</code> input being\n+spent. Its presence is optional.\n+\n+For each vault input citing a particular <code><trigger-vout-idx></code>, the output \n+located at <code>vout[<trigger-vout-idx>]</code> (the \"trigger output\") must:\n+\n+* have as its scriptPubKey a witness program version 1 with a single <code>OP_UNVAULT</code> tapscript, having the internal key <code>lift_x(0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)</code>, per the NUMS point mentioned in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Design BIP-0341].<ref>'''Why must the OP_UNVAULT taproot use a NUMS point as its internal key?''' This ensures that an OP_UNVAULT trigger output is verifiable as expected. It also ensures that it is spendable only by the conditions of the vault.</ref>\n+** If the witness program has a version less than 1, the script MUST fail and terminate immediately.\n+** If the scriptPubKey of the output does not match the expected scriptPubKey, as computed by creating a taproot output using the cited NUMS point and a single tapscript spend condition of the form<br /><code><recovery-params-from-stack> <spend-delay-from-stack> <target-outputs-hash-from-stack> OP_UNVAULT</code>,<br />the script MUST fail and terminate immediately.\n+** Witness versions greater than 1 are allowed for upgradeability.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 384,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "in_reply_to_id": 1110813029,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've clarified this in ca12c526ab11b0e7bf2b2da693405cf8ac350bfa.",
      "created_at": "2023-02-21T16:44:45Z",
      "updated_at": "2023-02-21T16:44:45Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1113321527",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113321527"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 384,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113335927",
      "pull_request_review_id": 1307829070,
      "id": 1113335927,
      "node_id": "PRRC_kwDOAN28mc5CXCh3",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the $5 wrench attack =====\n+\n+This proposal uniquely provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** Note that in the draft implementation, this is facilitated by a \"deferred check\" which is queued by the script interpreter, but executed after the script interpreter has finished, in other validation code.<ref>'''Why does this proposal require a \"deferred checks\" framework for correct script evaluation?''' The deferred checks framework is an augmentation to execution of the Bitcoin script interpreter. Currently, the validity of each input is checked in an order-indepdendent manner across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>\n+* The script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 307,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "in_reply_to_id": 1110810372,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Node policy is an individual decision and generally not a subject for BIPs at all.",
      "created_at": "2023-02-21T16:56:57Z",
      "updated_at": "2023-02-21T16:56:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1113335927",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113335927"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 307,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113342807",
      "pull_request_review_id": 1307838931,
      "id": 1113342807,
      "node_id": "PRRC_kwDOAN28mc5CXENX",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output<ref>Because the trigger scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.</ref>\n+** <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash''<ref>Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.</ref>, committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", <recovery-sPK>)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction, referred to as <code><recovery-auth-sPK></code>. \n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than or equal to this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the <code><recovery-auth-sPK></code> witness program, if any.\n+\n+* If <code><recovery-auth-sPK></code> is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+==== <code>OP_VAULT</code> evaluation for withdrawal trigger ====\n+\n+Else, if it has been determined that the spend is not within a recovery\n+transaction, it must be evaluated for eligibility as a withdrawal trigger\n+spend.\n+\n+===== Witness stack =====\n+\n+There must be at least 4 items on the stack (shown top to bottom):\n+\n+<source>\n+<trigger-vout-idx>\n+<target-outputs-hash>\n+<trigger-sPK>\n+<trigger witness stack item 1> [...] <item n>\n+</source>\n+\n+If the witness stack consists of fewer than four items the script MUST fail and\n+terminate immediately.\n+\n+(Note: in practice, the witness stack will have included the other items necessary to reveal \n+a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)\n+\n+The items on the stack must be validated as follows:\n+\n+* <code><trigger-vout-idx></code> is a <code>CScriptNum</code> of up to 4 bytes.\n+** It indicates the vout index of this input's corresponding <code>OP_UNVAULT</code> output.\n+*** Validation rules for this output are described below.\n+** If this value does not decode as a valid CScriptNum value, the script MUST fail and terminate immediately.\n+** If this value does not correspond to a valid output in the spending transaction, the script MUST fail and terminate immediately.\n+\n+* <code><target-outputs-hash></code> is a 32 byte data push.\n+** It is the hash of the proposed withdrawal target output set, defined by <code>target_outputs_hash(outputs)</code> below. Note that this value is duplicated here.<ref>'''Why, when spending an OP_VAULT output into a trigger, does the target hash need to be duplicated on the witness stack?''' The target hash exists in the <code>OP_UNVAULT</code> output script, likely behind a taproot pubkey. Its presence is required on the witness stack also so that the expected taproot pubkey for the <code>OP_UNVAULT</code> output can be constructed for comparison.</ref>\n+** If this value is not 32 bytes, the script MUST fail and terminate immediately.\n+\n+* <code><trigger-sPK></code> is a variable length data push.\n+** It must be the scriptPubKey that is the preimage to the <code><trigger-sPK-hash></code> specified in the spent <code>OP_VAULT</code> input.\n+** If this value does not tagged-hash to <code><trigger-sPK-hash></code> supplied by the <code>OP_VAULT</code> parameter, the script MUST fail and terminate immediately.\n+*** Verify <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>) == <trigger-sPK-hash></code>\n+** If this value does not correspond to a valid witness program, the script MUST fail and terminate immediately.\n+\n+* the remaining elements serve as the witness stack to satisfy the <code><trigger-sPK></code> witness program.\n+** If <code>VerifyWitnessProgram(<remaining stack elements>, <trigger-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the withdrawal trigger has been authorized.)\n+\n+===== Transaction outputs validation =====\n+\n+Once the contents of the witness stack have been parsed and validated, the transaction outputs must be checked.\n+\n+First, we must check for a ''revault output'': an output in the trigger transaction whose\n+scriptPubKey exactly matches that of the <code>OP_VAULT</code> input being\n+spent. Its presence is optional.\n+\n+For each vault input citing a particular <code><trigger-vout-idx></code>, the output \n+located at <code>vout[<trigger-vout-idx>]</code> (the \"trigger output\") must:\n+\n+* have as its scriptPubKey a witness program with a single <code>OP_UNVAULT</code> tapscript, having the internal x-only key <code>0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code>, per the NUMS point mentioned in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP-0341].<ref>'''Why must the OP_UNVAULT taproot use a predefined NUMS point as its internal key?''' This ensures that an OP_UNVAULT trigger output is verifiable as expected. It also ensures that it is spendable only by the conditions of the vault.</ref>\n+** If the witness program has a version less than 1, the script MUST fail and terminate immediately.\n+** If the witness program has a version greater than 1, the script MUST succeed to enable upgradeability.\n+** If the witness program has a version of 1 and the scriptPubKey of the output does not match the expected scriptPubKey, as computed by creating a taproot output using the cited NUMS point and a single tapscript spend condition of the form<br /><code><recovery-params-from-stack> <spend-delay-from-stack> <target-outputs-hash-from-stack> OP_UNVAULT</code>,<br />the script MUST fail and terminate immediately.\n+** Witness versions greater than 1 are allowed for upgradeability.\n+\n+* If there does not exist a revault output in the transaction for this input:\n+** (deferred) the <code>nValue</code> of the trigger output must equal the sum of all vault inputs which cite it as their corresponding trigger output.\n+*** If these values are not equal, the script MUST fail and terminate immediately.\n+* else (if there does exist a revault output for this input):\n+** (deferred) the <code>nValue</code>s of the trigger output and the revault output must sum to the sum of all vault inputs which both \n+*** cite this trigger output as the trigger-vout-idx and \n+*** have a scriptPubKey identical to the revault output's.\n+** If these values are not equal, the script MUST fail and terminate immediately.\n+\n+If none of the conditions above results in a failure of the script interpreter, the \n+stack will consist of a single true value (<code>0x01</code>).\n+\n+The above amount check can be expressed in Python as:\n+\n+<source lang=\"python\">\n+\n+spending_tx: CTransaction\n+vault_inputs: [CTxIn] = [inp for inp in spending_tx.vin if inp.is_OP_VAULT]\n+\n+\"Where we'll accumulate the expected totals for each vault input.\"\n+vault_totals_for_outputs: dict[(int, int), int] = defaultdict(0)\n+\n+\"Build the expected totals.\"\n+for vault_in in vault_inputs:\n+    maybe_revault_idx = find_revault_for_vault(vault_in)\n+    vault_total_for_outputs[(vault_in.trigger_vout_idx, maybe_revault_idx)] += vault_in.nValue\n+\n+\n+\"Check the expected totals against outputs.\"\n+for (out_idx, maybe_revault_idx), expected_amount in vault_totals_for_outputs.items():\n+    total = spending_tx.vout[out_idx].nValue\n+\n+    if maybe_revault_idx:\n+        total += spending_tx.vout[maybe_revault_idx]\n+\n+    if total != expected_amount:\n+        FAIL_AND_TERMINATE_SCRIPT()\n+    \n+    \n+def find_revault_for_vault(vault_in) -> int:\n+    \"\"\"Find the index of a revault output for a particular vault input, if one exists.\"\"\"\n+    for i, out in enumerate(spending_tx.vout):\n+        if out.scriptPubKey == vault_in.scriptPubKey:\n+            return i\n+    return None\n+</source>\n+\n+=== <code>OP_UNVAULT</code> evaulation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_UNVAULT</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbc</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_UNVAULT             (*) being evaluated\n+<target-outputs-hash>\n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><recovery-params></code> is validated exactly as described in [[#witness-program|the above <code>OP_VAULT</code> section]].\n+* <code><spend-delay></code> is validated exactly as described in [[#witness-program|the above <code>OP_VAULT</code> section]].\n+* <code><target-output-hash></code> is a 32 byte data push.\n+** If it is not equal to 32 bytes, the script MUST fail and terminate immediately.\n+\n+\n+==== Check for recovery ====\n+\n+A check is performed to determine if this input is being spent within the context of\n+a recovery transaction, exactly as in [[#check-for-recovery|the <code>OP_VAULT</code> evaluation described above]].\n+\n+\n+==== <code>OP_UNVAULT</code> evaluation for recovery spend ====\n+\n+This is identical to the [[#op_vault-evaluation-for-recovery-spend|<code>OP_VAULT</code> case described above]].\n+\n+\n+==== <code>OP_UNVAULT</code> evaluation for withdrawal ====\n+\n+When spending an <code>OP_UNVAULT</code> input into a withdrawal target, no witness stack is required.\n+\n+* <code><spend-delay></code> is used to check whether the withdrawal of the input has matured.\n+** If the input's relative timelock check, as described in [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP-0112] (using this value as \"the top item on the stack\") fails, the script MUST fail and terminate immediately.\n+*** The same <code>CheckSequence(<spend-delay>)</code> code path is used as for [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP-0112].\n+\n+* The transaction outputs are then checked to verify that the withdrawal outputs are as expected.\n+** If <code>target_outputs_hash(spending_tx.vout) != <target-output-hash></code> per the algorithm defined below, the script MUST fail and terminate immediately.\n+\n+<source lang=\"python\">\n+def target_outputs_hash(vout: [CTxOut]) -> bytes:\n+    return hash256(b\"\".join(serialize_txout(out) for out in vout))\n+\n+def serialize_txout(txo: CTxOut) -> bytes:\n+    spk: bytes = txo.scriptPubKey\n+    return struct.pack(\"<q\", txo.nValue) + ser_compact_size(len(spk)) + spk\n+</source>\n+\n+If the above conditions do not fail, a single true value (<code>0x01</code>) is pushed to the stack.\n+\n+== Policy changes ==\n+\n+In order to prevent possible pinning attacks, recovery transactions must be replaceable.\n+\n+* When validating an <code>OP_VAULT</code>/<code>OP_UNVAULT</code> input being spent towards a recovery, the script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], nor\n+*# the version of the recovery transaction has an nVersion equal to 3.\n+\n+In order to prevent pinning attacks in the case of unauthorized recovery, the output structure of unauthorized recovery\n+transaction is limited.\n+\n+* If <code><recovery-auth-sPK></code> (as determined from <code><recovery-params></code>) is null, the recovery transaction MUST (by policy) abide by the following constraints:\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output not the recovery output is not an ephemeral anchor, the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+== Implementation ==\n+\n+A sample implementation is available [https://github.com/jamesob/bitcoin/tree/2023-01-opvault here], with an associated [https://github.com/bitcoin/bitcoin/pull/26857 pull request].\n+\n+\n+== End use ==\n+\n+=== Creating an <code>OP_VAULT</code> output ===\n+\n+In order to vault coins, they must be spent into a witness v1<ref>'''Can <code>OP_VAULT</code> be used with a future witness version (greater than 1)?''' Yes, however use of yet to be defined witness versions is discouraged, since such a usage makes the coins spendable by anyone.</ref> <code>scriptPubKey</code> \n+that contains a Tapscript spending condition of the form\n+\n+<source>\n+<recovery-params> <spend-delay> <trigger-sPK-hash> OP_VAULT\n+</source>\n+\n+Typically, the internal key for the vault taproot output will be specified so\n+that it is controlled by the same descriptor as the recovery path, which\n+facilitates another (though probably unused) means of recovering the vault\n+output to the recovery path. This has the potential advantage of recovering the\n+coin without ever revealing it was a vault. \n+\n+Otherwise, the internal key can be chosen to be an unspendable NUMS point to\n+force tapscript execution of the <code>OP_VAULT</code> specification.\n+\n+\n+=== Recovery authorization ===\n+\n+When configuring a vault, the user must decide if they want to have the recovery process gated by the optional recovery authorization scriptPubKey. The choice is left to the user because it entails trade-offs.\n+\n+==== Unauthorized recovery ====\n+\n+Unauthorized recovery simplifies vault use in that recovery never requires additional information aside from the location of the vault outpoints and the recovery path - the \"authorization\" is simply the reveal of the recovery path. \n+\n+But because this reveal is the only authorization necessary to spend the vault coins to recovery, the user must expect to recover all such vaults at once, since an observer can replay this recovery (provided they know the outpoints).\n+\n+Additionally, unauthorized recovery across multiple distinct recovery paths cannot be batched, and fee control is more constrained: because the output structure is limited for unauthorized recovery, fee management relies either on inputs which are completely spent to fees or the use of the optional ephemeral anchor and package relay.\n+\n+==== Authorized recovery ====\n+\n+With authorized recovery, the user must keep track of an additional piece of information: how to solve the recovery authorization scriptPubKey when recovery is required. If this key is lost, the user will be unable to initiate the recovery process for their coins. If an attacker obtains the recovery key, they may grief the user during the recovery process by constructing a low fee rate recovery transaction and broadcasting it (though they will not be able to pin because of the replaceability requirement on recovery transactions).\n+\n+However, authorized recovery configurations have significant benefits. Batched recoveries are possible for vaults with otherwise incompatible recovery parameters. Fee management is much more flexible, since authorized recovery transactions are \"free form\" and unrelated inputs and outputs can be added, potentially to handle fees.\n+\n+==== Recommendation: use a simple, offline recovery authorization key seed ====\n+\n+The benefits of batching and fee management that authorized recovery provides are significant. If the recovery authorization key falls into the hands of an attacker, the outcome is not catastrophic, whereas if the user loses their recovery authorization key as well as their trigger key, the result is likely coin loss. Consequently, the author's recommendation is to use a simple seed for the recovery authorization key that can be written down offline and replicated. \n+\n+Note that the recovery authorization key '''is not''' the recovery path key, and\n+this is '''much different''' than any recommendation on how to generate the\n+recovery path key itself.\n+\n+=== Address reuse and recovery ===\n+\n+When creating a vault, four factors affect the resulting P2TR address:\n+# The internal key (likely belonging to the recovery wallet)\n+# The recovery parameters\n+# The spend delay\n+# The trigger scriptPubKey\n+\n+Aside from the spend delay, the end user has the option of varying the other three parameters along descriptors in order to avoid reusing vault addresses without affecting key management.\n+\n+Worth noting is that when using unauthorized recovery, the reveal of the recovery scriptPubKey will allow any observer to initiate the recovery process for any vault with matching recovery params, provided they are able to locate the vault outpoints. As a result, it is recommended to expect that '''all outputs sharing an identical unauthorized <code><recovery-params></code> should be recovered together'''.\n+\n+This situation can be avoided with a comparable key management model by varying the generation of each vault's recovery scriptPubKey along a single descriptor, but note that (when configured for unauthorized recovery), this will prevent batched recovery.\n+\n+==== Recommendation: vary the internal key ====\n+\n+The recommended mode of use is to keep recovery parameters identical across vaults which should be recovered in batch, but vary the internal key for each vault output along a single descriptor so that no address reuse is necessary.\n+\n+==== Recommendation: generate new recovery addresses for new trigger keys ====\n+\n+If using unauthorized recovery, it is recommended that you do not share literal recovery paths\n+across separate trigger keys. If one trigger key is compromised, that will necessitate the (unauthorized)\n+recovery of all vaults with that trigger key, which will reveal the recovery path preimage. This\n+means that an observer might be able to initiate recovery for vaults controlled by an uncompromised\n+trigger key.\n+\n+==== Fee management ====\n+\n+Fees can be managed in a variety of ways, but it's worth noting that both trigger and recovery transactions must preserve the total value of vault inputs, so vaulted values cannot be repurposed to pay for fees. This does not apply to the withdrawal transaction, which can allocate value arbitrarily.\n+\n+In the case of vaults that use recovery authorization, all transactions can \"bring their own fees\" in the form of unrelated inputs and outputs. These transactions are also free to specify ephemeral anchors, once the related relay policies are deployed. This means that vaults using recovery authorization have no dependence on the deploy of v3 relay policy.\n+\n+In the case of vaults that do not use recovery authorization, the recovery transaction relies on the use of either fully-spent fee inputs or an ephemeral anchor output. This means that vaults which do not use recovery authorization are essentially dependent on v3 transaction relay policy being deployed.\n+\n+==== Mixing input types ====\n+\n+<code>OP_VAULT</code>/<code>OP_UNVAULT</code> outputs can be spent\n+into a recovery transaction together. Script execution works identically for\n+both types of outputs.\n+\n+[[File:bip-VAULT/batch-sweep.drawio.png|frame|center]]\n+\n+\n+=== Batching ===\n+\n+==== During trigger ====\n+\n+<code>OP_VAULT</code> outputs with the same recovery-params and spend-delay can\n+be triggered into the same <code>OP_UNVAULT</code> output, creating a batched\n+withdrawal trigger. This is allowed regardless of the\n+<code><trigger-sPK-hash></code> values of each input, allowing the trigger keys\n+to differ.\n+\n+Trigger transactions can act on multiple incompatible <code>OP_VAULT</code>\n+input sets, provided each set has a suitable associated <code>OP_UNVAULT</code>\n+output.\n+\n+Since <code>SIGHASH_DEFAULT</code> can be used to sign the trigger\n+authorization, unrelated inputs and outputs can be included, possibly to\n+facilitate fee management or the batch withdrawal of incompatible vaults.\n+\n+==== During withdrawal ====\n+\n+During final withdrawal, multiple unrelated <code>OP_UNVAULT</code> outputs can\n+be used towards the same withdrawal transaction provided that they share\n+identical <code><target-outputs-hash></code> parameters. This facilitates\n+batched withdrawals.\n+\n+==== During recovery ====\n+\n+<code>OP_VAULT</code>/<code>OP_UNVAULT</code> outputs with the same recovery\n+scriptPubKey hash can be recovered into the same output.\n+\n+Recovery-incompatible vaults which have authorized recovery can be recovered in\n+the same transaction, so long as each set (grouped by recovery scriptPubKey\n+hash) has a suitable associated recovery output. This means that unrelated\n+recoveries controlled by the same owner can benefit from sharing common fee\n+management.\n+\n+=== Watchtowers ===\n+\n+The value of vaults is contingent upon having monitoring in place that will alert the owner when unexpected spends are taking place. This can be done in a variety of ways, with varying degrees of automation and trust in the watchtower.\n+\n+In the maximum-trust case, the watchtower can be fully aware of all vaulted coins and has the means to initiate the recovery process if spends are not pre-reported to the watchtower.\n+\n+In the minimum-trust case, the user can supply a probabilistic filter of which coins they wish to monitor; the watchtower would then alert the user if any coins matching the filter move, and the user would be responsible for ignoring false positives and handling recovery initiation.\n+\n+=== Script descriptors ===\n+\n+Script descriptors for vault-related outputs will be covered in a subsequent BIP.\n+\n+\n+== Deployment ==\n+\n+It is anticipated that deployment would happen in the same way [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Deployment that BIP-0341 was deployed]. Parameters to be determined.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 636,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "0204c9a1f9a9075f2483450f1bab034d453270b7",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Taproot was activated by BIP 343, not the linked section of 341 which lacked community support at the time, and negative sentiment toward has only grown since. Attempting to use \"speedy trial\" or BIP 9 is an attack on Bitcoin.",
      "created_at": "2023-02-21T17:02:57Z",
      "updated_at": "2023-02-21T17:02:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1113342807",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113342807"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 636,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113541997",
      "pull_request_review_id": 1308127194,
      "id": 1113541997,
      "node_id": "PRRC_kwDOAN28mc5CX01t",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output<ref>Because the trigger scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.</ref>\n+** <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash''<ref>Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.</ref>, committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", <recovery-sPK>)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction, referred to as <code><recovery-auth-sPK></code>. \n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than or equal to this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the <code><recovery-auth-sPK></code> witness program, if any.\n+\n+* If <code><recovery-auth-sPK></code> is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+==== <code>OP_VAULT</code> evaluation for withdrawal trigger ====\n+\n+Else, if it has been determined that the spend is not within a recovery\n+transaction, it must be evaluated for eligibility as a withdrawal trigger\n+spend.\n+\n+===== Witness stack =====\n+\n+There must be at least 4 items on the stack (shown top to bottom):\n+\n+<source>\n+<trigger-vout-idx>\n+<target-outputs-hash>\n+<trigger-sPK>\n+<trigger witness stack item 1> [...] <item n>\n+</source>\n+\n+If the witness stack consists of fewer than four items the script MUST fail and\n+terminate immediately.\n+\n+(Note: in practice, the witness stack will have included the other items necessary to reveal \n+a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)\n+\n+The items on the stack must be validated as follows:\n+\n+* <code><trigger-vout-idx></code> is a <code>CScriptNum</code> of up to 4 bytes.\n+** It indicates the vout index of this input's corresponding <code>OP_UNVAULT</code> output.\n+*** Validation rules for this output are described below.\n+** If this value does not decode as a valid CScriptNum value, the script MUST fail and terminate immediately.\n+** If this value does not correspond to a valid output in the spending transaction, the script MUST fail and terminate immediately.\n+\n+* <code><target-outputs-hash></code> is a 32 byte data push.\n+** It is the hash of the proposed withdrawal target output set, defined by <code>target_outputs_hash(outputs)</code> below. Note that this value is duplicated here.<ref>'''Why, when spending an OP_VAULT output into a trigger, does the target hash need to be duplicated on the witness stack?''' The target hash exists in the <code>OP_UNVAULT</code> output script, likely behind a taproot pubkey. Its presence is required on the witness stack also so that the expected taproot pubkey for the <code>OP_UNVAULT</code> output can be constructed for comparison.</ref>\n+** If this value is not 32 bytes, the script MUST fail and terminate immediately.\n+\n+* <code><trigger-sPK></code> is a variable length data push.\n+** It must be the scriptPubKey that is the preimage to the <code><trigger-sPK-hash></code> specified in the spent <code>OP_VAULT</code> input.\n+** If this value does not tagged-hash to <code><trigger-sPK-hash></code> supplied by the <code>OP_VAULT</code> parameter, the script MUST fail and terminate immediately.\n+*** Verify <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>) == <trigger-sPK-hash></code>\n+** If this value does not correspond to a valid witness program, the script MUST fail and terminate immediately.\n+\n+* the remaining elements serve as the witness stack to satisfy the <code><trigger-sPK></code> witness program.\n+** If <code>VerifyWitnessProgram(<remaining stack elements>, <trigger-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the withdrawal trigger has been authorized.)\n+\n+===== Transaction outputs validation =====\n+\n+Once the contents of the witness stack have been parsed and validated, the transaction outputs must be checked.\n+\n+First, we must check for a ''revault output'': an output in the trigger transaction whose\n+scriptPubKey exactly matches that of the <code>OP_VAULT</code> input being\n+spent. Its presence is optional.\n+\n+For each vault input citing a particular <code><trigger-vout-idx></code>, the output \n+located at <code>vout[<trigger-vout-idx>]</code> (the \"trigger output\") must:\n+\n+* have as its scriptPubKey a witness program with a single <code>OP_UNVAULT</code> tapscript, having the internal x-only key <code>0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code>, per the NUMS point mentioned in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP-0341].<ref>'''Why must the OP_UNVAULT taproot use a predefined NUMS point as its internal key?''' This ensures that an OP_UNVAULT trigger output is verifiable as expected. It also ensures that it is spendable only by the conditions of the vault.</ref>\n+** If the witness program has a version less than 1, the script MUST fail and terminate immediately.\n+** If the witness program has a version greater than 1, the script MUST succeed to enable upgradeability.\n+** If the witness program has a version of 1 and the scriptPubKey of the output does not match the expected scriptPubKey, as computed by creating a taproot output using the cited NUMS point and a single tapscript spend condition of the form<br /><code><recovery-params-from-stack> <spend-delay-from-stack> <target-outputs-hash-from-stack> OP_UNVAULT</code>,<br />the script MUST fail and terminate immediately.\n+** Witness versions greater than 1 are allowed for upgradeability.\n+\n+* If there does not exist a revault output in the transaction for this input:\n+** (deferred) the <code>nValue</code> of the trigger output must equal the sum of all vault inputs which cite it as their corresponding trigger output.\n+*** If these values are not equal, the script MUST fail and terminate immediately.\n+* else (if there does exist a revault output for this input):\n+** (deferred) the <code>nValue</code>s of the trigger output and the revault output must sum to the sum of all vault inputs which both \n+*** cite this trigger output as the trigger-vout-idx and \n+*** have a scriptPubKey identical to the revault output's.\n+** If these values are not equal, the script MUST fail and terminate immediately.\n+\n+If none of the conditions above results in a failure of the script interpreter, the \n+stack will consist of a single true value (<code>0x01</code>).\n+\n+The above amount check can be expressed in Python as:\n+\n+<source lang=\"python\">\n+\n+spending_tx: CTransaction\n+vault_inputs: [CTxIn] = [inp for inp in spending_tx.vin if inp.is_OP_VAULT]\n+\n+\"Where we'll accumulate the expected totals for each vault input.\"\n+vault_totals_for_outputs: dict[(int, int), int] = defaultdict(0)\n+\n+\"Build the expected totals.\"\n+for vault_in in vault_inputs:\n+    maybe_revault_idx = find_revault_for_vault(vault_in)\n+    vault_total_for_outputs[(vault_in.trigger_vout_idx, maybe_revault_idx)] += vault_in.nValue\n+\n+\n+\"Check the expected totals against outputs.\"\n+for (out_idx, maybe_revault_idx), expected_amount in vault_totals_for_outputs.items():\n+    total = spending_tx.vout[out_idx].nValue\n+\n+    if maybe_revault_idx:\n+        total += spending_tx.vout[maybe_revault_idx]\n+\n+    if total != expected_amount:\n+        FAIL_AND_TERMINATE_SCRIPT()\n+    \n+    \n+def find_revault_for_vault(vault_in) -> int:\n+    \"\"\"Find the index of a revault output for a particular vault input, if one exists.\"\"\"\n+    for i, out in enumerate(spending_tx.vout):\n+        if out.scriptPubKey == vault_in.scriptPubKey:\n+            return i\n+    return None\n+</source>\n+\n+=== <code>OP_UNVAULT</code> evaulation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_UNVAULT</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbc</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_UNVAULT             (*) being evaluated\n+<target-outputs-hash>\n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><recovery-params></code> is validated exactly as described in [[#witness-program|the above <code>OP_VAULT</code> section]].\n+* <code><spend-delay></code> is validated exactly as described in [[#witness-program|the above <code>OP_VAULT</code> section]].\n+* <code><target-output-hash></code> is a 32 byte data push.\n+** If it is not equal to 32 bytes, the script MUST fail and terminate immediately.\n+\n+\n+==== Check for recovery ====\n+\n+A check is performed to determine if this input is being spent within the context of\n+a recovery transaction, exactly as in [[#check-for-recovery|the <code>OP_VAULT</code> evaluation described above]].\n+\n+\n+==== <code>OP_UNVAULT</code> evaluation for recovery spend ====\n+\n+This is identical to the [[#op_vault-evaluation-for-recovery-spend|<code>OP_VAULT</code> case described above]].\n+\n+\n+==== <code>OP_UNVAULT</code> evaluation for withdrawal ====\n+\n+When spending an <code>OP_UNVAULT</code> input into a withdrawal target, no witness stack is required.\n+\n+* <code><spend-delay></code> is used to check whether the withdrawal of the input has matured.\n+** If the input's relative timelock check, as described in [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP-0112] (using this value as \"the top item on the stack\") fails, the script MUST fail and terminate immediately.\n+*** The same <code>CheckSequence(<spend-delay>)</code> code path is used as for [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP-0112].\n+\n+* The transaction outputs are then checked to verify that the withdrawal outputs are as expected.\n+** If <code>target_outputs_hash(spending_tx.vout) != <target-output-hash></code> per the algorithm defined below, the script MUST fail and terminate immediately.\n+\n+<source lang=\"python\">\n+def target_outputs_hash(vout: [CTxOut]) -> bytes:\n+    return hash256(b\"\".join(serialize_txout(out) for out in vout))\n+\n+def serialize_txout(txo: CTxOut) -> bytes:\n+    spk: bytes = txo.scriptPubKey\n+    return struct.pack(\"<q\", txo.nValue) + ser_compact_size(len(spk)) + spk\n+</source>\n+\n+If the above conditions do not fail, a single true value (<code>0x01</code>) is pushed to the stack.\n+\n+== Policy changes ==\n+\n+In order to prevent possible pinning attacks, recovery transactions must be replaceable.\n+\n+* When validating an <code>OP_VAULT</code>/<code>OP_UNVAULT</code> input being spent towards a recovery, the script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], nor\n+*# the version of the recovery transaction has an nVersion equal to 3.\n+\n+In order to prevent pinning attacks in the case of unauthorized recovery, the output structure of unauthorized recovery\n+transaction is limited.\n+\n+* If <code><recovery-auth-sPK></code> (as determined from <code><recovery-params></code>) is null, the recovery transaction MUST (by policy) abide by the following constraints:\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output not the recovery output is not an ephemeral anchor, the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+== Implementation ==\n+\n+A sample implementation is available [https://github.com/jamesob/bitcoin/tree/2023-01-opvault here], with an associated [https://github.com/bitcoin/bitcoin/pull/26857 pull request].\n+\n+\n+== End use ==\n+\n+=== Creating an <code>OP_VAULT</code> output ===\n+\n+In order to vault coins, they must be spent into a witness v1<ref>'''Can <code>OP_VAULT</code> be used with a future witness version (greater than 1)?''' Yes, however use of yet to be defined witness versions is discouraged, since such a usage makes the coins spendable by anyone.</ref> <code>scriptPubKey</code> \n+that contains a Tapscript spending condition of the form\n+\n+<source>\n+<recovery-params> <spend-delay> <trigger-sPK-hash> OP_VAULT\n+</source>\n+\n+Typically, the internal key for the vault taproot output will be specified so\n+that it is controlled by the same descriptor as the recovery path, which\n+facilitates another (though probably unused) means of recovering the vault\n+output to the recovery path. This has the potential advantage of recovering the\n+coin without ever revealing it was a vault. \n+\n+Otherwise, the internal key can be chosen to be an unspendable NUMS point to\n+force tapscript execution of the <code>OP_VAULT</code> specification.\n+\n+\n+=== Recovery authorization ===\n+\n+When configuring a vault, the user must decide if they want to have the recovery process gated by the optional recovery authorization scriptPubKey. The choice is left to the user because it entails trade-offs.\n+\n+==== Unauthorized recovery ====\n+\n+Unauthorized recovery simplifies vault use in that recovery never requires additional information aside from the location of the vault outpoints and the recovery path - the \"authorization\" is simply the reveal of the recovery path. \n+\n+But because this reveal is the only authorization necessary to spend the vault coins to recovery, the user must expect to recover all such vaults at once, since an observer can replay this recovery (provided they know the outpoints).\n+\n+Additionally, unauthorized recovery across multiple distinct recovery paths cannot be batched, and fee control is more constrained: because the output structure is limited for unauthorized recovery, fee management relies either on inputs which are completely spent to fees or the use of the optional ephemeral anchor and package relay.\n+\n+==== Authorized recovery ====\n+\n+With authorized recovery, the user must keep track of an additional piece of information: how to solve the recovery authorization scriptPubKey when recovery is required. If this key is lost, the user will be unable to initiate the recovery process for their coins. If an attacker obtains the recovery key, they may grief the user during the recovery process by constructing a low fee rate recovery transaction and broadcasting it (though they will not be able to pin because of the replaceability requirement on recovery transactions).\n+\n+However, authorized recovery configurations have significant benefits. Batched recoveries are possible for vaults with otherwise incompatible recovery parameters. Fee management is much more flexible, since authorized recovery transactions are \"free form\" and unrelated inputs and outputs can be added, potentially to handle fees.\n+\n+==== Recommendation: use a simple, offline recovery authorization key seed ====\n+\n+The benefits of batching and fee management that authorized recovery provides are significant. If the recovery authorization key falls into the hands of an attacker, the outcome is not catastrophic, whereas if the user loses their recovery authorization key as well as their trigger key, the result is likely coin loss. Consequently, the author's recommendation is to use a simple seed for the recovery authorization key that can be written down offline and replicated. \n+\n+Note that the recovery authorization key '''is not''' the recovery path key, and\n+this is '''much different''' than any recommendation on how to generate the\n+recovery path key itself.\n+\n+=== Address reuse and recovery ===\n+\n+When creating a vault, four factors affect the resulting P2TR address:\n+# The internal key (likely belonging to the recovery wallet)\n+# The recovery parameters\n+# The spend delay\n+# The trigger scriptPubKey\n+\n+Aside from the spend delay, the end user has the option of varying the other three parameters along descriptors in order to avoid reusing vault addresses without affecting key management.\n+\n+Worth noting is that when using unauthorized recovery, the reveal of the recovery scriptPubKey will allow any observer to initiate the recovery process for any vault with matching recovery params, provided they are able to locate the vault outpoints. As a result, it is recommended to expect that '''all outputs sharing an identical unauthorized <code><recovery-params></code> should be recovered together'''.\n+\n+This situation can be avoided with a comparable key management model by varying the generation of each vault's recovery scriptPubKey along a single descriptor, but note that (when configured for unauthorized recovery), this will prevent batched recovery.\n+\n+==== Recommendation: vary the internal key ====\n+\n+The recommended mode of use is to keep recovery parameters identical across vaults which should be recovered in batch, but vary the internal key for each vault output along a single descriptor so that no address reuse is necessary.\n+\n+==== Recommendation: generate new recovery addresses for new trigger keys ====\n+\n+If using unauthorized recovery, it is recommended that you do not share literal recovery paths\n+across separate trigger keys. If one trigger key is compromised, that will necessitate the (unauthorized)\n+recovery of all vaults with that trigger key, which will reveal the recovery path preimage. This\n+means that an observer might be able to initiate recovery for vaults controlled by an uncompromised\n+trigger key.\n+\n+==== Fee management ====\n+\n+Fees can be managed in a variety of ways, but it's worth noting that both trigger and recovery transactions must preserve the total value of vault inputs, so vaulted values cannot be repurposed to pay for fees. This does not apply to the withdrawal transaction, which can allocate value arbitrarily.\n+\n+In the case of vaults that use recovery authorization, all transactions can \"bring their own fees\" in the form of unrelated inputs and outputs. These transactions are also free to specify ephemeral anchors, once the related relay policies are deployed. This means that vaults using recovery authorization have no dependence on the deploy of v3 relay policy.\n+\n+In the case of vaults that do not use recovery authorization, the recovery transaction relies on the use of either fully-spent fee inputs or an ephemeral anchor output. This means that vaults which do not use recovery authorization are essentially dependent on v3 transaction relay policy being deployed.\n+\n+==== Mixing input types ====\n+\n+<code>OP_VAULT</code>/<code>OP_UNVAULT</code> outputs can be spent\n+into a recovery transaction together. Script execution works identically for\n+both types of outputs.\n+\n+[[File:bip-VAULT/batch-sweep.drawio.png|frame|center]]\n+\n+\n+=== Batching ===\n+\n+==== During trigger ====\n+\n+<code>OP_VAULT</code> outputs with the same recovery-params and spend-delay can\n+be triggered into the same <code>OP_UNVAULT</code> output, creating a batched\n+withdrawal trigger. This is allowed regardless of the\n+<code><trigger-sPK-hash></code> values of each input, allowing the trigger keys\n+to differ.\n+\n+Trigger transactions can act on multiple incompatible <code>OP_VAULT</code>\n+input sets, provided each set has a suitable associated <code>OP_UNVAULT</code>\n+output.\n+\n+Since <code>SIGHASH_DEFAULT</code> can be used to sign the trigger\n+authorization, unrelated inputs and outputs can be included, possibly to\n+facilitate fee management or the batch withdrawal of incompatible vaults.\n+\n+==== During withdrawal ====\n+\n+During final withdrawal, multiple unrelated <code>OP_UNVAULT</code> outputs can\n+be used towards the same withdrawal transaction provided that they share\n+identical <code><target-outputs-hash></code> parameters. This facilitates\n+batched withdrawals.\n+\n+==== During recovery ====\n+\n+<code>OP_VAULT</code>/<code>OP_UNVAULT</code> outputs with the same recovery\n+scriptPubKey hash can be recovered into the same output.\n+\n+Recovery-incompatible vaults which have authorized recovery can be recovered in\n+the same transaction, so long as each set (grouped by recovery scriptPubKey\n+hash) has a suitable associated recovery output. This means that unrelated\n+recoveries controlled by the same owner can benefit from sharing common fee\n+management.\n+\n+=== Watchtowers ===\n+\n+The value of vaults is contingent upon having monitoring in place that will alert the owner when unexpected spends are taking place. This can be done in a variety of ways, with varying degrees of automation and trust in the watchtower.\n+\n+In the maximum-trust case, the watchtower can be fully aware of all vaulted coins and has the means to initiate the recovery process if spends are not pre-reported to the watchtower.\n+\n+In the minimum-trust case, the user can supply a probabilistic filter of which coins they wish to monitor; the watchtower would then alert the user if any coins matching the filter move, and the user would be responsible for ignoring false positives and handling recovery initiation.\n+\n+=== Script descriptors ===\n+\n+Script descriptors for vault-related outputs will be covered in a subsequent BIP.\n+\n+\n+== Deployment ==\n+\n+It is anticipated that deployment would happen in the same way [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Deployment that BIP-0341 was deployed]. Parameters to be determined.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 636,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "0204c9a1f9a9075f2483450f1bab034d453270b7",
      "in_reply_to_id": 1113342807,
      "user": {
        "login": "harding",
        "id": 61096,
        "node_id": "MDQ6VXNlcjYxMDk2",
        "avatar_url": "https://avatars.githubusercontent.com/u/61096?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/harding",
        "html_url": "https://github.com/harding",
        "followers_url": "https://api.github.com/users/harding/followers",
        "following_url": "https://api.github.com/users/harding/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/harding/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/harding/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/harding/subscriptions",
        "organizations_url": "https://api.github.com/users/harding/orgs",
        "repos_url": "https://api.github.com/users/harding/repos",
        "events_url": "https://api.github.com/users/harding/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/harding/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would you refuse to merge this PR because you think it is in error and proposes an attack on Bitcoin?",
      "created_at": "2023-02-21T20:37:07Z",
      "updated_at": "2023-02-21T20:37:07Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1113541997",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113541997"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 636,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113564174",
      "pull_request_review_id": 1308160249,
      "id": 1113564174,
      "node_id": "PRRC_kwDOAN28mc5CX6QO",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output<ref>Because the trigger scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.</ref>\n+** <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash''<ref>Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.</ref>, committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", <recovery-sPK>)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction, referred to as <code><recovery-auth-sPK></code>. \n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than or equal to this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the <code><recovery-auth-sPK></code> witness program, if any.\n+\n+* If <code><recovery-auth-sPK></code> is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+==== <code>OP_VAULT</code> evaluation for withdrawal trigger ====\n+\n+Else, if it has been determined that the spend is not within a recovery\n+transaction, it must be evaluated for eligibility as a withdrawal trigger\n+spend.\n+\n+===== Witness stack =====\n+\n+There must be at least 4 items on the stack (shown top to bottom):\n+\n+<source>\n+<trigger-vout-idx>\n+<target-outputs-hash>\n+<trigger-sPK>\n+<trigger witness stack item 1> [...] <item n>\n+</source>\n+\n+If the witness stack consists of fewer than four items the script MUST fail and\n+terminate immediately.\n+\n+(Note: in practice, the witness stack will have included the other items necessary to reveal \n+a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)\n+\n+The items on the stack must be validated as follows:\n+\n+* <code><trigger-vout-idx></code> is a <code>CScriptNum</code> of up to 4 bytes.\n+** It indicates the vout index of this input's corresponding <code>OP_UNVAULT</code> output.\n+*** Validation rules for this output are described below.\n+** If this value does not decode as a valid CScriptNum value, the script MUST fail and terminate immediately.\n+** If this value does not correspond to a valid output in the spending transaction, the script MUST fail and terminate immediately.\n+\n+* <code><target-outputs-hash></code> is a 32 byte data push.\n+** It is the hash of the proposed withdrawal target output set, defined by <code>target_outputs_hash(outputs)</code> below. Note that this value is duplicated here.<ref>'''Why, when spending an OP_VAULT output into a trigger, does the target hash need to be duplicated on the witness stack?''' The target hash exists in the <code>OP_UNVAULT</code> output script, likely behind a taproot pubkey. Its presence is required on the witness stack also so that the expected taproot pubkey for the <code>OP_UNVAULT</code> output can be constructed for comparison.</ref>\n+** If this value is not 32 bytes, the script MUST fail and terminate immediately.\n+\n+* <code><trigger-sPK></code> is a variable length data push.\n+** It must be the scriptPubKey that is the preimage to the <code><trigger-sPK-hash></code> specified in the spent <code>OP_VAULT</code> input.\n+** If this value does not tagged-hash to <code><trigger-sPK-hash></code> supplied by the <code>OP_VAULT</code> parameter, the script MUST fail and terminate immediately.\n+*** Verify <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>) == <trigger-sPK-hash></code>\n+** If this value does not correspond to a valid witness program, the script MUST fail and terminate immediately.\n+\n+* the remaining elements serve as the witness stack to satisfy the <code><trigger-sPK></code> witness program.\n+** If <code>VerifyWitnessProgram(<remaining stack elements>, <trigger-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the withdrawal trigger has been authorized.)\n+\n+===== Transaction outputs validation =====\n+\n+Once the contents of the witness stack have been parsed and validated, the transaction outputs must be checked.\n+\n+First, we must check for a ''revault output'': an output in the trigger transaction whose\n+scriptPubKey exactly matches that of the <code>OP_VAULT</code> input being\n+spent. Its presence is optional.\n+\n+For each vault input citing a particular <code><trigger-vout-idx></code>, the output \n+located at <code>vout[<trigger-vout-idx>]</code> (the \"trigger output\") must:\n+\n+* have as its scriptPubKey a witness program with a single <code>OP_UNVAULT</code> tapscript, having the internal x-only key <code>0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code>, per the NUMS point mentioned in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP-0341].<ref>'''Why must the OP_UNVAULT taproot use a predefined NUMS point as its internal key?''' This ensures that an OP_UNVAULT trigger output is verifiable as expected. It also ensures that it is spendable only by the conditions of the vault.</ref>\n+** If the witness program has a version less than 1, the script MUST fail and terminate immediately.\n+** If the witness program has a version greater than 1, the script MUST succeed to enable upgradeability.\n+** If the witness program has a version of 1 and the scriptPubKey of the output does not match the expected scriptPubKey, as computed by creating a taproot output using the cited NUMS point and a single tapscript spend condition of the form<br /><code><recovery-params-from-stack> <spend-delay-from-stack> <target-outputs-hash-from-stack> OP_UNVAULT</code>,<br />the script MUST fail and terminate immediately.\n+** Witness versions greater than 1 are allowed for upgradeability.\n+\n+* If there does not exist a revault output in the transaction for this input:\n+** (deferred) the <code>nValue</code> of the trigger output must equal the sum of all vault inputs which cite it as their corresponding trigger output.\n+*** If these values are not equal, the script MUST fail and terminate immediately.\n+* else (if there does exist a revault output for this input):\n+** (deferred) the <code>nValue</code>s of the trigger output and the revault output must sum to the sum of all vault inputs which both \n+*** cite this trigger output as the trigger-vout-idx and \n+*** have a scriptPubKey identical to the revault output's.\n+** If these values are not equal, the script MUST fail and terminate immediately.\n+\n+If none of the conditions above results in a failure of the script interpreter, the \n+stack will consist of a single true value (<code>0x01</code>).\n+\n+The above amount check can be expressed in Python as:\n+\n+<source lang=\"python\">\n+\n+spending_tx: CTransaction\n+vault_inputs: [CTxIn] = [inp for inp in spending_tx.vin if inp.is_OP_VAULT]\n+\n+\"Where we'll accumulate the expected totals for each vault input.\"\n+vault_totals_for_outputs: dict[(int, int), int] = defaultdict(0)\n+\n+\"Build the expected totals.\"\n+for vault_in in vault_inputs:\n+    maybe_revault_idx = find_revault_for_vault(vault_in)\n+    vault_total_for_outputs[(vault_in.trigger_vout_idx, maybe_revault_idx)] += vault_in.nValue\n+\n+\n+\"Check the expected totals against outputs.\"\n+for (out_idx, maybe_revault_idx), expected_amount in vault_totals_for_outputs.items():\n+    total = spending_tx.vout[out_idx].nValue\n+\n+    if maybe_revault_idx:\n+        total += spending_tx.vout[maybe_revault_idx]\n+\n+    if total != expected_amount:\n+        FAIL_AND_TERMINATE_SCRIPT()\n+    \n+    \n+def find_revault_for_vault(vault_in) -> int:\n+    \"\"\"Find the index of a revault output for a particular vault input, if one exists.\"\"\"\n+    for i, out in enumerate(spending_tx.vout):\n+        if out.scriptPubKey == vault_in.scriptPubKey:\n+            return i\n+    return None\n+</source>\n+\n+=== <code>OP_UNVAULT</code> evaulation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_UNVAULT</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbc</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_UNVAULT             (*) being evaluated\n+<target-outputs-hash>\n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><recovery-params></code> is validated exactly as described in [[#witness-program|the above <code>OP_VAULT</code> section]].\n+* <code><spend-delay></code> is validated exactly as described in [[#witness-program|the above <code>OP_VAULT</code> section]].\n+* <code><target-output-hash></code> is a 32 byte data push.\n+** If it is not equal to 32 bytes, the script MUST fail and terminate immediately.\n+\n+\n+==== Check for recovery ====\n+\n+A check is performed to determine if this input is being spent within the context of\n+a recovery transaction, exactly as in [[#check-for-recovery|the <code>OP_VAULT</code> evaluation described above]].\n+\n+\n+==== <code>OP_UNVAULT</code> evaluation for recovery spend ====\n+\n+This is identical to the [[#op_vault-evaluation-for-recovery-spend|<code>OP_VAULT</code> case described above]].\n+\n+\n+==== <code>OP_UNVAULT</code> evaluation for withdrawal ====\n+\n+When spending an <code>OP_UNVAULT</code> input into a withdrawal target, no witness stack is required.\n+\n+* <code><spend-delay></code> is used to check whether the withdrawal of the input has matured.\n+** If the input's relative timelock check, as described in [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP-0112] (using this value as \"the top item on the stack\") fails, the script MUST fail and terminate immediately.\n+*** The same <code>CheckSequence(<spend-delay>)</code> code path is used as for [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP-0112].\n+\n+* The transaction outputs are then checked to verify that the withdrawal outputs are as expected.\n+** If <code>target_outputs_hash(spending_tx.vout) != <target-output-hash></code> per the algorithm defined below, the script MUST fail and terminate immediately.\n+\n+<source lang=\"python\">\n+def target_outputs_hash(vout: [CTxOut]) -> bytes:\n+    return hash256(b\"\".join(serialize_txout(out) for out in vout))\n+\n+def serialize_txout(txo: CTxOut) -> bytes:\n+    spk: bytes = txo.scriptPubKey\n+    return struct.pack(\"<q\", txo.nValue) + ser_compact_size(len(spk)) + spk\n+</source>\n+\n+If the above conditions do not fail, a single true value (<code>0x01</code>) is pushed to the stack.\n+\n+== Policy changes ==\n+\n+In order to prevent possible pinning attacks, recovery transactions must be replaceable.\n+\n+* When validating an <code>OP_VAULT</code>/<code>OP_UNVAULT</code> input being spent towards a recovery, the script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], nor\n+*# the version of the recovery transaction has an nVersion equal to 3.\n+\n+In order to prevent pinning attacks in the case of unauthorized recovery, the output structure of unauthorized recovery\n+transaction is limited.\n+\n+* If <code><recovery-auth-sPK></code> (as determined from <code><recovery-params></code>) is null, the recovery transaction MUST (by policy) abide by the following constraints:\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output not the recovery output is not an ephemeral anchor, the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+== Implementation ==\n+\n+A sample implementation is available [https://github.com/jamesob/bitcoin/tree/2023-01-opvault here], with an associated [https://github.com/bitcoin/bitcoin/pull/26857 pull request].\n+\n+\n+== End use ==\n+\n+=== Creating an <code>OP_VAULT</code> output ===\n+\n+In order to vault coins, they must be spent into a witness v1<ref>'''Can <code>OP_VAULT</code> be used with a future witness version (greater than 1)?''' Yes, however use of yet to be defined witness versions is discouraged, since such a usage makes the coins spendable by anyone.</ref> <code>scriptPubKey</code> \n+that contains a Tapscript spending condition of the form\n+\n+<source>\n+<recovery-params> <spend-delay> <trigger-sPK-hash> OP_VAULT\n+</source>\n+\n+Typically, the internal key for the vault taproot output will be specified so\n+that it is controlled by the same descriptor as the recovery path, which\n+facilitates another (though probably unused) means of recovering the vault\n+output to the recovery path. This has the potential advantage of recovering the\n+coin without ever revealing it was a vault. \n+\n+Otherwise, the internal key can be chosen to be an unspendable NUMS point to\n+force tapscript execution of the <code>OP_VAULT</code> specification.\n+\n+\n+=== Recovery authorization ===\n+\n+When configuring a vault, the user must decide if they want to have the recovery process gated by the optional recovery authorization scriptPubKey. The choice is left to the user because it entails trade-offs.\n+\n+==== Unauthorized recovery ====\n+\n+Unauthorized recovery simplifies vault use in that recovery never requires additional information aside from the location of the vault outpoints and the recovery path - the \"authorization\" is simply the reveal of the recovery path. \n+\n+But because this reveal is the only authorization necessary to spend the vault coins to recovery, the user must expect to recover all such vaults at once, since an observer can replay this recovery (provided they know the outpoints).\n+\n+Additionally, unauthorized recovery across multiple distinct recovery paths cannot be batched, and fee control is more constrained: because the output structure is limited for unauthorized recovery, fee management relies either on inputs which are completely spent to fees or the use of the optional ephemeral anchor and package relay.\n+\n+==== Authorized recovery ====\n+\n+With authorized recovery, the user must keep track of an additional piece of information: how to solve the recovery authorization scriptPubKey when recovery is required. If this key is lost, the user will be unable to initiate the recovery process for their coins. If an attacker obtains the recovery key, they may grief the user during the recovery process by constructing a low fee rate recovery transaction and broadcasting it (though they will not be able to pin because of the replaceability requirement on recovery transactions).\n+\n+However, authorized recovery configurations have significant benefits. Batched recoveries are possible for vaults with otherwise incompatible recovery parameters. Fee management is much more flexible, since authorized recovery transactions are \"free form\" and unrelated inputs and outputs can be added, potentially to handle fees.\n+\n+==== Recommendation: use a simple, offline recovery authorization key seed ====\n+\n+The benefits of batching and fee management that authorized recovery provides are significant. If the recovery authorization key falls into the hands of an attacker, the outcome is not catastrophic, whereas if the user loses their recovery authorization key as well as their trigger key, the result is likely coin loss. Consequently, the author's recommendation is to use a simple seed for the recovery authorization key that can be written down offline and replicated. \n+\n+Note that the recovery authorization key '''is not''' the recovery path key, and\n+this is '''much different''' than any recommendation on how to generate the\n+recovery path key itself.\n+\n+=== Address reuse and recovery ===\n+\n+When creating a vault, four factors affect the resulting P2TR address:\n+# The internal key (likely belonging to the recovery wallet)\n+# The recovery parameters\n+# The spend delay\n+# The trigger scriptPubKey\n+\n+Aside from the spend delay, the end user has the option of varying the other three parameters along descriptors in order to avoid reusing vault addresses without affecting key management.\n+\n+Worth noting is that when using unauthorized recovery, the reveal of the recovery scriptPubKey will allow any observer to initiate the recovery process for any vault with matching recovery params, provided they are able to locate the vault outpoints. As a result, it is recommended to expect that '''all outputs sharing an identical unauthorized <code><recovery-params></code> should be recovered together'''.\n+\n+This situation can be avoided with a comparable key management model by varying the generation of each vault's recovery scriptPubKey along a single descriptor, but note that (when configured for unauthorized recovery), this will prevent batched recovery.\n+\n+==== Recommendation: vary the internal key ====\n+\n+The recommended mode of use is to keep recovery parameters identical across vaults which should be recovered in batch, but vary the internal key for each vault output along a single descriptor so that no address reuse is necessary.\n+\n+==== Recommendation: generate new recovery addresses for new trigger keys ====\n+\n+If using unauthorized recovery, it is recommended that you do not share literal recovery paths\n+across separate trigger keys. If one trigger key is compromised, that will necessitate the (unauthorized)\n+recovery of all vaults with that trigger key, which will reveal the recovery path preimage. This\n+means that an observer might be able to initiate recovery for vaults controlled by an uncompromised\n+trigger key.\n+\n+==== Fee management ====\n+\n+Fees can be managed in a variety of ways, but it's worth noting that both trigger and recovery transactions must preserve the total value of vault inputs, so vaulted values cannot be repurposed to pay for fees. This does not apply to the withdrawal transaction, which can allocate value arbitrarily.\n+\n+In the case of vaults that use recovery authorization, all transactions can \"bring their own fees\" in the form of unrelated inputs and outputs. These transactions are also free to specify ephemeral anchors, once the related relay policies are deployed. This means that vaults using recovery authorization have no dependence on the deploy of v3 relay policy.\n+\n+In the case of vaults that do not use recovery authorization, the recovery transaction relies on the use of either fully-spent fee inputs or an ephemeral anchor output. This means that vaults which do not use recovery authorization are essentially dependent on v3 transaction relay policy being deployed.\n+\n+==== Mixing input types ====\n+\n+<code>OP_VAULT</code>/<code>OP_UNVAULT</code> outputs can be spent\n+into a recovery transaction together. Script execution works identically for\n+both types of outputs.\n+\n+[[File:bip-VAULT/batch-sweep.drawio.png|frame|center]]\n+\n+\n+=== Batching ===\n+\n+==== During trigger ====\n+\n+<code>OP_VAULT</code> outputs with the same recovery-params and spend-delay can\n+be triggered into the same <code>OP_UNVAULT</code> output, creating a batched\n+withdrawal trigger. This is allowed regardless of the\n+<code><trigger-sPK-hash></code> values of each input, allowing the trigger keys\n+to differ.\n+\n+Trigger transactions can act on multiple incompatible <code>OP_VAULT</code>\n+input sets, provided each set has a suitable associated <code>OP_UNVAULT</code>\n+output.\n+\n+Since <code>SIGHASH_DEFAULT</code> can be used to sign the trigger\n+authorization, unrelated inputs and outputs can be included, possibly to\n+facilitate fee management or the batch withdrawal of incompatible vaults.\n+\n+==== During withdrawal ====\n+\n+During final withdrawal, multiple unrelated <code>OP_UNVAULT</code> outputs can\n+be used towards the same withdrawal transaction provided that they share\n+identical <code><target-outputs-hash></code> parameters. This facilitates\n+batched withdrawals.\n+\n+==== During recovery ====\n+\n+<code>OP_VAULT</code>/<code>OP_UNVAULT</code> outputs with the same recovery\n+scriptPubKey hash can be recovered into the same output.\n+\n+Recovery-incompatible vaults which have authorized recovery can be recovered in\n+the same transaction, so long as each set (grouped by recovery scriptPubKey\n+hash) has a suitable associated recovery output. This means that unrelated\n+recoveries controlled by the same owner can benefit from sharing common fee\n+management.\n+\n+=== Watchtowers ===\n+\n+The value of vaults is contingent upon having monitoring in place that will alert the owner when unexpected spends are taking place. This can be done in a variety of ways, with varying degrees of automation and trust in the watchtower.\n+\n+In the maximum-trust case, the watchtower can be fully aware of all vaulted coins and has the means to initiate the recovery process if spends are not pre-reported to the watchtower.\n+\n+In the minimum-trust case, the user can supply a probabilistic filter of which coins they wish to monitor; the watchtower would then alert the user if any coins matching the filter move, and the user would be responsible for ignoring false positives and handling recovery initiation.\n+\n+=== Script descriptors ===\n+\n+Script descriptors for vault-related outputs will be covered in a subsequent BIP.\n+\n+\n+== Deployment ==\n+\n+It is anticipated that deployment would happen in the same way [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Deployment that BIP-0341 was deployed]. Parameters to be determined.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 636,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "0204c9a1f9a9075f2483450f1bab034d453270b7",
      "in_reply_to_id": 1113342807,
      "user": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can you leave this deployment section blank for now @jamesob? There's no reason to spend time discussing deployment prior to getting a BIP number. Still lots of discussion, merging on bitcoin-inquisition, prototype vault designs on signet, building community consensus on the actual proposal etc before deployment becomes relevant.",
      "created_at": "2023-02-21T21:01:02Z",
      "updated_at": "2023-02-21T21:01:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1113564174",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113564174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 636,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113570132",
      "pull_request_review_id": 1308166433,
      "id": 1113570132,
      "node_id": "PRRC_kwDOAN28mc5CX7tU",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output<ref>Because the trigger scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.</ref>\n+** <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash''<ref>Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.</ref>, committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", <recovery-sPK>)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction, referred to as <code><recovery-auth-sPK></code>. \n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than or equal to this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the <code><recovery-auth-sPK></code> witness program, if any.\n+\n+* If <code><recovery-auth-sPK></code> is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+==== <code>OP_VAULT</code> evaluation for withdrawal trigger ====\n+\n+Else, if it has been determined that the spend is not within a recovery\n+transaction, it must be evaluated for eligibility as a withdrawal trigger\n+spend.\n+\n+===== Witness stack =====\n+\n+There must be at least 4 items on the stack (shown top to bottom):\n+\n+<source>\n+<trigger-vout-idx>\n+<target-outputs-hash>\n+<trigger-sPK>\n+<trigger witness stack item 1> [...] <item n>\n+</source>\n+\n+If the witness stack consists of fewer than four items the script MUST fail and\n+terminate immediately.\n+\n+(Note: in practice, the witness stack will have included the other items necessary to reveal \n+a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)\n+\n+The items on the stack must be validated as follows:\n+\n+* <code><trigger-vout-idx></code> is a <code>CScriptNum</code> of up to 4 bytes.\n+** It indicates the vout index of this input's corresponding <code>OP_UNVAULT</code> output.\n+*** Validation rules for this output are described below.\n+** If this value does not decode as a valid CScriptNum value, the script MUST fail and terminate immediately.\n+** If this value does not correspond to a valid output in the spending transaction, the script MUST fail and terminate immediately.\n+\n+* <code><target-outputs-hash></code> is a 32 byte data push.\n+** It is the hash of the proposed withdrawal target output set, defined by <code>target_outputs_hash(outputs)</code> below. Note that this value is duplicated here.<ref>'''Why, when spending an OP_VAULT output into a trigger, does the target hash need to be duplicated on the witness stack?''' The target hash exists in the <code>OP_UNVAULT</code> output script, likely behind a taproot pubkey. Its presence is required on the witness stack also so that the expected taproot pubkey for the <code>OP_UNVAULT</code> output can be constructed for comparison.</ref>\n+** If this value is not 32 bytes, the script MUST fail and terminate immediately.\n+\n+* <code><trigger-sPK></code> is a variable length data push.\n+** It must be the scriptPubKey that is the preimage to the <code><trigger-sPK-hash></code> specified in the spent <code>OP_VAULT</code> input.\n+** If this value does not tagged-hash to <code><trigger-sPK-hash></code> supplied by the <code>OP_VAULT</code> parameter, the script MUST fail and terminate immediately.\n+*** Verify <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>) == <trigger-sPK-hash></code>\n+** If this value does not correspond to a valid witness program, the script MUST fail and terminate immediately.\n+\n+* the remaining elements serve as the witness stack to satisfy the <code><trigger-sPK></code> witness program.\n+** If <code>VerifyWitnessProgram(<remaining stack elements>, <trigger-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the withdrawal trigger has been authorized.)\n+\n+===== Transaction outputs validation =====\n+\n+Once the contents of the witness stack have been parsed and validated, the transaction outputs must be checked.\n+\n+First, we must check for a ''revault output'': an output in the trigger transaction whose\n+scriptPubKey exactly matches that of the <code>OP_VAULT</code> input being\n+spent. Its presence is optional.\n+\n+For each vault input citing a particular <code><trigger-vout-idx></code>, the output \n+located at <code>vout[<trigger-vout-idx>]</code> (the \"trigger output\") must:\n+\n+* have as its scriptPubKey a witness program with a single <code>OP_UNVAULT</code> tapscript, having the internal x-only key <code>0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code>, per the NUMS point mentioned in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP-0341].<ref>'''Why must the OP_UNVAULT taproot use a predefined NUMS point as its internal key?''' This ensures that an OP_UNVAULT trigger output is verifiable as expected. It also ensures that it is spendable only by the conditions of the vault.</ref>\n+** If the witness program has a version less than 1, the script MUST fail and terminate immediately.\n+** If the witness program has a version greater than 1, the script MUST succeed to enable upgradeability.\n+** If the witness program has a version of 1 and the scriptPubKey of the output does not match the expected scriptPubKey, as computed by creating a taproot output using the cited NUMS point and a single tapscript spend condition of the form<br /><code><recovery-params-from-stack> <spend-delay-from-stack> <target-outputs-hash-from-stack> OP_UNVAULT</code>,<br />the script MUST fail and terminate immediately.\n+** Witness versions greater than 1 are allowed for upgradeability.\n+\n+* If there does not exist a revault output in the transaction for this input:\n+** (deferred) the <code>nValue</code> of the trigger output must equal the sum of all vault inputs which cite it as their corresponding trigger output.\n+*** If these values are not equal, the script MUST fail and terminate immediately.\n+* else (if there does exist a revault output for this input):\n+** (deferred) the <code>nValue</code>s of the trigger output and the revault output must sum to the sum of all vault inputs which both \n+*** cite this trigger output as the trigger-vout-idx and \n+*** have a scriptPubKey identical to the revault output's.\n+** If these values are not equal, the script MUST fail and terminate immediately.\n+\n+If none of the conditions above results in a failure of the script interpreter, the \n+stack will consist of a single true value (<code>0x01</code>).\n+\n+The above amount check can be expressed in Python as:\n+\n+<source lang=\"python\">\n+\n+spending_tx: CTransaction\n+vault_inputs: [CTxIn] = [inp for inp in spending_tx.vin if inp.is_OP_VAULT]\n+\n+\"Where we'll accumulate the expected totals for each vault input.\"\n+vault_totals_for_outputs: dict[(int, int), int] = defaultdict(0)\n+\n+\"Build the expected totals.\"\n+for vault_in in vault_inputs:\n+    maybe_revault_idx = find_revault_for_vault(vault_in)\n+    vault_total_for_outputs[(vault_in.trigger_vout_idx, maybe_revault_idx)] += vault_in.nValue\n+\n+\n+\"Check the expected totals against outputs.\"\n+for (out_idx, maybe_revault_idx), expected_amount in vault_totals_for_outputs.items():\n+    total = spending_tx.vout[out_idx].nValue\n+\n+    if maybe_revault_idx:\n+        total += spending_tx.vout[maybe_revault_idx]\n+\n+    if total != expected_amount:\n+        FAIL_AND_TERMINATE_SCRIPT()\n+    \n+    \n+def find_revault_for_vault(vault_in) -> int:\n+    \"\"\"Find the index of a revault output for a particular vault input, if one exists.\"\"\"\n+    for i, out in enumerate(spending_tx.vout):\n+        if out.scriptPubKey == vault_in.scriptPubKey:\n+            return i\n+    return None\n+</source>\n+\n+=== <code>OP_UNVAULT</code> evaulation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_UNVAULT</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbc</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_UNVAULT             (*) being evaluated\n+<target-outputs-hash>\n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><recovery-params></code> is validated exactly as described in [[#witness-program|the above <code>OP_VAULT</code> section]].\n+* <code><spend-delay></code> is validated exactly as described in [[#witness-program|the above <code>OP_VAULT</code> section]].\n+* <code><target-output-hash></code> is a 32 byte data push.\n+** If it is not equal to 32 bytes, the script MUST fail and terminate immediately.\n+\n+\n+==== Check for recovery ====\n+\n+A check is performed to determine if this input is being spent within the context of\n+a recovery transaction, exactly as in [[#check-for-recovery|the <code>OP_VAULT</code> evaluation described above]].\n+\n+\n+==== <code>OP_UNVAULT</code> evaluation for recovery spend ====\n+\n+This is identical to the [[#op_vault-evaluation-for-recovery-spend|<code>OP_VAULT</code> case described above]].\n+\n+\n+==== <code>OP_UNVAULT</code> evaluation for withdrawal ====\n+\n+When spending an <code>OP_UNVAULT</code> input into a withdrawal target, no witness stack is required.\n+\n+* <code><spend-delay></code> is used to check whether the withdrawal of the input has matured.\n+** If the input's relative timelock check, as described in [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP-0112] (using this value as \"the top item on the stack\") fails, the script MUST fail and terminate immediately.\n+*** The same <code>CheckSequence(<spend-delay>)</code> code path is used as for [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP-0112].\n+\n+* The transaction outputs are then checked to verify that the withdrawal outputs are as expected.\n+** If <code>target_outputs_hash(spending_tx.vout) != <target-output-hash></code> per the algorithm defined below, the script MUST fail and terminate immediately.\n+\n+<source lang=\"python\">\n+def target_outputs_hash(vout: [CTxOut]) -> bytes:\n+    return hash256(b\"\".join(serialize_txout(out) for out in vout))\n+\n+def serialize_txout(txo: CTxOut) -> bytes:\n+    spk: bytes = txo.scriptPubKey\n+    return struct.pack(\"<q\", txo.nValue) + ser_compact_size(len(spk)) + spk\n+</source>\n+\n+If the above conditions do not fail, a single true value (<code>0x01</code>) is pushed to the stack.\n+\n+== Policy changes ==\n+\n+In order to prevent possible pinning attacks, recovery transactions must be replaceable.\n+\n+* When validating an <code>OP_VAULT</code>/<code>OP_UNVAULT</code> input being spent towards a recovery, the script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], nor\n+*# the version of the recovery transaction has an nVersion equal to 3.\n+\n+In order to prevent pinning attacks in the case of unauthorized recovery, the output structure of unauthorized recovery\n+transaction is limited.\n+\n+* If <code><recovery-auth-sPK></code> (as determined from <code><recovery-params></code>) is null, the recovery transaction MUST (by policy) abide by the following constraints:\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output not the recovery output is not an ephemeral anchor, the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+== Implementation ==\n+\n+A sample implementation is available [https://github.com/jamesob/bitcoin/tree/2023-01-opvault here], with an associated [https://github.com/bitcoin/bitcoin/pull/26857 pull request].\n+\n+\n+== End use ==\n+\n+=== Creating an <code>OP_VAULT</code> output ===\n+\n+In order to vault coins, they must be spent into a witness v1<ref>'''Can <code>OP_VAULT</code> be used with a future witness version (greater than 1)?''' Yes, however use of yet to be defined witness versions is discouraged, since such a usage makes the coins spendable by anyone.</ref> <code>scriptPubKey</code> \n+that contains a Tapscript spending condition of the form\n+\n+<source>\n+<recovery-params> <spend-delay> <trigger-sPK-hash> OP_VAULT\n+</source>\n+\n+Typically, the internal key for the vault taproot output will be specified so\n+that it is controlled by the same descriptor as the recovery path, which\n+facilitates another (though probably unused) means of recovering the vault\n+output to the recovery path. This has the potential advantage of recovering the\n+coin without ever revealing it was a vault. \n+\n+Otherwise, the internal key can be chosen to be an unspendable NUMS point to\n+force tapscript execution of the <code>OP_VAULT</code> specification.\n+\n+\n+=== Recovery authorization ===\n+\n+When configuring a vault, the user must decide if they want to have the recovery process gated by the optional recovery authorization scriptPubKey. The choice is left to the user because it entails trade-offs.\n+\n+==== Unauthorized recovery ====\n+\n+Unauthorized recovery simplifies vault use in that recovery never requires additional information aside from the location of the vault outpoints and the recovery path - the \"authorization\" is simply the reveal of the recovery path. \n+\n+But because this reveal is the only authorization necessary to spend the vault coins to recovery, the user must expect to recover all such vaults at once, since an observer can replay this recovery (provided they know the outpoints).\n+\n+Additionally, unauthorized recovery across multiple distinct recovery paths cannot be batched, and fee control is more constrained: because the output structure is limited for unauthorized recovery, fee management relies either on inputs which are completely spent to fees or the use of the optional ephemeral anchor and package relay.\n+\n+==== Authorized recovery ====\n+\n+With authorized recovery, the user must keep track of an additional piece of information: how to solve the recovery authorization scriptPubKey when recovery is required. If this key is lost, the user will be unable to initiate the recovery process for their coins. If an attacker obtains the recovery key, they may grief the user during the recovery process by constructing a low fee rate recovery transaction and broadcasting it (though they will not be able to pin because of the replaceability requirement on recovery transactions).\n+\n+However, authorized recovery configurations have significant benefits. Batched recoveries are possible for vaults with otherwise incompatible recovery parameters. Fee management is much more flexible, since authorized recovery transactions are \"free form\" and unrelated inputs and outputs can be added, potentially to handle fees.\n+\n+==== Recommendation: use a simple, offline recovery authorization key seed ====\n+\n+The benefits of batching and fee management that authorized recovery provides are significant. If the recovery authorization key falls into the hands of an attacker, the outcome is not catastrophic, whereas if the user loses their recovery authorization key as well as their trigger key, the result is likely coin loss. Consequently, the author's recommendation is to use a simple seed for the recovery authorization key that can be written down offline and replicated. \n+\n+Note that the recovery authorization key '''is not''' the recovery path key, and\n+this is '''much different''' than any recommendation on how to generate the\n+recovery path key itself.\n+\n+=== Address reuse and recovery ===\n+\n+When creating a vault, four factors affect the resulting P2TR address:\n+# The internal key (likely belonging to the recovery wallet)\n+# The recovery parameters\n+# The spend delay\n+# The trigger scriptPubKey\n+\n+Aside from the spend delay, the end user has the option of varying the other three parameters along descriptors in order to avoid reusing vault addresses without affecting key management.\n+\n+Worth noting is that when using unauthorized recovery, the reveal of the recovery scriptPubKey will allow any observer to initiate the recovery process for any vault with matching recovery params, provided they are able to locate the vault outpoints. As a result, it is recommended to expect that '''all outputs sharing an identical unauthorized <code><recovery-params></code> should be recovered together'''.\n+\n+This situation can be avoided with a comparable key management model by varying the generation of each vault's recovery scriptPubKey along a single descriptor, but note that (when configured for unauthorized recovery), this will prevent batched recovery.\n+\n+==== Recommendation: vary the internal key ====\n+\n+The recommended mode of use is to keep recovery parameters identical across vaults which should be recovered in batch, but vary the internal key for each vault output along a single descriptor so that no address reuse is necessary.\n+\n+==== Recommendation: generate new recovery addresses for new trigger keys ====\n+\n+If using unauthorized recovery, it is recommended that you do not share literal recovery paths\n+across separate trigger keys. If one trigger key is compromised, that will necessitate the (unauthorized)\n+recovery of all vaults with that trigger key, which will reveal the recovery path preimage. This\n+means that an observer might be able to initiate recovery for vaults controlled by an uncompromised\n+trigger key.\n+\n+==== Fee management ====\n+\n+Fees can be managed in a variety of ways, but it's worth noting that both trigger and recovery transactions must preserve the total value of vault inputs, so vaulted values cannot be repurposed to pay for fees. This does not apply to the withdrawal transaction, which can allocate value arbitrarily.\n+\n+In the case of vaults that use recovery authorization, all transactions can \"bring their own fees\" in the form of unrelated inputs and outputs. These transactions are also free to specify ephemeral anchors, once the related relay policies are deployed. This means that vaults using recovery authorization have no dependence on the deploy of v3 relay policy.\n+\n+In the case of vaults that do not use recovery authorization, the recovery transaction relies on the use of either fully-spent fee inputs or an ephemeral anchor output. This means that vaults which do not use recovery authorization are essentially dependent on v3 transaction relay policy being deployed.\n+\n+==== Mixing input types ====\n+\n+<code>OP_VAULT</code>/<code>OP_UNVAULT</code> outputs can be spent\n+into a recovery transaction together. Script execution works identically for\n+both types of outputs.\n+\n+[[File:bip-VAULT/batch-sweep.drawio.png|frame|center]]\n+\n+\n+=== Batching ===\n+\n+==== During trigger ====\n+\n+<code>OP_VAULT</code> outputs with the same recovery-params and spend-delay can\n+be triggered into the same <code>OP_UNVAULT</code> output, creating a batched\n+withdrawal trigger. This is allowed regardless of the\n+<code><trigger-sPK-hash></code> values of each input, allowing the trigger keys\n+to differ.\n+\n+Trigger transactions can act on multiple incompatible <code>OP_VAULT</code>\n+input sets, provided each set has a suitable associated <code>OP_UNVAULT</code>\n+output.\n+\n+Since <code>SIGHASH_DEFAULT</code> can be used to sign the trigger\n+authorization, unrelated inputs and outputs can be included, possibly to\n+facilitate fee management or the batch withdrawal of incompatible vaults.\n+\n+==== During withdrawal ====\n+\n+During final withdrawal, multiple unrelated <code>OP_UNVAULT</code> outputs can\n+be used towards the same withdrawal transaction provided that they share\n+identical <code><target-outputs-hash></code> parameters. This facilitates\n+batched withdrawals.\n+\n+==== During recovery ====\n+\n+<code>OP_VAULT</code>/<code>OP_UNVAULT</code> outputs with the same recovery\n+scriptPubKey hash can be recovered into the same output.\n+\n+Recovery-incompatible vaults which have authorized recovery can be recovered in\n+the same transaction, so long as each set (grouped by recovery scriptPubKey\n+hash) has a suitable associated recovery output. This means that unrelated\n+recoveries controlled by the same owner can benefit from sharing common fee\n+management.\n+\n+=== Watchtowers ===\n+\n+The value of vaults is contingent upon having monitoring in place that will alert the owner when unexpected spends are taking place. This can be done in a variety of ways, with varying degrees of automation and trust in the watchtower.\n+\n+In the maximum-trust case, the watchtower can be fully aware of all vaulted coins and has the means to initiate the recovery process if spends are not pre-reported to the watchtower.\n+\n+In the minimum-trust case, the user can supply a probabilistic filter of which coins they wish to monitor; the watchtower would then alert the user if any coins matching the filter move, and the user would be responsible for ignoring false positives and handling recovery initiation.\n+\n+=== Script descriptors ===\n+\n+Script descriptors for vault-related outputs will be covered in a subsequent BIP.\n+\n+\n+== Deployment ==\n+\n+It is anticipated that deployment would happen in the same way [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Deployment that BIP-0341 was deployed]. Parameters to be determined.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 636,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "0204c9a1f9a9075f2483450f1bab034d453270b7",
      "in_reply_to_id": 1113342807,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@michaelfolkson yeah that's fine with me. I'll replace this section's content with TBD.",
      "created_at": "2023-02-21T21:06:41Z",
      "updated_at": "2023-02-21T21:06:42Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1113570132",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113570132"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 636,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113595887",
      "pull_request_review_id": 1308203815,
      "id": 1113595887,
      "node_id": "PRRC_kwDOAN28mc5CYB_v",
      "diff_hunk": "@@ -0,0 +1,745 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the $5 wrench attack =====\n+\n+This proposal uniquely provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** Note that in the draft implementation, this is facilitated by a \"deferred check\" which is queued by the script interpreter, but executed after the script interpreter has finished, in other validation code.<ref>'''Why does this proposal require a \"deferred checks\" framework for correct script evaluation?''' The deferred checks framework is an augmentation to execution of the Bitcoin script interpreter. Currently, the validity of each input is checked in an order-indepdendent manner across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>\n+* The script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 307,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "c589490f98ba1b0c606d0e2030463f1fde54b786",
      "in_reply_to_id": 1110810372,
      "user": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@luke-jr: Agreed but there are going to be future discussions on changing the default policy in Bitcoin Core and the recommended default policy in other implementations (which those implementations are free to ignore as are all users given it is only a policy default and not a consensus rule). It is inevitable with proposals for Lightning, vaults etc and the associated pinning vectors. Personally I would much rather any proposed changes to default policy were spec'ed and discussed in the open in the BIP process than just say merged into Core.\r\n\r\nI do agree that mixing consensus and policy in the same proposal isn't ideal. Perhaps there can be a note to the reader on what the BIP author recommends for default policy changes associated with this proposal but making it clear that this BIP stands alone as a proposed consensus change and not a default policy change.\r\n",
      "created_at": "2023-02-21T21:40:22Z",
      "updated_at": "2023-02-21T21:40:23Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1113595887",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113595887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 307,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1122695762",
      "pull_request_review_id": 1321173414,
      "id": 1122695762,
      "node_id": "PRRC_kwDOAN28mc5C6vpS",
      "diff_hunk": "@@ -0,0 +1,756 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdraw to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output<ref>Because the trigger scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.</ref>\n+** <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash''<ref>Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.</ref>, committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", <recovery-sPK>)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction, referred to as <code><recovery-auth-sPK></code>. \n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than or equal to this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the <code><recovery-auth-sPK></code> witness program, if any.\n+\n+* If <code><recovery-auth-sPK></code> is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+==== <code>OP_VAULT</code> evaluation for withdrawal trigger ====\n+\n+Else, if it has been determined that the spend is not within a recovery\n+transaction, it must be evaluated for eligibility as a withdrawal trigger\n+spend.\n+\n+===== Witness stack =====\n+\n+There must be at least 4 items on the stack (shown top to bottom):\n+\n+<source>\n+<trigger-vout-idx>\n+<target-outputs-hash>\n+<trigger-sPK>\n+<trigger witness stack item 1> [...] <item n>\n+</source>\n+\n+If the witness stack consists of fewer than four items the script MUST fail and\n+terminate immediately.\n+\n+(Note: in practice, the witness stack will have included the other items necessary to reveal \n+a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)\n+\n+The items on the stack must be validated as follows:\n+\n+* <code><trigger-vout-idx></code> is a <code>CScriptNum</code> of up to 4 bytes.\n+** It indicates the vout index of this input's corresponding <code>OP_UNVAULT</code> output.\n+*** Validation rules for this output are described below.\n+** If this value does not decode as a valid CScriptNum value, the script MUST fail and terminate immediately.\n+** If this value does not correspond to a valid output in the spending transaction, the script MUST fail and terminate immediately.\n+\n+* <code><target-outputs-hash></code> is a 32 byte data push.\n+** It is the hash of the proposed withdrawal target output set, defined by <code>target_outputs_hash(outputs)</code> below. Note that this value is duplicated here.<ref>'''Why, when spending an OP_VAULT output into a trigger, does the target hash need to be duplicated on the witness stack?''' The target hash exists in the <code>OP_UNVAULT</code> output script, likely behind a taproot pubkey. Its presence is required on the witness stack also so that the expected taproot pubkey for the <code>OP_UNVAULT</code> output can be constructed for comparison.</ref>\n+** If this value is not 32 bytes, the script MUST fail and terminate immediately.\n+\n+* <code><trigger-sPK></code> is a variable length data push.\n+** It must be the scriptPubKey that is the preimage to the <code><trigger-sPK-hash></code> specified in the spent <code>OP_VAULT</code> input.\n+** If this value does not tagged-hash to <code><trigger-sPK-hash></code> supplied by the <code>OP_VAULT</code> parameter, the script MUST fail and terminate immediately.\n+*** Verify <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>) == <trigger-sPK-hash></code>\n+** If this value does not correspond to a valid witness program, the script MUST fail and terminate immediately.\n+\n+* the remaining elements serve as the witness stack to satisfy the <code><trigger-sPK></code> witness program.\n+** If <code>VerifyWitnessProgram(<remaining stack elements>, <trigger-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the withdrawal trigger has been authorized.)\n+\n+===== Transaction outputs validation =====\n+\n+Once the contents of the witness stack have been parsed and validated, the transaction outputs must be checked.\n+\n+First, we must check for a ''revault output'': an output in the trigger transaction whose\n+scriptPubKey exactly matches that of the <code>OP_VAULT</code> input being\n+spent. Its presence is optional.\n+\n+For each vault input citing a particular <code><trigger-vout-idx></code>, the output \n+located at <code>vout[<trigger-vout-idx>]</code> (the \"trigger output\") must:\n+\n+* have as its scriptPubKey a witness program with a single <code>OP_UNVAULT</code> tapscript, having the internal x-only key <code>0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0</code>, per the NUMS point mentioned in [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#constructing-and-spending-taproot-outputs BIP-0341].<ref>'''Why must the OP_UNVAULT taproot use a predefined NUMS point as its internal key?''' This ensures that an OP_UNVAULT trigger output is verifiable as expected. It also ensures that it is spendable only by the conditions of the vault.</ref>\n+** If the witness program has a version less than 1, the script MUST fail and terminate immediately.\n+** If the witness program has a version greater than 1, the script MUST succeed to enable upgradeability.\n+** If the witness program has a version of 1 and the scriptPubKey of the output does not match the expected scriptPubKey, as computed by creating a taproot output using the cited NUMS point and a single tapscript spend condition of the form<br /><code><recovery-params-from-stack> <spend-delay-from-stack> <target-outputs-hash-from-stack> OP_UNVAULT</code>,<br />the script MUST fail and terminate immediately.\n+** Witness versions greater than 1 are allowed for upgradeability.\n+\n+* If there does not exist a revault output in the transaction for this input:\n+** (deferred) the <code>nValue</code> of the trigger output must equal the sum of all vault inputs which cite it as their corresponding trigger output.\n+*** If these values are not equal, the script MUST fail and terminate immediately.\n+* else (if there does exist a revault output for this input):\n+** (deferred) the <code>nValue</code>s of the trigger output and the revault output must sum to the sum of all vault inputs which both \n+*** cite this trigger output as the trigger-vout-idx and \n+*** have a scriptPubKey identical to the revault output's.\n+** If these values are not equal, the script MUST fail and terminate immediately.\n+\n+If none of the conditions above results in a failure of the script interpreter, the \n+stack will consist of a single true value (<code>0x01</code>).\n+\n+The above amount check can be expressed in Python as:\n+\n+<source lang=\"python\">\n+\n+spending_tx: CTransaction\n+vault_inputs: [CTxIn] = [inp for inp in spending_tx.vin if inp.is_OP_VAULT]\n+\n+\"Where we'll accumulate the expected totals for each vault input.\"\n+vault_totals_for_outputs: dict[(int, int), int] = defaultdict(0)\n+\n+\"Build the expected totals.\"\n+for vault_in in vault_inputs:\n+    maybe_revault_idx = find_revault_for_vault(vault_in)\n+    vault_total_for_outputs[(vault_in.trigger_vout_idx, maybe_revault_idx)] += vault_in.nValue\n+\n+\n+\"Check the expected totals against outputs.\"\n+for (out_idx, maybe_revault_idx), expected_amount in vault_totals_for_outputs.items():\n+    total = spending_tx.vout[out_idx].nValue\n+\n+    if maybe_revault_idx:\n+        total += spending_tx.vout[maybe_revault_idx]\n+\n+    if total != expected_amount:\n+        FAIL_AND_TERMINATE_SCRIPT()\n+    \n+    \n+def find_revault_for_vault(vault_in) -> int:\n+    \"\"\"Find the index of a revault output for a particular vault input, if one exists.\"\"\"\n+    for i, out in enumerate(spending_tx.vout):\n+        if out.scriptPubKey == vault_in.scriptPubKey:\n+            return i\n+    return None\n+</source>\n+\n+=== <code>OP_UNVAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_UNVAULT</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbc</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_UNVAULT             (*) being evaluated\n+<target-outputs-hash>\n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><recovery-params></code> is validated exactly as described in [[#witness-program|the above <code>OP_VAULT</code> section]].\n+* <code><spend-delay></code> is validated exactly as described in [[#witness-program|the above <code>OP_VAULT</code> section]].\n+* <code><target-output-hash></code> is a 32 byte data push.\n+** If it is not equal to 32 bytes, the script MUST fail and terminate immediately.\n+\n+\n+==== Check for recovery ====\n+\n+A check is performed to determine if this input is being spent within the context of\n+a recovery transaction, exactly as in [[#check-for-recovery|the <code>OP_VAULT</code> evaluation described above]].\n+\n+\n+==== <code>OP_UNVAULT</code> evaluation for recovery spend ====\n+\n+This is identical to the [[#op_vault-evaluation-for-recovery-spend|<code>OP_VAULT</code> case described above]].\n+\n+\n+==== <code>OP_UNVAULT</code> evaluation for withdrawal ====\n+\n+When spending an <code>OP_UNVAULT</code> input into a withdrawal target, no witness stack is required.\n+\n+* <code><spend-delay></code> is used to check whether the withdrawal of the input has matured.\n+** If the input's relative timelock check, as described in [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP-0112] (using this value as \"the top item on the stack\") fails, the script MUST fail and terminate immediately.\n+*** The same <code>CheckSequence(<spend-delay>)</code> code path is used as for [https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki BIP-0112].\n+\n+* The transaction outputs are then checked to verify that the withdrawal outputs are as expected.\n+** If <code>target_outputs_hash(spending_tx.vout) != <target-output-hash></code> per the algorithm defined below, the script MUST fail and terminate immediately.\n+\n+<source lang=\"python\">\n+def target_outputs_hash(vout: [CTxOut]) -> bytes:\n+    return hash256(b\"\".join(serialize_txout(out) for out in vout))\n+\n+def serialize_txout(txo: CTxOut) -> bytes:\n+    spk: bytes = txo.scriptPubKey\n+    return struct.pack(\"<q\", txo.nValue) + ser_compact_size(len(spk)) + spk\n+</source>\n+\n+If the above conditions do not fail, a single true value (<code>0x01</code>) is pushed to the stack.\n+\n+== Policy changes ==\n+\n+In order to prevent possible pinning attacks, recovery transactions must be replaceable.\n+\n+* When validating an <code>OP_VAULT</code>/<code>OP_UNVAULT</code> input being spent towards a recovery, the script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], nor\n+*# the version of the recovery transaction has an nVersion equal to 3.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 481,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "61dd727556d98e3fa983cf51e5eb2833f0cbe89d",
      "in_reply_to_id": null,
      "user": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is going to be misinterpreted in its current form. Perhaps this would be easier to human-parse:\r\n\r\n```suggestion\r\n* When validating an <code>OP_VAULT</code>/<code>OP_UNVAULT</code> input being spent towards a recovery, the script must FAIL (by policy, not consensus) and terminate immediately if both<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\r\n*# the input is not marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], and\r\n*# the version of the recovery transaction has an nVersion other than 3.\r\n```",
      "created_at": "2023-03-02T07:33:54Z",
      "updated_at": "2023-03-02T07:45:13Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1122695762",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1122695762"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": 479,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 481,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1128832014",
      "pull_request_review_id": 1329822398,
      "id": 1128832014,
      "node_id": "PRRC_kwDOAN28mc5DSJwO",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 50,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think there is an operational complexity in authenticating the \"recovery path\" to the individual/group of stakeholders locking up the funds in the initial OP_VAULT UTXO, _without_ re-introducing one of the security risk aforementioned, e.g the origin hardware wallet could have been compromised to display the \"honest\" recovery path, while at the script-level a malicious \"recovery path\" has been substituted for. I think you might need at least 2 \"logical\" trusted systems, the air-gapped/cold storage where the OP_VAULT funding transaction is generated, and the initial hardware where are relying the non-covenanted secret key (though it could be one \"physical\" system).",
      "created_at": "2023-03-08T01:18:13Z",
      "updated_at": "2023-03-08T02:08:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1128832014",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1128832014"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 50,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1128833113",
      "pull_request_review_id": 1329822398,
      "id": 1128833113,
      "node_id": "PRRC_kwDOAN28mc5DSKBZ",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 55,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A side-note, the block-relay stack of most of lightweight clients is a level or two of hardening under the Bitcoin Core p2p stack, so building a vault mobile client is probably going to be passive to eclipse/time-dilation attacks and other niceties.",
      "created_at": "2023-03-08T01:19:41Z",
      "updated_at": "2023-03-08T02:08:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1128833113",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1128833113"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 55,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1128841588",
      "pull_request_review_id": 1329822398,
      "id": 1128841588,
      "node_id": "PRRC_kwDOAN28mc5DSMF0",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 79,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think there is still the trigger key path that a victim could be coerced to use to unlock the funds to the trigger transaction. This is nullified only if you have a set of watchtowers to correct the \"misbehaving\" unlock with the recovery transaction. I think the presence of watchtowers is what grants vaults a proactive security model and your \"$5 wrench attack\" is proportional to your number of watchtowers.",
      "created_at": "2023-03-08T01:30:29Z",
      "updated_at": "2023-03-08T02:08:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1128841588",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1128841588"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1128846013",
      "pull_request_review_id": 1329822398,
      "id": 1128846013,
      "node_id": "PRRC_kwDOAN28mc5DSNK9",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. ",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 134,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think if you use key blinding, you should be able to prevent address reuse, e.g your user gives you a set of blinding points to be used one-time with the same base `scriptPubKey`, a solution to address reuse would be valuable for coins confidentiality.",
      "created_at": "2023-03-08T01:36:25Z",
      "updated_at": "2023-03-08T02:08:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1128846013",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1128846013"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1128855079",
      "pull_request_review_id": 1329822398,
      "id": 1128855079,
      "node_id": "PRRC_kwDOAN28mc5DSPYn",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 136,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Recovery batching is unsafe if you assume an adversary that can generate trigger transactions for all your swept vault outputs, even if you use nversion=3 I think. Your batching _recovery_ transaction spending the OP_UNVAULT outputs can be rejected on the ground of bip125 rule #5 (i.e max 100 replacements), so you might to limit the size of your batch.",
      "created_at": "2023-03-08T01:47:21Z",
      "updated_at": "2023-03-08T02:08:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1128855079",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1128855079"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1128861652",
      "pull_request_review_id": 1329822398,
      "id": 1128861652,
      "node_id": "PRRC_kwDOAN28mc5DSQ_U",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdraw to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 191,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think one flexibility increase could be to allow the output index to be included as an element in the witness data, therefore you might do mixed batching, where inputs [0..2] goes to output N and inputs [3..7] goes to output M, with a single anchor output/pair of inputs/outputs and fee-bumping reserve coin is consumed for dynamic fee adjustment.",
      "created_at": "2023-03-08T01:55:56Z",
      "updated_at": "2023-03-08T02:08:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1128861652",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1128861652"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 191,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1128871297",
      "pull_request_review_id": 1329822398,
      "id": 1128871297,
      "node_id": "PRRC_kwDOAN28mc5DSTWB",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdraw to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 209,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't know if this statement is correct in the presence of unsolved pinnings vectors. E.g a bip125 rule #3 pinning where a malicious recovery transaction (without a secondary authorisation `scriptPubkey`) iiuc is absolute fee inflated to prevent confirmation of a recovery transaction. Though this one should be solved by nversion=3 I believe.",
      "created_at": "2023-03-08T02:06:14Z",
      "updated_at": "2023-03-08T02:08:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1128871297",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1128871297"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1131466324",
      "pull_request_review_id": 1333546425,
      "id": 1131466324,
      "node_id": "PRRC_kwDOAN28mc5DcM5U",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 136,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": 1128855079,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Batching here means additional *confirmed* inputs, not unconfirmed batching. \r\n\r\nin other words: You have N deposited utxos. If they share the same recovery path, they all can be moved into the same new output in a single bitcoin transaction,",
      "created_at": "2023-03-09T18:58:30Z",
      "updated_at": "2023-03-09T18:59:23Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1131466324",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1131466324"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133137243",
      "pull_request_review_id": 1335925575,
      "id": 1133137243,
      "node_id": "PRRC_kwDOAN28mc5Dik1b",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 61,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "...and additional transactions. Seems like the ideal solution would allow sending locked UTXOs to their final destination in a single transaction, yet allow a \"claw back\" transaction as well. Locktimes+RBF basically do this already, but without an on-chain commitment to the intermediate transaction which can be enforced by the UTXO itself.\r\n\r\nPerhaps a better approach would be to have a covenant requiring the recipient to have a locktime N days later when spending, and an escape hatch for the clawback scenario. The drawback to this would be that we might need receiving wallets to understand the process (and yet another address format upgrade?).\r\n\r\n(I suppose this is too different from OP_VAULT to be a change to your BIP, but it might be something to consider before moving too far along with OP_VAULT)",
      "created_at": "2023-03-11T19:27:25Z",
      "updated_at": "2023-03-11T20:28:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1133137243",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133137243"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133138026",
      "pull_request_review_id": 1335925575,
      "id": 1133138026,
      "node_id": "PRRC_kwDOAN28mc5DilBq",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 77,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm not sure it actually solves the $5 wrench attack. The attacker can just demand all the multisig keys. Or even accept the delay, but deprive the owner of clawback key(s) to intervene later.",
      "created_at": "2023-03-11T19:34:53Z",
      "updated_at": "2023-03-11T20:28:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1133138026",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133138026"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": 73,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133138173",
      "pull_request_review_id": 1335925575,
      "id": 1133138173,
      "node_id": "PRRC_kwDOAN28mc5DilD9",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 97,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Isn't it inherently always required in one form or another?",
      "created_at": "2023-03-11T19:36:48Z",
      "updated_at": "2023-03-11T20:28:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1133138173",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133138173"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 97,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133138230",
      "pull_request_review_id": 1335925575,
      "id": 1133138230,
      "node_id": "PRRC_kwDOAN28mc5DilE2",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 98,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "But multiple patterns can be precommitted to, so is this an issue in practice?",
      "created_at": "2023-03-11T19:37:23Z",
      "updated_at": "2023-03-11T20:28:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1133138230",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133138230"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 98,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133138807",
      "pull_request_review_id": 1335925575,
      "id": 1133138807,
      "node_id": "PRRC_kwDOAN28mc5DilN3",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. ",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 134,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Someone sending to the same address multiple times is undefined behaviour. Users should not expect it to work, and enforcement can be done by simply setting an expectation that additional sends may be lost. This is inherently also true for edge cases such as changing your wallet or being compromised. Address reuse *cannot* be made safe.",
      "created_at": "2023-03-11T19:42:37Z",
      "updated_at": "2023-03-11T20:28:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1133138807",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133138807"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133138870",
      "pull_request_review_id": 1335925575,
      "id": 1133138870,
      "node_id": "PRRC_kwDOAN28mc5DilO2",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. ",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 134,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Making it efficient *encourages* reuse. Better not to.",
      "created_at": "2023-03-11T19:43:29Z",
      "updated_at": "2023-03-11T20:28:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1133138870",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133138870"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133142221",
      "pull_request_review_id": 1335925575,
      "id": 1133142221,
      "node_id": "PRRC_kwDOAN28mc5DimDN",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 136,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This could reintroduce serious privacy issues if not combined with some kind of coinjoin/CISA",
      "created_at": "2023-03-11T20:12:29Z",
      "updated_at": "2023-03-11T20:28:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1133142221",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133142221"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133143812",
      "pull_request_review_id": 1335925575,
      "id": 1133143812,
      "node_id": "PRRC_kwDOAN28mc5DimcE",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdraw to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output<ref>Because the trigger scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.</ref>\n+** <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash''<ref>Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.</ref>, committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", <recovery-sPK>)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction, referred to as <code><recovery-auth-sPK></code>. \n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than or equal to this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the <code><recovery-auth-sPK></code> witness program, if any.\n+\n+* If <code><recovery-auth-sPK></code> is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+==== <code>OP_VAULT</code> evaluation for withdrawal trigger ====\n+\n+Else, if it has been determined that the spend is not within a recovery\n+transaction, it must be evaluated for eligibility as a withdrawal trigger\n+spend.\n+\n+===== Witness stack =====\n+\n+There must be at least 4 items on the stack (shown top to bottom):\n+\n+<source>\n+<trigger-vout-idx>\n+<target-outputs-hash>\n+<trigger-sPK>\n+<trigger witness stack item 1> [...] <item n>\n+</source>\n+\n+If the witness stack consists of fewer than four items the script MUST fail and\n+terminate immediately.\n+\n+(Note: in practice, the witness stack will have included the other items necessary to reveal \n+a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)\n+\n+The items on the stack must be validated as follows:\n+\n+* <code><trigger-vout-idx></code> is a <code>CScriptNum</code> of up to 4 bytes.\n+** It indicates the vout index of this input's corresponding <code>OP_UNVAULT</code> output.\n+*** Validation rules for this output are described below.\n+** If this value does not decode as a valid CScriptNum value, the script MUST fail and terminate immediately.\n+** If this value does not correspond to a valid output in the spending transaction, the script MUST fail and terminate immediately.\n+\n+* <code><target-outputs-hash></code> is a 32 byte data push.\n+** It is the hash of the proposed withdrawal target output set, defined by <code>target_outputs_hash(outputs)</code> below. Note that this value is duplicated here.<ref>'''Why, when spending an OP_VAULT output into a trigger, does the target hash need to be duplicated on the witness stack?''' The target hash exists in the <code>OP_UNVAULT</code> output script, likely behind a taproot pubkey. Its presence is required on the witness stack also so that the expected taproot pubkey for the <code>OP_UNVAULT</code> output can be constructed for comparison.</ref>\n+** If this value is not 32 bytes, the script MUST fail and terminate immediately.\n+\n+* <code><trigger-sPK></code> is a variable length data push.\n+** It must be the scriptPubKey that is the preimage to the <code><trigger-sPK-hash></code> specified in the spent <code>OP_VAULT</code> input.\n+** If this value does not tagged-hash to <code><trigger-sPK-hash></code> supplied by the <code>OP_VAULT</code> parameter, the script MUST fail and terminate immediately.\n+*** Verify <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>) == <trigger-sPK-hash></code>\n+** If this value does not correspond to a valid witness program, the script MUST fail and terminate immediately.\n+\n+* the remaining elements serve as the witness stack to satisfy the <code><trigger-sPK></code> witness program.\n+** If <code>VerifyWitnessProgram(<remaining stack elements>, <trigger-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the withdrawal trigger has been authorized.)\n+\n+===== Transaction outputs validation =====\n+\n+Once the contents of the witness stack have been parsed and validated, the transaction outputs must be checked.\n+\n+First, we must check for a ''revault output'': an output in the trigger transaction whose",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 359,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Even this kind of address reuse has serious privacy implications. There should be a way to make it unknowable which output is change.",
      "created_at": "2023-03-11T20:27:42Z",
      "updated_at": "2023-03-11T20:28:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1133143812",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133143812"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 359,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133250804",
      "pull_request_review_id": 1336020226,
      "id": 1133250804,
      "node_id": "PRRC_kwDOAN28mc5DjAj0",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. ",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 134,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": 1133138807,
      "user": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"undefined behaviour\"? I get it is discouraged in a single signer use case because why not just generate a new key? But in multiparty and vault like use cases getting all participants and all spending paths to generate a new key any time there is movement of funds might be at best unwieldy and at worst impact security practices (e.g. needing to access a key in cold storage when you'd rather not). Seems to me that we are firmly in privacy, security/UX trade-off territory here when we (arguably) weren't in a single signer use case.",
      "created_at": "2023-03-12T12:57:51Z",
      "updated_at": "2023-03-12T12:57:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1133250804",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133250804"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133254813",
      "pull_request_review_id": 1336024081,
      "id": 1133254813,
      "node_id": "PRRC_kwDOAN28mc5DjBid",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. ",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 134,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": 1133138807,
      "user": {
        "login": "michaelfolkson",
        "id": 16323900,
        "node_id": "MDQ6VXNlcjE2MzIzOTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/16323900?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/michaelfolkson",
        "html_url": "https://github.com/michaelfolkson",
        "followers_url": "https://api.github.com/users/michaelfolkson/followers",
        "following_url": "https://api.github.com/users/michaelfolkson/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/michaelfolkson/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/michaelfolkson/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/michaelfolkson/subscriptions",
        "organizations_url": "https://api.github.com/users/michaelfolkson/orgs",
        "repos_url": "https://api.github.com/users/michaelfolkson/repos",
        "events_url": "https://api.github.com/users/michaelfolkson/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/michaelfolkson/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I put \"arguably\" in brackets because even in the single signer use case there are additional computational and tracking costs and so we are already in trade-off territory. It is just many would value privacy benefits higher than these relatively tiny costs hence a universal attitude against address reuse makes much more sense in a single signer use case. In a more complex setting (more keys, more spending paths) it is much, much harder to justify any kind of universal approach.",
      "created_at": "2023-03-12T13:23:11Z",
      "updated_at": "2023-03-12T13:23:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1133254813",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1133254813"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 134,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1134041560",
      "pull_request_review_id": 1337184216,
      "id": 1134041560,
      "node_id": "PRRC_kwDOAN28mc5DmBnY",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 61,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": 1133137243,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Completely handwaving here, but I think you'd need something like recursive taproot(or better bitcoin script) to do this properly. The \"forwarded\" script would at spend time get a `<pubkey>` that is inserted to a timelocked sub-expression in a larger expression that has otherwise been committed to at deposit time.\r\n\r\nYou can't just insert random bitcoin script at spend time, as we need to ensure it's purely restricting spends, i.e. cannot be OP_SUCCESSX or something that modifies the stack in an unexpected way.\r\n\r\nRecipients would have to scan on the input side to decipher outputs have hit their wallet, and they would still have to sweep that output to call it a proper deposit, ala HTLC resolution.\r\n\r\nI'm not sure that's a compelling use-case, since wallets will likely sweep outputs promptly for this very reason regardless.",
      "created_at": "2023-03-13T14:27:37Z",
      "updated_at": "2023-03-13T14:27:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1134041560",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1134041560"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1134052461",
      "pull_request_review_id": 1337198724,
      "id": 1134052461,
      "node_id": "PRRC_kwDOAN28mc5DmERt",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> inputs into an <code>OP_UNVAULT</code> output which carries forward the same recovery and delay parameters, along with a commitment to the proposed withdrawal target outputs. This publicly broadcasts the intent to withdraw to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> trigger inputs into a compatible set of final withdrawal outputs per the target hash, after the trigger inputs have matured per the spend delay. The only authorization for this spend (aside from the relative timelock) is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage, i.e. the recovery path.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output<ref>Because the trigger scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.</ref>\n+** <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash''<ref>Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.</ref>, committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", <recovery-sPK>)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction, referred to as <code><recovery-auth-sPK></code>. \n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+\n+==== Witness stack ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. \n+\n+Witness stack shown top to bottom:\n+\n+<source>\n+<recovery-vout-idx>\n+[other potential witness stack items ...]\n+</source>\n+\n+where\n+\n+* <code><recovery-vout-idx></code> is an integer indicating which output, if any, is a recovery output.\n+** If this value cannot be decoded as a CScriptNum and cast to an integer, script execution MUST fail and terminate immediately.\n+** If this value is less than -1, script execution MUST fail and terminate immediately.\n+** If this value is greater than or equal to 0, this spend is a recovery transaction and this value denotes the recovery output that corresponds to this vault input.\n+* The parse of the other stack items depends on whether or not this is a recovery spend.\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than or equal to this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the <code><recovery-auth-sPK></code> witness program, if any.\n+\n+* If <code><recovery-auth-sPK></code> is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+==== <code>OP_VAULT</code> evaluation for withdrawal trigger ====\n+\n+Else, if it has been determined that the spend is not within a recovery\n+transaction, it must be evaluated for eligibility as a withdrawal trigger\n+spend.\n+\n+===== Witness stack =====\n+\n+There must be at least 4 items on the stack (shown top to bottom):\n+\n+<source>\n+<trigger-vout-idx>\n+<target-outputs-hash>\n+<trigger-sPK>\n+<trigger witness stack item 1> [...] <item n>\n+</source>\n+\n+If the witness stack consists of fewer than four items the script MUST fail and\n+terminate immediately.\n+\n+(Note: in practice, the witness stack will have included the other items necessary to reveal \n+a witness v1 (or greater) script-path spend, per [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#user-content-Constructing_and_spending_Taproot_outputs BIP-0341]. This is demonstrated in detail in [[#Transaction examples|the transaction examples section]].)\n+\n+The items on the stack must be validated as follows:\n+\n+* <code><trigger-vout-idx></code> is a <code>CScriptNum</code> of up to 4 bytes.\n+** It indicates the vout index of this input's corresponding <code>OP_UNVAULT</code> output.\n+*** Validation rules for this output are described below.\n+** If this value does not decode as a valid CScriptNum value, the script MUST fail and terminate immediately.\n+** If this value does not correspond to a valid output in the spending transaction, the script MUST fail and terminate immediately.\n+\n+* <code><target-outputs-hash></code> is a 32 byte data push.\n+** It is the hash of the proposed withdrawal target output set, defined by <code>target_outputs_hash(outputs)</code> below. Note that this value is duplicated here.<ref>'''Why, when spending an OP_VAULT output into a trigger, does the target hash need to be duplicated on the witness stack?''' The target hash exists in the <code>OP_UNVAULT</code> output script, likely behind a taproot pubkey. Its presence is required on the witness stack also so that the expected taproot pubkey for the <code>OP_UNVAULT</code> output can be constructed for comparison.</ref>\n+** If this value is not 32 bytes, the script MUST fail and terminate immediately.\n+\n+* <code><trigger-sPK></code> is a variable length data push.\n+** It must be the scriptPubKey that is the preimage to the <code><trigger-sPK-hash></code> specified in the spent <code>OP_VAULT</code> input.\n+** If this value does not tagged-hash to <code><trigger-sPK-hash></code> supplied by the <code>OP_VAULT</code> parameter, the script MUST fail and terminate immediately.\n+*** Verify <code>tagged_hash(\"VaultTriggerSPK\", <trigger-sPK>) == <trigger-sPK-hash></code>\n+** If this value does not correspond to a valid witness program, the script MUST fail and terminate immediately.\n+\n+* the remaining elements serve as the witness stack to satisfy the <code><trigger-sPK></code> witness program.\n+** If <code>VerifyWitnessProgram(<remaining stack elements>, <trigger-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the withdrawal trigger has been authorized.)\n+\n+===== Transaction outputs validation =====\n+\n+Once the contents of the witness stack have been parsed and validated, the transaction outputs must be checked.\n+\n+First, we must check for a ''revault output'': an output in the trigger transaction whose",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 359,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": 1133143812,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You can derive a new address via key derivation and send change there. This means the user has to wait for the timelock to run out before re-spending, and at spend time it becomes somewhat obvious which is change due to timelock configuration, at a minimum.",
      "created_at": "2023-03-13T14:33:28Z",
      "updated_at": "2023-03-13T14:33:29Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1134052461",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1134052461"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 359,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1134063376",
      "pull_request_review_id": 1337212751,
      "id": 1134063376,
      "node_id": "PRRC_kwDOAN28mc5DmG8Q",
      "diff_hunk": "@@ -0,0 +1,757 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a solution to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 136,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "00eadde0fbc10e089db05eeff527593bc9663005",
      "in_reply_to_id": 1133142221,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fundamental issue here is that you cannot, sans ZKP magic, get rid of the association.\r\n\r\nThe funds must go from the vault to the specific covenant derivation. If that link wasn't enforced by bitcoin script, it would be useless.",
      "created_at": "2023-03-13T14:39:47Z",
      "updated_at": "2023-03-13T14:39:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1134063376",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1134063376"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1151407472",
      "pull_request_review_id": 1362271442,
      "id": 1151407472,
      "node_id": "PRRC_kwDOAN28mc5EoRVw",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 73,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": 1105535651,
      "user": {
        "login": "19861826",
        "id": 124975449,
        "node_id": "U_kgDOB3L5WQ",
        "avatar_url": "https://avatars.githubusercontent.com/u/124975449?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/19861826",
        "html_url": "https://github.com/19861826",
        "followers_url": "https://api.github.com/users/19861826/followers",
        "following_url": "https://api.github.com/users/19861826/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/19861826/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/19861826/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/19861826/subscriptions",
        "organizations_url": "https://api.github.com/users/19861826/orgs",
        "repos_url": "https://api.github.com/users/19861826/repos",
        "events_url": "https://api.github.com/users/19861826/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/19861826/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> * 錯別字\r\n> * 目前還不清楚“人質情況”是什麼意思。\r\n\r\n",
      "created_at": "2023-03-29T05:23:20Z",
      "updated_at": "2023-03-29T05:23:20Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1151407472",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1151407472"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 73,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1152013901",
      "pull_request_review_id": 1363221045,
      "id": 1152013901,
      "node_id": "PRRC_kwDOAN28mc5EqlZN",
      "diff_hunk": "@@ -0,0 +1,615 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is a \"single signature and\n+passphrase\" with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any Bitcoin script policy: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and leaf another with",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 160,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "0b0674c546eba07583da87d029f42a5da551af42",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit ...?\r\n\r\n```suggestion\r\nfacilitates the expected withdrawal process, and another leaf with\r\n```",
      "created_at": "2023-03-29T14:13:37Z",
      "updated_at": "2023-03-29T14:13:38Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1152013901",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1152013901"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1167355768",
      "pull_request_review_id": 1386289238,
      "id": 1167355768,
      "node_id": "PRRC_kwDOAN28mc5FlG94",
      "diff_hunk": "@@ -0,0 +1,615 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is a \"single signature and\n+passphrase\" with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any Bitcoin script policy: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and leaf another with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked <code>OP_CHECKTEMPLATEVERIFY</code> trigger inputs into a compatible set of final withdrawal outputs per the CTV hash, after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT_RECOVER</code>-tapleaf inputs to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If fewer than <code><n-pushes> + 2</code> items are on the stack, script execution when spending this output MUST fail and terminate immediately.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+** If there are fewer than <code><n-pushes> + 2</code> items on the stack, script execution when spending this output MUST fail and terminate immediately.  \n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a witness program of the same version and same tapleaf version as the currently executing script, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** The leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* If the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output MUST fail and terminate immediately.\n+* (Deferred<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>) the <code>nValue</code> of ''triggerOut'', plus the <code>nValue</code> of ''revaultOut'' if one exists, must equal the sum of all vault inputs which cite it as their corresponding trigger output. If these values are not equal, the script MUST fail and terminate immediately.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== <code>OP_VAULT_RECOVER</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT_RECOVER</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<recovery-sPK-hash>\n+<recovery-vout-idx>\n+</source>\n+\n+where\n+\n+* <code><recovery-sPK-hash></code> is a 32-byte data push.\n+** If this is not 32 bytes in length, script execution when spending this output MUST fail and terminate immediately.\n+* <code><recovery-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the recovery output.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output at index <code><recovery-vout-idx></code> be called ''recoveryOut''.\n+* If the scriptPubKey of ''recoveryOut'' does not have a tagged hash equal to <code><recovery-sPK-hash></code> (<code>tagged_hash(\"VaultRecoverySPK\", recoveryOut.scriptPubKey) == recovery-sPK-hash</code>, where <code>tagged_hash()</code> is from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code]), script execution when spending this output MUST fail and terminate immediately.\n+* If ''recoveryOut'' does not have an <code>nValue</code> greater than or equal to this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if ''recoveryOut'' does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT_RECOVER</code>-spent inputs with a corresponding <code>recovery-sPK-hash</code>, the transaction validation MUST fail.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 298,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "0b0674c546eba07583da87d029f42a5da551af42",
      "in_reply_to_id": null,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not sure this matches the implementation. In the implementation if an input executes multiple OP_VAULT opcodes, I think it will expect multiple times the value of that particular input?",
      "created_at": "2023-04-15T01:46:23Z",
      "updated_at": "2023-04-15T01:46:23Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1167355768",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1167355768"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1171812442",
      "pull_request_review_id": 1392815467,
      "id": 1171812442,
      "node_id": "PRRC_kwDOAN28mc5F2HBa",
      "diff_hunk": "@@ -0,0 +1,615 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is a \"single signature and\n+passphrase\" with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any Bitcoin script policy: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and leaf another with",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 160,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "0b0674c546eba07583da87d029f42a5da551af42",
      "in_reply_to_id": 1152013901,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed, thanks.",
      "created_at": "2023-04-19T20:18:21Z",
      "updated_at": "2023-04-19T20:18:21Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1171812442",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1171812442"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1297862738",
      "pull_request_review_id": 1583658308,
      "id": 1297862738,
      "node_id": "PRRC_kwDOAN28mc5NW9BS",
      "diff_hunk": "@@ -0,0 +1,750 @@\n+<pre>\n+  BIP: xxxx\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-xxxx\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2020-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes new tapscript opcodes, <code>OP_VAULT</code> and\n+<code>OP_UNVAULT</code>, that add consensus support for a specialized covenant. \n+These opcodes allow users to enforce a delay period before designated coins may\n+be spent to an arbitrary destination, with the exception of a prespecified\n+\"recovery\" path. At any time prior to final withdrawal, the coins can be spent to\n+the prespecified path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+An individual custodying Bitcoin uses the common \"single signature and\n+passphrase\" configuration with a hardware wallet. They are concerned about the\n+risk associated with relying on a single manufacturer for key management as\n+well as physical access to the hardware, so they generate a new key that is\n+highly secure, but would be impractical for daily use. For example the key\n+could be generated in some analog fashion, or on an old computer (with added\n+entropy) that is then destroyed, with the private key replicated only in paper\n+form. Or the key could be a 2-of-3 multisig using devices from different\n+manufacturers. Perhaps the key is geographically distributed.\n+\n+This individual can use <code>OP_VAULT</code> to make use of the highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key, with a configured spend delay of 1 day. They can\n+run software on their mobile device that monitors the blockchain for spends of\n+the vault outpoints.\n+\n+If the vaulted coins move in an unexpected way, the user can immediately sweep\n+them to the highly secure recovery path, but spending the coins on a daily\n+basis works in the same way it did prior to vaulting - aside from the spend\n+delay.\n+\n+The recovery key could be any number of things: a 2-of-3 multisig with keys\n+that live on different devices, a 3-of-5 with socially distributed keys, a\n+Taproot construction that incorporates one of these methods along with a\n+time-delayed fallback to an \"easier\" recovery method, in case the highly secure\n+key winds up being ''too'' highly secure.\n+\n+Institutional custodians of Bitcoin would likely use vaults in similar fashion.\n+\n+===== Avoiding the hostage situation =====\n+\n+This proposal uniquely provides a solution to the \"hostage situation;\" by\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-VAULT/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) or earlier. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html\n+in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely delete ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity else value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-VAULT/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. There are no sample vault implementations using\n+these means known to the author.\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdrawal partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, future transaction versions (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3]) and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawik ephemeral anchors].\n+\n+== Design ==\n+\n+=== State machine ===\n+\n+[[File:bip-VAULT/opvault-flow.drawio.png|frame|center]]\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins with an <code>OP_VAULT</code> script invocation.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code> outputs into one compatible <code>OP_UNVAULT</code> output, which broadcasts the intent to withdrawal to some specific set of outputs. This transaction may have an additional output which allocates some of the vault balance into a partial revault, which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> of the originating <code>OP_VAULT</code> output(s).\n+\n+* '''withdrawal transaction''': spends <code>OP_UNVAULT</code> inputs into a compatible set of final withdrawal outputs per the target hash. The only authorization for this spend is the content hash of the withdrawal outputs.\n+\n+* '''recovery transaction''': spends one or more <code>OP_VAULT</code> or <code>OP_UNVAULT</code> inputs, which can be done at any time prior to withdrawal confirmation, to the prespecified recovery path. This transaction can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional scriptPubKey gating the initiation of recovery. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Parameters ===\n+\n+<code><recovery-params></code>\n+\n+The recovery parameters dictate both where funds can be swept to during a\n+recovery, and what kind of authorization (if any) is needed to initiate a\n+recovery. It is specified in the form \n+\n+<source>\n+<recovery sPK tagged hash (32 bytes)>[<optional auth. scriptPubKey ...>]\n+</source>\n+\n+The first component commits to the destination that vault funds can be swept to\n+at any point prior to the finalization of a withdrawal.\n+\n+The recovery scriptPubKey would usually correspond to a spending script that is\n+inconvenient to exercise but highly secure.\n+\n+The second component, the recovery authorization scriptPubKey, is optional. It\n+is a raw scriptPubKey that, if specified, must be satisfied to allow the input\n+to be recovered. The benefit of using this parameter will be discussed later.\n+If this component is not given, the de facto \"authorization\" is the reveal of\n+the <code><recovery sPK tagged hash></code> preimage.\n+\n+Vaults which share the same recovery path can always be swept in batch operations,\n+which is an important practical aspect of managing large numbers of vaults.\n+\n+<code><spend-delay></code>\n+\n+The spend delay dictates the duration of blocks or time which must\n+elapse for the trigger <code>OP_UNVAULT</code> output to be claimable into the\n+withdrawal target outputs. Encoded as the least significant 23 bits of a\n+[https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] style\n+relative locktime.\n+\n+'''Trigger key'''\n+\n+The trigger key, committed to with <code><trigger-sPK-hash></code>, is used to\n+authorize the ''trigger transaction'' - an on-chain declaration to attempt a\n+withdrawal to a certain set of target outputs.\n+\n+This functions as the \"normal\" spending key, but if an attacker obtains access\n+to this key, the outcome is not catastrophic: any withdrawal attempt can be\n+interrupted (within the spend delay) and swept to the recovery path. \n+\n+The trigger key can be an arbitrary scriptPubKey so long as it represents a\n+valid witness program. <code>OP_VAULT</code> outputs which have the same\n+recovery params and spend delay can be spent into the same\n+<code>OP_UNVAULT</code> output for a batched withdrawal process. \n+\n+<code><target-outputs-hash></code>\n+\n+An arbitrary set of target withdrawal outputs that is specified as a parameter to <code>OP_UNVAULT</code> as a 32 byte tagged hash. The preimage is a list of destination output scriptPubKeys and amounts. If the trigger remains uncontested -- if it isn't swept to recovery before the spend delay elapses -- the vaulted funds may be spent into a compatible set of target outputs.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable by high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+content-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are claimed to implement the\n+<code>OP_VAULT</code> and <code>OP_UNVAULT</code> rules, respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+==== Witness program ====\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the witness program is pushed onto the stack for the\n+following result (stack shown top to bottom):\n+\n+<source>\n+OP_VAULT            (*) being evaluated\n+<trigger-sPK-hash> \n+<spend-delay> \n+<recovery-params> \n+</source>\n+\n+where\n+\n+* <code><trigger-sPK-hash></code> is a 32 byte tagged hash of the scriptPubKey used to authorize the spend of this output into an <code>OP_UNVAULT</code> trigger output \n+** <code>tagged_hash(\"VaultTriggerSPK\", spk)</code>, per BIP-0340.\n+** If this value is not 32 bytes, script execution when spending this output MUST fail and terminate immediately. \n+** Because this parameter's scriptPubKey is committed to using a hash, witness version upgradeability for the trigger key is preserved.\n+\n+* <code><spend-delay></code> is a <code>CScriptNum</code>-encoded number (up to 4 bytes) \n+** It is interpreted as the least significant 23 bits of a [https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki BIP-0068] relative timelock.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><recovery-params></code> is a variable length data push, consisting of two components:\n+*# a 32 byte tagged hash, the ''recovery sPK hash'', committing to the scriptPubKey which coins may be recovered to \n+*#* <code>tagged_hash(\"VaultRecoverySPK\", spk)</code> from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code].\n+*# 0 or more bytes that optionally specify a scriptPubKey that needs to be satisfied to authorize the recovery transaction. \n+*#* This optional parameter changes the allowable structure of recovery transactions.\n+** If <code><recovery-params></code> is less than 32 bytes, script execution when spending this output MUST fail and terminate immediately.\n+** Because the recovery scriptPubKey is committed to with a hash, witness version upgradeability is preserved.\n+\n+==== Check for recovery ====\n+\n+After the witness program is parsed, it must be determined whether this input\n+is being spent towards a recovery. If an output in the spending transaction is\n+found whose scriptPubKey hashes to the recovery sPK hash (the\n+first component of <code><recovery-params></code>), the interpreter will\n+evaluate for recovery. Otherwise, the interpreter will evaluate assuming a withdrawal\n+is being triggered.\n+\n+In pseudocode:\n+\n+<source lang=\"python\">\n+is_recovery = False\n+recovery_out: Optional[CTxOut] = None\n+\n+for out in spending_tx.vout:\n+    if tagged_hash(\"VaultRecoverySPK\", out.scriptPubKey) == recovery_sPK_hash:\n+        is_recovery = True\n+        recovery_out = out\n+\n+if is_recovery:\n+    eval_for_recovery()\n+else:\n+    eval_for_withdrawal_trigger()\n+</source>\n+\n+==== <code>OP_VAULT</code> evaluation for recovery spend ====\n+\n+* If the recovery output does not have an <code>nValue</code> greater than this input's amount, the script MUST fail and terminate immediately.\n+* (Deferred) if the recovery output does not have an <code>nValue</code> equal to the sum of all <code>OP_VAULT</code>/<code>OP_UNVAULT</code> inputs with a corresponding recovery sPK hash, the transaction validation MUST fail.\n+** Note that in the draft implementation, this is facilitated by a \"deferred check\" which is queued by the script interpreter, but executed after the script interpreter has finished, in other validation code.<ref>'''Why does this proposal require a \"deferred checks\" framework for correct script evaluation?''' The deferred checks framework is an augmentation to execution of the Bitcoin script interpreter. Currently, the validity of each input is checked in an order-indepdendent manner across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref>\n+* The script must FAIL (by policy, not consensus) and terminate immediately if neither<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], nor\n+*# the version of the recovery transaction has an nVersion equal to 3.\n+\n+The stack may now have 0 or more elements. Any items on the stack will be used to verify the recovery authorization witness program, if any.\n+\n+* If the ''recovery authorization sPK'' is not null:\n+** If <code>VerifyWitnessProgram(<stack elements>, <recovery-auth-sPK>, ...)</code> fails, the script MUST fail and terminate immediately.\n+** (This validates that the recovery has been authorized.)\n+* else (if the recovery is allowed to be unauthorized):\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output not the recovery output is not an ephemeral anchor, the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>",
      "path": "bip-vaults.mediawiki",
      "position": null,
      "original_position": 323,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "b30e37c8a26d6b18415406a5664aaef9929a8ac5",
      "in_reply_to_id": 1105594633,
      "user": {
        "login": "Ruffledfeatherz",
        "id": 122839131,
        "node_id": "U_kgDOB1JgWw",
        "avatar_url": "https://avatars.githubusercontent.com/u/122839131?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Ruffledfeatherz",
        "html_url": "https://github.com/Ruffledfeatherz",
        "followers_url": "https://api.github.com/users/Ruffledfeatherz/followers",
        "following_url": "https://api.github.com/users/Ruffledfeatherz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Ruffledfeatherz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Ruffledfeatherz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Ruffledfeatherz/subscriptions",
        "organizations_url": "https://api.github.com/users/Ruffledfeatherz/orgs",
        "repos_url": "https://api.github.com/users/Ruffledfeatherz/repos",
        "events_url": "https://api.github.com/users/Ruffledfeatherz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Ruffledfeatherz/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "looks like this is it",
      "created_at": "2023-08-18T00:05:58Z",
      "updated_at": "2023-08-18T00:05:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1297862738",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1297862738"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 323,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1312396297",
      "pull_request_review_id": 1605919360,
      "id": 1312396297,
      "node_id": "PRRC_kwDOAN28mc5OOZQJ",
      "diff_hunk": "@@ -0,0 +1,683 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If fewer than <code><n-pushes> + 2</code> items are on the stack, script execution when spending this output MUST fail and terminate immediately.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+** If there are fewer than <code><n-pushes> + 2</code> items on the stack, script execution when spending this output MUST fail and terminate immediately.  ",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 252,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "e2ff23b3f07215450e75779f7f944d24660a9d47",
      "in_reply_to_id": null,
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this should be `n_pushes + 3` according to above diagram? ",
      "created_at": "2023-08-31T23:57:47Z",
      "updated_at": "2023-09-01T01:57:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1312396297",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1312396297"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1312451523",
      "pull_request_review_id": 1605919360,
      "id": 1312451523,
      "node_id": "PRRC_kwDOAN28mc5OOmvD",
      "diff_hunk": "@@ -0,0 +1,683 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If fewer than <code><n-pushes> + 2</code> items are on the stack, script execution when spending this output MUST fail and terminate immediately.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+** If there are fewer than <code><n-pushes> + 2</code> items on the stack, script execution when spending this output MUST fail and terminate immediately.  \n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 260,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "e2ff23b3f07215450e75779f7f944d24660a9d47",
      "in_reply_to_id": null,
      "user": {
        "login": "sanket1729",
        "id": 6881849,
        "node_id": "MDQ6VXNlcjY4ODE4NDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6881849?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sanket1729",
        "html_url": "https://github.com/sanket1729",
        "followers_url": "https://api.github.com/users/sanket1729/followers",
        "following_url": "https://api.github.com/users/sanket1729/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sanket1729/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sanket1729/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sanket1729/subscriptions",
        "organizations_url": "https://api.github.com/users/sanket1729/orgs",
        "repos_url": "https://api.github.com/users/sanket1729/repos",
        "events_url": "https://api.github.com/users/sanket1729/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sanket1729/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think we should fix to CScritpNum(-1) to avoid potential malleability vectors. ",
      "created_at": "2023-09-01T01:56:25Z",
      "updated_at": "2023-09-01T01:57:50Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1312451523",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1312451523"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1312805451",
      "pull_request_review_id": 1606609454,
      "id": 1312805451,
      "node_id": "PRRC_kwDOAN28mc5OP9JL",
      "diff_hunk": "@@ -0,0 +1,683 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If fewer than <code><n-pushes> + 2</code> items are on the stack, script execution when spending this output MUST fail and terminate immediately.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+** If there are fewer than <code><n-pushes> + 2</code> items on the stack, script execution when spending this output MUST fail and terminate immediately.  ",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 252,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "e2ff23b3f07215450e75779f7f944d24660a9d47",
      "in_reply_to_id": 1312396297,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch! I clearly missed updating this when I made `<revault-amt>` explicit (https://github.com/bitcoin/bips/pull/1421/commits/cb50446a65cb8504499e1ebded22539188612bb3).",
      "created_at": "2023-09-01T09:33:01Z",
      "updated_at": "2023-09-01T09:33:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1312805451",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1312805451"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 252,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1312863235",
      "pull_request_review_id": 1606696339,
      "id": 1312863235,
      "node_id": "PRRC_kwDOAN28mc5OQLQD",
      "diff_hunk": "@@ -0,0 +1,683 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If fewer than <code><n-pushes> + 2</code> items are on the stack, script execution when spending this output MUST fail and terminate immediately.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+** If there are fewer than <code><n-pushes> + 2</code> items on the stack, script execution when spending this output MUST fail and terminate immediately.  \n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 260,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "e2ff23b3f07215450e75779f7f944d24660a9d47",
      "in_reply_to_id": 1312451523,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yep, good point. I'll update this.",
      "created_at": "2023-09-01T10:32:29Z",
      "updated_at": "2023-09-01T10:32:29Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1312863235",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1312863235"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 260,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1325069886",
      "pull_request_review_id": 1625440098,
      "id": 1325069886,
      "node_id": "PRRC_kwDOAN28mc5O-vY-",
      "diff_hunk": "@@ -0,0 +1,683 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a witness program of the same version and same tapleaf version as the currently executing script, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 277,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "4aae726be9610a675b362e66f539ce0d5f903a5f",
      "in_reply_to_id": null,
      "user": {
        "login": "twhit223",
        "id": 6600711,
        "node_id": "MDQ6VXNlcjY2MDA3MTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6600711?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/twhit223",
        "html_url": "https://github.com/twhit223",
        "followers_url": "https://api.github.com/users/twhit223/followers",
        "following_url": "https://api.github.com/users/twhit223/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/twhit223/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/twhit223/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/twhit223/subscriptions",
        "organizations_url": "https://api.github.com/users/twhit223/orgs",
        "repos_url": "https://api.github.com/users/twhit223/repos",
        "events_url": "https://api.github.com/users/twhit223/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/twhit223/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think this could use additional clarification. On initial read, I was confused as to why the ''triggerOut'' amount should be greater than or equal to the input amount. To this point, the BIP discusses how once vaulted, an input can be triggered for withdrawal. Fees were glanced over in the beginning. So my mental model was that an input in a vault would be spent through a trigger tx as follows:\r\n> 1. Specify input to be spent (input_idx) which contains an amount (A)\r\n> 2. Specify trigger amt (B)\r\n> 3. Specify revault amt (C)\r\n> 4. Spend input_idx with amt A such that: fee = A - (B + C)\r\n\r\nIn this case, the logic would be that the sum of ''triggerOut'' and ''revaultOut'' must be less than or equal to the value of the input for this tx to be valid. While some clarification is made later in the BIP, I think a discussion of the fee structure needs to happen before walking through the Python code of trigger checks. \r\n\r\n",
      "created_at": "2023-09-13T20:56:14Z",
      "updated_at": "2023-09-13T20:56:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1325069886",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1325069886"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1325073237",
      "pull_request_review_id": 1625445582,
      "id": 1325073237,
      "node_id": "PRRC_kwDOAN28mc5O-wNV",
      "diff_hunk": "@@ -0,0 +1,683 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a witness program of the same version and same tapleaf version as the currently executing script, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.\n+** Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.\n+* Queue a deferred check<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref> that ensures the satoshis for this input's <code>nValue</code> minus <code><revault-amount></code> are included within the output <code>nValue</code> found at <code><trigger-vout-idx></code>.\n+* Queue a deferred check that ensures <code><revault-amount></code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code><revault-vout-idx></code>.\n+** These deferred checks could be characterized in terms of the pseudocode below (in ''Deferred checks'') as<br /><code>TriggerCheck(input_amount, <revault-amount>, <trigger-vout-idx>, <revault-vout-idx>)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== <code>OP_VAULT_RECOVER</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT_RECOVER</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<recovery-sPK-hash>\n+<recovery-vout-idx>\n+</source>\n+\n+where\n+\n+* <code><recovery-sPK-hash></code> is a 32-byte data push.\n+** If this is not 32 bytes in length, script execution when spending this output MUST fail and terminate immediately.\n+* <code><recovery-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the recovery output.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output at index <code><recovery-vout-idx></code> be called ''recoveryOut''.\n+* If the scriptPubKey of ''recoveryOut'' does not have a tagged hash equal to <code><recovery-sPK-hash></code> (<code>tagged_hash(\"VaultRecoverySPK\", recoveryOut.scriptPubKey) == recovery-sPK-hash</code>, where <code>tagged_hash()</code> is from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code]), script execution when spending this output MUST fail and terminate immediately.\n+** Implementation recommendation: if ''recoveryOut'' does not have an <code>nValue</code> greater than or equal to this input's amount, the script SHOULD fail and terminate immediately.\n+* Queue a deferred check that ensures the <code>nValue</code> of ''recoveryOut'' contains the entire <code>nValue</code> of this input.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** This deferred check could be characterized in terms of the pseudocode below as <code>RecoveryCheck(<recovery-vout-idx>, input_amount)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== Deferred check evaluation ===\n+\n+Once all inputs for a transaction are validated per the rules above, any\n+deferred checks queued MUST be evaluated.\n+\n+The Python pseudocode for this is as follows:\n+\n+<source lang=\"python\">\n+class TriggerCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT (withdrawal trigger).\"\"\"\n+    input_amount: int\n+    revault_amount: int\n+    trigger_vout_idx: int\n+    revault_vout_idx: int\n+\n+\n+class RecoveryCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT_RECOVER.\"\"\"\n+    input_amount: int\n+    vout_idx: int\n+\n+\n+def validate_deferred_checks(checks: [DeferredCheck], tx: Transaction) -> bool:\n+    \"\"\"\n+    Ensure that all value from vault inputs being triggered or recovered is preserved\n+    in suitable output nValues.\n+    \"\"\"\n+    # Map to hold expected output values.\n+    out_map: Dict[int, int] = defaultdict(lambda: 0)\n+\n+    for c in checks:\n+        if isinstance(c, TriggerCheck):\n+            out_map[c.trigger_vout_idx] += (c.input_amount - c.revault_amount)\n+\n+            if c.revault_amount > 0:\n+                out_map[c.revault_vout_idx] += c.revault_amount\n+\n+        elif isinstance(c, RecoveryCheck):\n+            out_map[c.vout_idx] += c.input_amount\n+\n+    for (vout_idx, amount_sats) in out_map.items():\n+        # Trigger/recovery value can be greater than the constituent vault input\n+        # amounts.\n+        if tx.vout[vout_idx].nValue < amount_sats:\n+            return False\n+\n+    return True\n+</source>\n+\n+If the above procedure, or an equivalent, returns false, script execution MUST fail and terminate\n+immediately.\n+\n+This ensures that all compatible vault inputs can be batched into shared\n+corresponding trigger or recovery outputs while preserving their entire input value.\n+\n+\n+== Policy changes ==\n+\n+In order to prevent possible pinning attacks, recovery transactions must be replaceable.\n+\n+* When validating an <code>OP_VAULT_RECOVER</code> input being spent, the script MUST fail (by policy, not consensus) and terminate immediately if both<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is not marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], and\n+*# the version of the recovery transaction has an nVersion other than 3.\n+\n+If the script containing <code>OP_VAULT_RECOVER</code> is 34 bytes or less<ref>34 bytes is the length of a recovery script that consists solely of <code><recovery-sPK-hash> OP_VAULT_RECOVER</code>.</ref>, let\n+it be called \"unauthorized,\" because there is no script guarding the recovery\n+process. In order to prevent pinning attacks in the case of unauthorized\n+recovery - since the spend of the input (and the structure of the\n+transaction) is not authorized by a signed signature message - the output structure of\n+unauthorized recovery transaction is limited.\n+\n+* If the recovery is unauthorized, the recovery transaction MUST (by policy) abide by the following constraints:\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output which is not ''recoveryOut'' is not an [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchor], the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+== Implementation ==\n+\n+A sample implementation is available on bitcoin-inquisition [https://github.com/jamesob/bitcoin/tree/2023-01-opvault-inq here], with an associated [https://github.com/bitcoin-inquisition/bitcoin/pull/21 pull request].\n+\n+\n+== Applications ==",
      "path": "bip-0345.mediawiki",
      "position": 394,
      "original_position": 393,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "4aae726be9610a675b362e66f539ce0d5f903a5f",
      "in_reply_to_id": null,
      "user": {
        "login": "twhit223",
        "id": 6600711,
        "node_id": "MDQ6VXNlcjY2MDA3MTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6600711?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/twhit223",
        "html_url": "https://github.com/twhit223",
        "followers_url": "https://api.github.com/users/twhit223/followers",
        "following_url": "https://api.github.com/users/twhit223/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/twhit223/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/twhit223/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/twhit223/subscriptions",
        "organizations_url": "https://api.github.com/users/twhit223/orgs",
        "repos_url": "https://api.github.com/users/twhit223/repos",
        "events_url": "https://api.github.com/users/twhit223/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/twhit223/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For completeness, it would be nice to have a quick mention of the actual \"withdrawal transaction\" mentioned in this section. Even if all it does is state that the withdrawal tx is trivially easy once the trigger timelock has elapsed. ",
      "created_at": "2023-09-13T21:00:18Z",
      "updated_at": "2023-09-13T21:00:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1325073237",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1325073237"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 394,
      "original_line": 393,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1325076750",
      "pull_request_review_id": 1625450963,
      "id": 1325076750,
      "node_id": "PRRC_kwDOAN28mc5O-xEO",
      "diff_hunk": "@@ -0,0 +1,683 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a witness program of the same version and same tapleaf version as the currently executing script, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 277,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "4aae726be9610a675b362e66f539ce0d5f903a5f",
      "in_reply_to_id": 1325069886,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fees aren't a part of the specification, \"protecting input value\" is. It's an accumulator of value-to-outputs over the various OP_VAULT invocations. \r\n\r\nthat said, if you can think of a way to make the text clearer, would be great.",
      "created_at": "2023-09-13T21:04:42Z",
      "updated_at": "2023-09-13T21:04:42Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1325076750",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1325076750"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1325090436",
      "pull_request_review_id": 1625471528,
      "id": 1325090436,
      "node_id": "PRRC_kwDOAN28mc5O-0aE",
      "diff_hunk": "@@ -0,0 +1,683 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a witness program of the same version and same tapleaf version as the currently executing script, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.\n+** Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.\n+* Queue a deferred check<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref> that ensures the satoshis for this input's <code>nValue</code> minus <code><revault-amount></code> are included within the output <code>nValue</code> found at <code><trigger-vout-idx></code>.\n+* Queue a deferred check that ensures <code><revault-amount></code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code><revault-vout-idx></code>.\n+** These deferred checks could be characterized in terms of the pseudocode below (in ''Deferred checks'') as<br /><code>TriggerCheck(input_amount, <revault-amount>, <trigger-vout-idx>, <revault-vout-idx>)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== <code>OP_VAULT_RECOVER</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT_RECOVER</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<recovery-sPK-hash>\n+<recovery-vout-idx>\n+</source>\n+\n+where\n+\n+* <code><recovery-sPK-hash></code> is a 32-byte data push.\n+** If this is not 32 bytes in length, script execution when spending this output MUST fail and terminate immediately.\n+* <code><recovery-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the recovery output.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output at index <code><recovery-vout-idx></code> be called ''recoveryOut''.\n+* If the scriptPubKey of ''recoveryOut'' does not have a tagged hash equal to <code><recovery-sPK-hash></code> (<code>tagged_hash(\"VaultRecoverySPK\", recoveryOut.scriptPubKey) == recovery-sPK-hash</code>, where <code>tagged_hash()</code> is from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code]), script execution when spending this output MUST fail and terminate immediately.\n+** Implementation recommendation: if ''recoveryOut'' does not have an <code>nValue</code> greater than or equal to this input's amount, the script SHOULD fail and terminate immediately.\n+* Queue a deferred check that ensures the <code>nValue</code> of ''recoveryOut'' contains the entire <code>nValue</code> of this input.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** This deferred check could be characterized in terms of the pseudocode below as <code>RecoveryCheck(<recovery-vout-idx>, input_amount)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== Deferred check evaluation ===\n+\n+Once all inputs for a transaction are validated per the rules above, any\n+deferred checks queued MUST be evaluated.\n+\n+The Python pseudocode for this is as follows:\n+\n+<source lang=\"python\">\n+class TriggerCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT (withdrawal trigger).\"\"\"\n+    input_amount: int\n+    revault_amount: int\n+    trigger_vout_idx: int\n+    revault_vout_idx: int\n+\n+\n+class RecoveryCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT_RECOVER.\"\"\"\n+    input_amount: int\n+    vout_idx: int\n+\n+\n+def validate_deferred_checks(checks: [DeferredCheck], tx: Transaction) -> bool:\n+    \"\"\"\n+    Ensure that all value from vault inputs being triggered or recovered is preserved\n+    in suitable output nValues.\n+    \"\"\"\n+    # Map to hold expected output values.\n+    out_map: Dict[int, int] = defaultdict(lambda: 0)\n+\n+    for c in checks:\n+        if isinstance(c, TriggerCheck):\n+            out_map[c.trigger_vout_idx] += (c.input_amount - c.revault_amount)\n+\n+            if c.revault_amount > 0:\n+                out_map[c.revault_vout_idx] += c.revault_amount\n+\n+        elif isinstance(c, RecoveryCheck):\n+            out_map[c.vout_idx] += c.input_amount\n+\n+    for (vout_idx, amount_sats) in out_map.items():\n+        # Trigger/recovery value can be greater than the constituent vault input\n+        # amounts.\n+        if tx.vout[vout_idx].nValue < amount_sats:\n+            return False\n+\n+    return True\n+</source>\n+\n+If the above procedure, or an equivalent, returns false, script execution MUST fail and terminate\n+immediately.\n+\n+This ensures that all compatible vault inputs can be batched into shared\n+corresponding trigger or recovery outputs while preserving their entire input value.\n+\n+\n+== Policy changes ==\n+\n+In order to prevent possible pinning attacks, recovery transactions must be replaceable.\n+\n+* When validating an <code>OP_VAULT_RECOVER</code> input being spent, the script MUST fail (by policy, not consensus) and terminate immediately if both<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is not marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], and\n+*# the version of the recovery transaction has an nVersion other than 3.\n+\n+If the script containing <code>OP_VAULT_RECOVER</code> is 34 bytes or less<ref>34 bytes is the length of a recovery script that consists solely of <code><recovery-sPK-hash> OP_VAULT_RECOVER</code>.</ref>, let\n+it be called \"unauthorized,\" because there is no script guarding the recovery\n+process. In order to prevent pinning attacks in the case of unauthorized\n+recovery - since the spend of the input (and the structure of the\n+transaction) is not authorized by a signed signature message - the output structure of\n+unauthorized recovery transaction is limited.\n+\n+* If the recovery is unauthorized, the recovery transaction MUST (by policy) abide by the following constraints:\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output which is not ''recoveryOut'' is not an [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchor], the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+== Implementation ==\n+\n+A sample implementation is available on bitcoin-inquisition [https://github.com/jamesob/bitcoin/tree/2023-01-opvault-inq here], with an associated [https://github.com/bitcoin-inquisition/bitcoin/pull/21 pull request].\n+\n+\n+== Applications ==\n+\n+The specification above, perhaps surprisingly, does not specifically cover how a relative timelocked withdrawal process with a fixed target is implemented. The tapleaf update semantics specified in <code>OP_VAULT</code> as well as the output-based authorization enabled by <code>OP_VAULT_RECOVER</code> can be used to implement a vault, but they are incomplete without two other pieces:\n+\n+* a way to enforce relative timelocks, like <code>OP_CHECKSEQUENCEVERIFY</code>, and\n+* a way to enforce that proposed withdrawals are ultimately being spent to a precise set of outputs, like <code>OP_CHECKTEMPLATEVERIFY</code>.\n+\n+These two pieces are combined with the tapleaf update capabilities of\n+<code>OP_VAULT</code> to create a vault, described below.\n+\n+=== Creating a vault ===\n+\n+In order to vault coins, they can be spent into a witness v1 <code>scriptPubKey</code>\n+that contains a taptree of the form\n+\n+<source>\n+tr(<internal-pubkey>,\n+  leaves = {\n+    recover: \n+      <recovery-sPK-hash> OP_VAULT_RECOVER,\n+\n+    trigger: \n+      <trigger-auth-pubkey> OP_CHECKSIGVERIFY                     (i)\n+      <spend-delay> 2 $leaf-update-script-body OP_VAULT,          (ii)\n+\n+    ... [ possibly other leaves ]\n+  }\n+)\n+</source>\n+where\n+* <code>$leaf-update-script-body</code> is, for example, <code>OP_CHECKSEQUENCEVERIFY OP_DROP OP_CHECKTEMPLATEVERIFY</code>.\n+** This is one example of a trigger script, but ''any'' script fragment can be used, allowing the creation of different types of vaults. For example, you could use <code>OP_CHECKSEQUENCEVERIFY OP_DROP OP_CHECKSIG</code> to do a time-delayed transfer of the coins to another key. This also future-proofs <code>OP_VAULT</code> for future scripting capabilities.\n+* The script fragment in <code>(i)</code> is called the \"trigger authorization,\" because it gates triggering the withdrawal. This can be done in whatever manner the wallet designer would like.\n+* The script fragment in <code>(ii)</code> is the incomplete <code>OP_VAULT</code> invocation - it will be completed once the rest of the parameters (the CTV target hash, trigger vout index, and revault vout index) are provided by the trigger transaction witness.\n+\n+Typically, the internal key for the vault taproot output will be specified so\n+that it is controlled by the same descriptor as the recovery path, which\n+facilitates another (though probably unused) means of recovering the vault\n+output to the recovery path. This has the potential advantage of recovering the\n+coin without ever revealing it was a vault. \n+\n+Otherwise, the internal key can be chosen to be an unspendable NUMS point to\n+force execution of the taptree contents.\n+\n+=== Triggering a withdrawal ===\n+\n+To make use of the vault, and spend it towards some output, we construct a spend\n+of the above <code>tr()</code> output that simply replaces the \"trigger\" leaf with the \n+full leaf-update script (in this case, a timelocked CTV script):\n+\n+<source>\n+Witness stack:\n+\n+- <revault-amount>\n+- <revault-vout-idx> (-1 if none)\n+- <trigger-vout-idx>\n+- <target-CTV-hash>\n+- <trigger-auth-pubkey-signature>\n+- [ \"trigger\" leaf script contents ]\n+- [ taproot control block prompting a script-path spend to \"trigger\" leaf ]\n+\n+Output scripts:\n+\n+[\n+  tr(<internal-pubkey>,\n+    leaves = {\n+      recover: \n+        <recovery-sPK-hash> OP_VAULT_RECOVER,               <--  unchanged\n+\n+      trigger:\n+        <target-CTV-hash> <spend-delay> \n+        OP_CHECKSEQUENCEVERIFY OP_DROP OP_CHECKTEMPLATEVERIFY  <--  changed per the \n+                                                                    leaf-update\n+                                                                    rules of OP_VAULT\n+       ... [ possibly other leaves ]\n+     }\n+   ),                                                               \n+\n+   [ optional revault output with the\n+     same sPK as the original vault output ],\n+]\n+</source>\n+\n+<code>OP_VAULT</code> has allowed the taptree to be transformed so that the trigger leaf\n+becomes a timelocked CTV script, which is what actually facilitates the announced\n+withdrawal. The withdrawal is interruptible by the recovery path because the\n+\"recover\" leaf is preserved exactly from the original taptree.\n+\n+Note that the CTV hash is specified at spend time using the witness stack, and\n+\"locked in\" via the <code>OP_VAULT</code> spend rules which assert its existence in the output.\n+\n+The vault funds can be recovered at any time prior to the spend of the\n+timelocked CTV script by way of a script-path spend using the \"recover\" leaf.\n+\n+\n+=== Recovery authorization ===\n+\n+When configuring a vault, the user must decide if they want to have the\n+recovery process gated by a script fragment prefixing the\n+<code>OP_VAULT_RECOVER</code> instruction in the \"recover\" leaf. Its use\n+entails trade-offs.\n+\n+==== Unauthorized recovery ====\n+\n+Unauthorized recovery simplifies vault use in that recovery never requires additional information aside from the location of the vault outpoints and the recovery path - the \"authorization\" is simply the reveal of the recovery path, i.e. the preimage of <code><recovery-sPK-hash></code>. \n+\n+But because this reveal is the only authorization necessary to spend the vault coins to recovery, the user must expect to recover all such vaults at once, since an observer can replay this recovery (provided they know the outpoints).\n+\n+Additionally, unauthorized recovery across multiple distinct recovery paths\n+cannot be done in the same transaction, and fee control is more constrained:\n+because the output structure is limited for unauthorized recovery, fee\n+management relies either on inputs which are completely spent to fees or the\n+use of the optional ephemeral anchor and package relay.\n+\n+These limitations are to avoid pinning attacks.\n+\n+==== Authorized recovery ====\n+\n+With authorized recovery, the user must keep track of an additional piece of information: how to solve the recovery authorization script fragment when recovery is required. \n+\n+If this key is lost, the user will be unable to initiate the recovery process for their coins. If an attacker obtains the recovery key, they may grief the user during the recovery process by constructing a low fee rate recovery transaction and broadcasting it (though they will not be able to pin because of the replaceability requirement on recovery transactions).\n+\n+However, authorized recovery configurations have significant benefits. Batched recoveries are possible for vaults with otherwise incompatible recovery parameters. Fee management is much more flexible, since authorized recovery transactions are \"free form\" and unrelated inputs and outputs can be added, potentially to handle fees.\n+\n+==== Recommendation: use a simple, offline recovery authorization key seed ====\n+\n+The benefits of batching and fee management that authorized recovery provides are significant. If the recovery authorization key falls into the hands of an attacker, the outcome is not catastrophic, whereas if the user loses their recovery authorization key as well as their trigger key, the result is likely coin loss. Consequently, the author's recommendation is to use a simple seed for the recovery authorization key that can be written down offline and replicated. \n+\n+Note that the recovery authorization key '''is not''' the recovery path key, and\n+this is '''much different''' than any recommendation on how to generate the\n+recovery path key itself.\n+\n+=== Address reuse and recovery ===\n+\n+When creating a vault, four factors affect the resulting P2TR address:\n+# The internal pubkey (likely belonging to the recovery wallet)\n+# The recovery leaf\n+# The trigger leaf\n+# Any other leaves that exist in the taptree\n+\n+The end user has the option of varying certain contents along descriptors in\n+order to avoid reusing vault addresses without affecting key management, e.g.\n+the trigger authorization pubkeys.\n+\n+Note that when using unauthorized recovery, the reveal of the\n+recovery scriptPubKey will allow any observer to initiate the recovery process\n+for any vault with matching recovery params, provided they are able to locate\n+the vault outpoints. As a result, it is recommended to expect that \n+'''all outputs sharing an identical unauthorized <code><recovery-sPK-hash></code> should be recovered together'''.\n+\n+This situation can be avoided with a comparable key management model by varying\n+the generation of each vault's recovery scriptPubKey along a single descriptor,\n+but note that this will prevent recovering multiple separate vaults into a single\n+recovery output.\n+\n+Varying the internal pubkey will prevent batching the trigger of multiple vault\n+inputs into a single trigger output; consequently it is recommended that users\n+instead vary some component of the trigger leaf script if address reuse is\n+undesirable. Users could vary the trigger pubkey along a descriptor, keeping\n+the recovery path and internal-pubkey the same, which both avoids reusing\n+addresses and allows batched trigger and recovery operations.\n+\n+==== Recommendation: generate new recovery addresses for new trigger keys ====\n+\n+If using unauthorized recovery, it is recommended that you do not share recovery scriptPubKeys\n+across separate trigger keys. If one trigger key is compromised, that will necessitate the (unauthorized)\n+recovery of all vaults with that trigger key, which will reveal the recovery path preimage. This\n+means that an observer might be able to initiate recovery for vaults controlled by an uncompromised\n+trigger key.\n+\n+==== Fee management ====\n+\n+Fees can be managed in a variety of ways, but it's worth noting that both\n+trigger and recovery transactions must preserve the total value of vault\n+inputs, so vaulted values cannot be repurposed to pay for fees. This does not\n+apply to the withdrawal transaction, which can allocate value arbitrarily.\n+\n+In the case of vaults that use recovery authorization, all transactions can\n+\"bring their own fees\" in the form of unrelated inputs and outputs. These\n+transactions are also free to specify ephemeral anchors, once the related relay\n+policies are deployed. This means that vaults using recovery authorization have\n+no dependence on the deploy of v3 relay policy.\n+\n+For vaults using unauthorized recovery, the recovery\n+transaction relies on the use of either fully-spent fee inputs or an ephemeral\n+anchor output. This means that vaults which do not use recovery authorization\n+are essentially dependent on v3 transaction relay policy being deployed.\n+",
      "path": "bip-0345.mediawiki",
      "position": 581,
      "original_position": 580,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "4aae726be9610a675b362e66f539ce0d5f903a5f",
      "in_reply_to_id": null,
      "user": {
        "login": "twhit223",
        "id": 6600711,
        "node_id": "MDQ6VXNlcjY2MDA3MTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6600711?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/twhit223",
        "html_url": "https://github.com/twhit223",
        "followers_url": "https://api.github.com/users/twhit223/followers",
        "following_url": "https://api.github.com/users/twhit223/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/twhit223/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/twhit223/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/twhit223/subscriptions",
        "organizations_url": "https://api.github.com/users/twhit223/orgs",
        "repos_url": "https://api.github.com/users/twhit223/repos",
        "events_url": "https://api.github.com/users/twhit223/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/twhit223/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Is the interpretation of this that vaults using unauthorized recovery could \"pre-load\" themselves with varying size UTXOs to pay for fees based on the fee rate at the time of trigger (with the understanding that those UTXOs will have to be fully spent towards fees)? The last sentence makes it sound like unauthorized recovery is unusable without v3 transaction relay being deployed. A bit more clarification here would be helpful. ",
      "created_at": "2023-09-13T21:22:19Z",
      "updated_at": "2023-09-13T21:22:19Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1325090436",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1325090436"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 581,
      "original_line": 580,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1345603139",
      "pull_request_review_id": 1657249307,
      "id": 1345603139,
      "node_id": "PRRC_kwDOAN28mc5QNEZD",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 49,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "014b832e07d3be3c6aff1230d560fcf7032f0495",
      "in_reply_to_id": null,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit\r\n```suggestion\r\nconfiguration might be concerned about the risk associated with relying on a\r\n```",
      "created_at": "2023-10-04T10:55:24Z",
      "updated_at": "2023-10-04T10:55:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1345603139",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1345603139"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 49,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1345761010",
      "pull_request_review_id": 1657479607,
      "id": 1345761010,
      "node_id": "PRRC_kwDOAN28mc5QNq7y",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Decrement the per-script sigops budget (see [https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#user-content-Resource_limits BIP-0342]) by 60<ref>'''Why is the sigops cost for OP_VAULT set to 60?''' To determine the validity of a trigger output, OP_VAULT must perform an EC multiplication and hashing proportional to the length of the control block in order to generate the output's expected TapTweak. This has been measured to have a cost in the worst case (max length control block) of roughly twice a Schnorr verification. Because the hashing cost could be mitigated by caching midstate, the cost is 60 and not 100.</ref>; if the budget is brought below zero, script execution MUST fail and terminate immediately.\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a witness program of the same version and same tapleaf version as the currently executing script, script execution MUST fail and terminate immediately.",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 271,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "014b832e07d3be3c6aff1230d560fcf7032f0495",
      "in_reply_to_id": null,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The scriptPubKey doesn't have a tapleaf version, i think you should only keep the witness program version check here?\r\n```suggestion\r\n* If the scriptPubKey of ''triggerOut'' is not a witness program of the same version, script execution MUST fail and terminate immediately.\r\n```\r\n\r\nIn fact, since this is only defined for segwit v1 this may as well check explicitly for it?\r\n```suggestion\r\n* If the scriptPubKey of ''triggerOut'' is not a version 1 witness program, script execution MUST fail and terminate immediately.\r\n```",
      "created_at": "2023-10-04T13:01:46Z",
      "updated_at": "2023-10-04T13:01:47Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1345761010",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1345761010"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 271,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1350637359",
      "pull_request_review_id": 1665033266,
      "id": 1350637359,
      "node_id": "PRRC_kwDOAN28mc5QgRcv",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Decrement the per-script sigops budget (see [https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#user-content-Resource_limits BIP-0342]) by 60<ref>'''Why is the sigops cost for OP_VAULT set to 60?''' To determine the validity of a trigger output, OP_VAULT must perform an EC multiplication and hashing proportional to the length of the control block in order to generate the output's expected TapTweak. This has been measured to have a cost in the worst case (max length control block) of roughly twice a Schnorr verification. Because the hashing cost could be mitigated by caching midstate, the cost is 60 and not 100.</ref>; if the budget is brought below zero, script execution MUST fail and terminate immediately.\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a witness program of the same version and same tapleaf version as the currently executing script, script execution MUST fail and terminate immediately.",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 271,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "014b832e07d3be3c6aff1230d560fcf7032f0495",
      "in_reply_to_id": 1345761010,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good observation, fixed. cc @instagibbs",
      "created_at": "2023-10-09T18:07:03Z",
      "updated_at": "2023-10-09T18:07:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1350637359",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1350637359"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 271,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357788739",
      "pull_request_review_id": 1675754288,
      "id": 1357788739,
      "node_id": "PRRC_kwDOAN28mc5Q7jZD",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===",
      "path": "bip-0345.mediawiki",
      "position": 227,
      "original_position": 227,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'd like to review the discussion from [bitcoin-dev 2023-03](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021528.html), with a slightly different opcode split.\r\n\r\nWhat we currently have is:\r\n\r\n * `[revault_amount revault_idx] [unvault_idx unvault_pushes unvault_n unvault_script] OP_VAULT`\r\n * `[idx hash] OP_VAULT_RECOVER`\r\n\r\nwhere `OP_VAULT` does both unvaulting and revaulting, and both do `scriptPubKey` checks and deferred amount checks.\r\n\r\nWhat I'd like to propose for consideration is:\r\n\r\n * `[idx amount] OP_REVAULT`\r\n * `[idx amount pushes... n script] OP_UNVAULT`\r\n * `[idx amount sPK] OP_VAULT_RECOVER` (~`OP_VAULT_FREEZE`~)\r\n\r\nwith the behaviour that `idx amount` specifies the given amount from this input is aggregated into the output at idx (via the deferred checks), and the `scriptPubKey` at idx matches (respectively) the scriptPubKey being spent by this input, the scriptPubKey you get by replacing the current tapleaf with the script prefixed by n-pushes of the given n stack items, or the given sPK. If the amount is -1 that represents the remaining value from this input. If the amount is 0, or the amount is -1 but the remaining amount is 0, the operation succeeds. If the operation succeeds, `1` is left on the stack.\r\n\r\nI think that's a slightly better split, in that it separates out the \"spend/revault\" operations into separate opcodes, and also make the \"claim the entire remainder\" vs \"claim and explicit remount\" logic available to each vault operation. \r\n\r\nIt's possible to go further in breaking down the logic:\r\n\r\n * you could split out the amount verification and the scriptPubKey verification into different opcodes, but then you need to manually link the `idx` between the two, but that seems to just gets awkward for no real benefit (there's no point restricting an output amount or an output scriptPubKey on their own, after all)\r\n * you could split out the \"build up a script by prefixing pushes\" operation from the \"verify a scriptPubKey is made up by replacing the current script with a given script\"; but that seems slightly exploitable (as you could be building up a script much larger than 520 bytes)\r\n\r\nYou can reimplement OP_VAULT as:\r\n\r\n   * `[unvault_idx unvault_amt unvault_pushes... unvault_n unvault_script] [revault_idx revault_amount] ` (input)\r\n   * `OVER TOALT REVAULT DROP UNVAULT DROP -1 FROMALT REVAULT` (script)\r\n\r\nI think this enables plausible new behaviour compared to the current spec; eg limiting the amount you can withdraw:\r\n\r\n   * `[unvault_idx unvault_amt unvault_pushes... unvault_n unvault_script] [revault_idx revault_amount] ` (input)\r\n  * `OVER TOALT REVAULT DROP`\r\n  * `TOALT DUP 1ADD PICK DUP 0 GT VERIFY <limit> LT VERIFY FROMALT UNVAULT`\r\n  * `DROP -1 FROMALT REVAULT`\r\n\r\nOr a \"hodl until day D, but allow consolidations\" script:\r\n\r\n  * `[sigA]` to spend after `D`, or `[idx sigA]` to consolidate to output `idx`\r\n  * `A CHECKSIGVERIFY DEPTH IF -1 REVAULT ELSE <D> CLTV ENDIF`",
      "created_at": "2023-10-13T05:41:08Z",
      "updated_at": "2023-11-06T00:39:35Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1357788739",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357788739"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 227,
      "original_line": 227,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357794539",
      "pull_request_review_id": 1675762428,
      "id": 1357794539,
      "node_id": "PRRC_kwDOAN28mc5Q7kzr",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 235,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should use either `n-pushes` or `n` consistently.",
      "created_at": "2023-10-13T05:51:08Z",
      "updated_at": "2023-10-13T06:27:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1357794539",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357794539"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 235,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357801965",
      "pull_request_review_id": 1675762428,
      "id": 1357801965,
      "node_id": "PRRC_kwDOAN28mc5Q7mnt",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 246,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"minimally-encoded `CScriptNum`\" ?\r\n\r\ns/prepend/prefix/g :smile:",
      "created_at": "2023-10-13T06:03:13Z",
      "updated_at": "2023-10-13T06:27:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1357801965",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357801965"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 246,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357805436",
      "pull_request_review_id": 1675762428,
      "id": 1357805436,
      "node_id": "PRRC_kwDOAN28mc5Q7nd8",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 263,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"when spending this output\" seems redundant and slightly confusing (we're looking at an input not an output; the entire tx fails not just this output; and other attempts to spend this output could succeed) -- why not just \"script execution MUST fail and terminate immediately\" here and elsewhere?",
      "created_at": "2023-10-13T06:08:26Z",
      "updated_at": "2023-10-13T06:27:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1357805436",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357805436"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 263,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357805922",
      "pull_request_review_id": 1675762428,
      "id": 1357805922,
      "node_id": "PRRC_kwDOAN28mc5Q7nli",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 265,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If this value is zero, `<revault-vout-idx>` must be `-1` ? Otherwise you still have malleability?",
      "created_at": "2023-10-13T06:09:18Z",
      "updated_at": "2023-10-13T06:27:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1357805922",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357805922"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 265,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357811051",
      "pull_request_review_id": 1675762428,
      "id": 1357811051,
      "node_id": "PRRC_kwDOAN28mc5Q7o1r",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Decrement the per-script sigops budget (see [https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#user-content-Resource_limits BIP-0342]) by 60<ref>'''Why is the sigops cost for OP_VAULT set to 60?''' To determine the validity of a trigger output, OP_VAULT must perform an EC multiplication and hashing proportional to the length of the control block in order to generate the output's expected TapTweak. This has been measured to have a cost in the worst case (max length control block) of roughly twice a Schnorr verification. Because the hashing cost could be mitigated by caching midstate, the cost is 60 and not 100.</ref>; if the budget is brought below zero, script execution MUST fail and terminate immediately.\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a version 1 witness program, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.\n+** Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.\n+* Queue a deferred check<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref> that ensures the satoshis for this input's <code>nValue</code> minus <code><revault-amount></code> are included within the output <code>nValue</code> found at <code><trigger-vout-idx></code>.\n+* Queue a deferred check that ensures <code><revault-amount></code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code><revault-vout-idx></code>.\n+** These deferred checks could be characterized in terms of the pseudocode below (in ''Deferred checks'') as<br /><code>TriggerCheck(input_amount, <revault-amount>, <trigger-vout-idx>, <revault-vout-idx>)</code>.\n+",
      "path": "bip-0345.mediawiki",
      "position": 283,
      "original_position": 283,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In so far as rehashing the tapleaf path with a replaced script can be expensive, perhaps an implementation recommendation should be made to store the `H_TapLeaf()` value after the first successful `OP_VAULT`, and afterwards simply compare if the hashed script matches the cached value, without recalculating the merkle root and taproot tweak.",
      "created_at": "2023-10-13T06:17:13Z",
      "updated_at": "2023-10-13T06:27:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1357811051",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357811051"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 283,
      "original_line": 283,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357811848",
      "pull_request_review_id": 1675762428,
      "id": 1357811848,
      "node_id": "PRRC_kwDOAN28mc5Q7pCI",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Decrement the per-script sigops budget (see [https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#user-content-Resource_limits BIP-0342]) by 60<ref>'''Why is the sigops cost for OP_VAULT set to 60?''' To determine the validity of a trigger output, OP_VAULT must perform an EC multiplication and hashing proportional to the length of the control block in order to generate the output's expected TapTweak. This has been measured to have a cost in the worst case (max length control block) of roughly twice a Schnorr verification. Because the hashing cost could be mitigated by caching midstate, the cost is 60 and not 100.</ref>; if the budget is brought below zero, script execution MUST fail and terminate immediately.\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a version 1 witness program, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.\n+** Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.\n+* Queue a deferred check<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref> that ensures the satoshis for this input's <code>nValue</code> minus <code><revault-amount></code> are included within the output <code>nValue</code> found at <code><trigger-vout-idx></code>.\n+* Queue a deferred check that ensures <code><revault-amount></code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code><revault-vout-idx></code>.\n+** These deferred checks could be characterized in terms of the pseudocode below (in ''Deferred checks'') as<br /><code>TriggerCheck(input_amount, <revault-amount>, <trigger-vout-idx>, <revault-vout-idx>)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.",
      "path": "bip-0345.mediawiki",
      "position": 284,
      "original_position": 284,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "These are all effectively `*VERIFY` operations that either succeed or abort execution; seems slightly strange to leave a true value on the stack.",
      "created_at": "2023-10-13T06:18:20Z",
      "updated_at": "2023-10-13T06:27:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1357811848",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357811848"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 284,
      "original_line": 284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357814856",
      "pull_request_review_id": 1675762428,
      "id": 1357814856,
      "node_id": "PRRC_kwDOAN28mc5Q7pxI",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Decrement the per-script sigops budget (see [https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#user-content-Resource_limits BIP-0342]) by 60<ref>'''Why is the sigops cost for OP_VAULT set to 60?''' To determine the validity of a trigger output, OP_VAULT must perform an EC multiplication and hashing proportional to the length of the control block in order to generate the output's expected TapTweak. This has been measured to have a cost in the worst case (max length control block) of roughly twice a Schnorr verification. Because the hashing cost could be mitigated by caching midstate, the cost is 60 and not 100.</ref>; if the budget is brought below zero, script execution MUST fail and terminate immediately.\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a version 1 witness program, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 273,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This still seems ambiguous? If the top of the stack is A and the next element is B; having the script push A then B will mean that B is on the top of the stack when the remainder of the script is executed.",
      "created_at": "2023-10-13T06:22:48Z",
      "updated_at": "2023-10-13T06:27:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1357814856",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357814856"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357815420",
      "pull_request_review_id": 1675762428,
      "id": 1357815420,
      "node_id": "PRRC_kwDOAN28mc5Q7p58",
      "diff_hunk": "@@ -0,0 +1,683 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a witness program of the same version and same tapleaf version as the currently executing script, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 277,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "4aae726be9610a675b362e66f539ce0d5f903a5f",
      "in_reply_to_id": 1325069886,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"implementation\" has two n's in it",
      "created_at": "2023-10-13T06:23:39Z",
      "updated_at": "2023-10-13T06:27:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1357815420",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357815420"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357816644",
      "pull_request_review_id": 1675762428,
      "id": 1357816644,
      "node_id": "PRRC_kwDOAN28mc5Q7qNE",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Decrement the per-script sigops budget (see [https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#user-content-Resource_limits BIP-0342]) by 60<ref>'''Why is the sigops cost for OP_VAULT set to 60?''' To determine the validity of a trigger output, OP_VAULT must perform an EC multiplication and hashing proportional to the length of the control block in order to generate the output's expected TapTweak. This has been measured to have a cost in the worst case (max length control block) of roughly twice a Schnorr verification. Because the hashing cost could be mitigated by caching midstate, the cost is 60 and not 100.</ref>; if the budget is brought below zero, script execution MUST fail and terminate immediately.\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a version 1 witness program, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.\n+** Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.\n+* Queue a deferred check<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref> that ensures the satoshis for this input's <code>nValue</code> minus <code><revault-amount></code> are included within the output <code>nValue</code> found at <code><trigger-vout-idx></code>.\n+* Queue a deferred check that ensures <code><revault-amount></code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code><revault-vout-idx></code>.\n+** These deferred checks could be characterized in terms of the pseudocode below (in ''Deferred checks'') as<br /><code>TriggerCheck(input_amount, <revault-amount>, <trigger-vout-idx>, <revault-vout-idx>)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== <code>OP_VAULT_RECOVER</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT_RECOVER</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<recovery-sPK-hash>\n+<recovery-vout-idx>\n+</source>\n+\n+where\n+\n+* <code><recovery-sPK-hash></code> is a 32-byte data push.\n+** If this is not 32 bytes in length, script execution when spending this output MUST fail and terminate immediately.\n+* <code><recovery-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the recovery output.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output at index <code><recovery-vout-idx></code> be called ''recoveryOut''.\n+* If the scriptPubKey of ''recoveryOut'' does not have a tagged hash equal to <code><recovery-sPK-hash></code> (<code>tagged_hash(\"VaultRecoverySPK\", recoveryOut.scriptPubKey) == recovery-sPK-hash</code>, where <code>tagged_hash()</code> is from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code]), script execution when spending this output MUST fail and terminate immediately.\n+** Implementation recommendation: if ''recoveryOut'' does not have an <code>nValue</code> greater than or equal to this input's amount, the script SHOULD fail and terminate immediately.\n+* Queue a deferred check that ensures the <code>nValue</code> of ''recoveryOut'' contains the entire <code>nValue</code> of this input.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** This deferred check could be characterized in terms of the pseudocode below as <code>RecoveryCheck(<recovery-vout-idx>, input_amount)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== Deferred check evaluation ===\n+\n+Once all inputs for a transaction are validated per the rules above, any\n+deferred checks queued MUST be evaluated.\n+\n+The Python pseudocode for this is as follows:\n+\n+<source lang=\"python\">\n+class TriggerCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT (withdrawal trigger).\"\"\"\n+    input_amount: int\n+    revault_amount: int\n+    trigger_vout_idx: int\n+    revault_vout_idx: int\n+\n+\n+class RecoveryCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT_RECOVER.\"\"\"\n+    input_amount: int\n+    vout_idx: int\n+\n+\n+def validate_deferred_checks(checks: [DeferredCheck], tx: Transaction) -> bool:\n+    \"\"\"\n+    Ensure that all value from vault inputs being triggered or recovered is preserved\n+    in suitable output nValues.\n+    \"\"\"\n+    # Map to hold expected output values.\n+    out_map: Dict[int, int] = defaultdict(lambda: 0)\n+\n+    for c in checks:\n+        if isinstance(c, TriggerCheck):\n+            out_map[c.trigger_vout_idx] += (c.input_amount - c.revault_amount)\n+\n+            if c.revault_amount > 0:\n+                out_map[c.revault_vout_idx] += c.revault_amount\n+\n+        elif isinstance(c, RecoveryCheck):\n+            out_map[c.vout_idx] += c.input_amount\n+\n+    for (vout_idx, amount_sats) in out_map.items():\n+        # Trigger/recovery value can be greater than the constituent vault input\n+        # amounts.\n+        if tx.vout[vout_idx].nValue < amount_sats:\n+            return False\n+\n+    return True\n+</source>\n+\n+If the above procedure, or an equivalent, returns false, script execution MUST fail and terminate\n+immediately.\n+\n+This ensures that all compatible vault inputs can be batched into shared\n+corresponding trigger or recovery outputs while preserving their entire input value.\n+\n+\n+== Policy changes ==",
      "path": "bip-0345.mediawiki",
      "position": 370,
      "original_position": 370,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not sure the policy changes thoughts really make sense/add very much in this document.",
      "created_at": "2023-10-13T06:25:21Z",
      "updated_at": "2023-10-13T06:27:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1357816644",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357816644"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 370,
      "original_line": 370,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357817076",
      "pull_request_review_id": 1675762428,
      "id": 1357817076,
      "node_id": "PRRC_kwDOAN28mc5Q7qT0",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Decrement the per-script sigops budget (see [https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#user-content-Resource_limits BIP-0342]) by 60<ref>'''Why is the sigops cost for OP_VAULT set to 60?''' To determine the validity of a trigger output, OP_VAULT must perform an EC multiplication and hashing proportional to the length of the control block in order to generate the output's expected TapTweak. This has been measured to have a cost in the worst case (max length control block) of roughly twice a Schnorr verification. Because the hashing cost could be mitigated by caching midstate, the cost is 60 and not 100.</ref>; if the budget is brought below zero, script execution MUST fail and terminate immediately.\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a version 1 witness program, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.\n+** Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.\n+* Queue a deferred check<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref> that ensures the satoshis for this input's <code>nValue</code> minus <code><revault-amount></code> are included within the output <code>nValue</code> found at <code><trigger-vout-idx></code>.\n+* Queue a deferred check that ensures <code><revault-amount></code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code><revault-vout-idx></code>.\n+** These deferred checks could be characterized in terms of the pseudocode below (in ''Deferred checks'') as<br /><code>TriggerCheck(input_amount, <revault-amount>, <trigger-vout-idx>, <revault-vout-idx>)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== <code>OP_VAULT_RECOVER</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT_RECOVER</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<recovery-sPK-hash>\n+<recovery-vout-idx>\n+</source>\n+\n+where\n+\n+* <code><recovery-sPK-hash></code> is a 32-byte data push.\n+** If this is not 32 bytes in length, script execution when spending this output MUST fail and terminate immediately.\n+* <code><recovery-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the recovery output.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output at index <code><recovery-vout-idx></code> be called ''recoveryOut''.\n+* If the scriptPubKey of ''recoveryOut'' does not have a tagged hash equal to <code><recovery-sPK-hash></code> (<code>tagged_hash(\"VaultRecoverySPK\", recoveryOut.scriptPubKey) == recovery-sPK-hash</code>, where <code>tagged_hash()</code> is from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code]), script execution when spending this output MUST fail and terminate immediately.\n+** Implementation recommendation: if ''recoveryOut'' does not have an <code>nValue</code> greater than or equal to this input's amount, the script SHOULD fail and terminate immediately.\n+* Queue a deferred check that ensures the <code>nValue</code> of ''recoveryOut'' contains the entire <code>nValue</code> of this input.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** This deferred check could be characterized in terms of the pseudocode below as <code>RecoveryCheck(<recovery-vout-idx>, input_amount)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== Deferred check evaluation ===\n+\n+Once all inputs for a transaction are validated per the rules above, any\n+deferred checks queued MUST be evaluated.\n+\n+The Python pseudocode for this is as follows:\n+\n+<source lang=\"python\">\n+class TriggerCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT (withdrawal trigger).\"\"\"\n+    input_amount: int\n+    revault_amount: int\n+    trigger_vout_idx: int\n+    revault_vout_idx: int\n+\n+\n+class RecoveryCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT_RECOVER.\"\"\"\n+    input_amount: int\n+    vout_idx: int\n+\n+\n+def validate_deferred_checks(checks: [DeferredCheck], tx: Transaction) -> bool:\n+    \"\"\"\n+    Ensure that all value from vault inputs being triggered or recovered is preserved\n+    in suitable output nValues.\n+    \"\"\"\n+    # Map to hold expected output values.\n+    out_map: Dict[int, int] = defaultdict(lambda: 0)\n+\n+    for c in checks:\n+        if isinstance(c, TriggerCheck):\n+            out_map[c.trigger_vout_idx] += (c.input_amount - c.revault_amount)\n+\n+            if c.revault_amount > 0:\n+                out_map[c.revault_vout_idx] += c.revault_amount\n+\n+        elif isinstance(c, RecoveryCheck):\n+            out_map[c.vout_idx] += c.input_amount\n+\n+    for (vout_idx, amount_sats) in out_map.items():\n+        # Trigger/recovery value can be greater than the constituent vault input\n+        # amounts.\n+        if tx.vout[vout_idx].nValue < amount_sats:\n+            return False\n+\n+    return True\n+</source>\n+\n+If the above procedure, or an equivalent, returns false, script execution MUST fail and terminate\n+immediately.\n+\n+This ensures that all compatible vault inputs can be batched into shared\n+corresponding trigger or recovery outputs while preserving their entire input value.\n+\n+\n+== Policy changes ==\n+\n+In order to prevent possible pinning attacks, recovery transactions must be replaceable.\n+\n+* When validating an <code>OP_VAULT_RECOVER</code> input being spent, the script MUST fail (by policy, not consensus) and terminate immediately if both<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is not marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], and\n+*# the version of the recovery transaction has an nVersion other than 3.\n+\n+If the script containing <code>OP_VAULT_RECOVER</code> is 34 bytes or less<ref>34 bytes is the length of a recovery script that consists solely of <code><recovery-sPK-hash> OP_VAULT_RECOVER</code>.</ref>, let\n+it be called \"unauthorized,\" because there is no script guarding the recovery\n+process. In order to prevent pinning attacks in the case of unauthorized\n+recovery - since the spend of the input (and the structure of the\n+transaction) is not authorized by a signed signature message - the output structure of\n+unauthorized recovery transaction is limited.\n+\n+* If the recovery is unauthorized, the recovery transaction MUST (by policy) abide by the following constraints:\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output which is not ''recoveryOut'' is not an [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchor], the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+== Implementation ==\n+\n+A sample implementation is available on bitcoin-inquisition [https://github.com/jamesob/bitcoin/tree/2023-01-opvault-inq here], with an associated [https://github.com/bitcoin-inquisition/bitcoin/pull/21 pull request].\n+\n+\n+== Applications ==\n+\n+The specification above, perhaps surprisingly, does not specifically cover how a relative timelocked withdrawal process with a fixed target is implemented. The tapleaf update semantics specified in <code>OP_VAULT</code> as well as the output-based authorization enabled by <code>OP_VAULT_RECOVER</code> can be used to implement a vault, but they are incomplete without two other pieces:\n+\n+* a way to enforce relative timelocks, like <code>OP_CHECKSEQUENCEVERIFY</code>, and\n+* a way to enforce that proposed withdrawals are ultimately being spent to a precise set of outputs, like <code>OP_CHECKTEMPLATEVERIFY</code>.\n+\n+These two pieces are combined with the tapleaf update capabilities of\n+<code>OP_VAULT</code> to create a vault, described below.\n+\n+=== Creating a vault ===\n+\n+In order to vault coins, they can be spent into a witness v1 <code>scriptPubKey</code>\n+that contains a taptree of the form\n+\n+<source>\n+tr(<internal-pubkey>,\n+  leaves = {\n+    recover: \n+      <recovery-sPK-hash> OP_VAULT_RECOVER,\n+\n+    trigger: \n+      <trigger-auth-pubkey> OP_CHECKSIGVERIFY                     (i)\n+      <spend-delay> 2 $leaf-update-script-body OP_VAULT,          (ii)\n+\n+    ... [ possibly other leaves ]\n+  }\n+)\n+</source>",
      "path": "bip-0345.mediawiki",
      "position": 422,
      "original_position": 422,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Might be asking too much, but these seem like they would be better as diagrams?",
      "created_at": "2023-10-13T06:26:00Z",
      "updated_at": "2023-10-13T06:27:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1357817076",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357817076"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 422,
      "original_line": 422,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357818371",
      "pull_request_review_id": 1675762428,
      "id": 1357818371,
      "node_id": "PRRC_kwDOAN28mc5Q7qoD",
      "diff_hunk": "@@ -0,0 +1,683 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a witness program of the same version and same tapleaf version as the currently executing script, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.\n+** Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.\n+* Queue a deferred check<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref> that ensures the satoshis for this input's <code>nValue</code> minus <code><revault-amount></code> are included within the output <code>nValue</code> found at <code><trigger-vout-idx></code>.\n+* Queue a deferred check that ensures <code><revault-amount></code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code><revault-vout-idx></code>.\n+** These deferred checks could be characterized in terms of the pseudocode below (in ''Deferred checks'') as<br /><code>TriggerCheck(input_amount, <revault-amount>, <trigger-vout-idx>, <revault-vout-idx>)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== <code>OP_VAULT_RECOVER</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT_RECOVER</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<recovery-sPK-hash>\n+<recovery-vout-idx>\n+</source>\n+\n+where\n+\n+* <code><recovery-sPK-hash></code> is a 32-byte data push.\n+** If this is not 32 bytes in length, script execution when spending this output MUST fail and terminate immediately.\n+* <code><recovery-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the recovery output.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output at index <code><recovery-vout-idx></code> be called ''recoveryOut''.\n+* If the scriptPubKey of ''recoveryOut'' does not have a tagged hash equal to <code><recovery-sPK-hash></code> (<code>tagged_hash(\"VaultRecoverySPK\", recoveryOut.scriptPubKey) == recovery-sPK-hash</code>, where <code>tagged_hash()</code> is from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code]), script execution when spending this output MUST fail and terminate immediately.\n+** Implementation recommendation: if ''recoveryOut'' does not have an <code>nValue</code> greater than or equal to this input's amount, the script SHOULD fail and terminate immediately.\n+* Queue a deferred check that ensures the <code>nValue</code> of ''recoveryOut'' contains the entire <code>nValue</code> of this input.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** This deferred check could be characterized in terms of the pseudocode below as <code>RecoveryCheck(<recovery-vout-idx>, input_amount)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== Deferred check evaluation ===\n+\n+Once all inputs for a transaction are validated per the rules above, any\n+deferred checks queued MUST be evaluated.\n+\n+The Python pseudocode for this is as follows:\n+\n+<source lang=\"python\">\n+class TriggerCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT (withdrawal trigger).\"\"\"\n+    input_amount: int\n+    revault_amount: int\n+    trigger_vout_idx: int\n+    revault_vout_idx: int\n+\n+\n+class RecoveryCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT_RECOVER.\"\"\"\n+    input_amount: int\n+    vout_idx: int\n+\n+\n+def validate_deferred_checks(checks: [DeferredCheck], tx: Transaction) -> bool:\n+    \"\"\"\n+    Ensure that all value from vault inputs being triggered or recovered is preserved\n+    in suitable output nValues.\n+    \"\"\"\n+    # Map to hold expected output values.\n+    out_map: Dict[int, int] = defaultdict(lambda: 0)\n+\n+    for c in checks:\n+        if isinstance(c, TriggerCheck):\n+            out_map[c.trigger_vout_idx] += (c.input_amount - c.revault_amount)\n+\n+            if c.revault_amount > 0:\n+                out_map[c.revault_vout_idx] += c.revault_amount\n+\n+        elif isinstance(c, RecoveryCheck):\n+            out_map[c.vout_idx] += c.input_amount\n+\n+    for (vout_idx, amount_sats) in out_map.items():\n+        # Trigger/recovery value can be greater than the constituent vault input\n+        # amounts.\n+        if tx.vout[vout_idx].nValue < amount_sats:\n+            return False\n+\n+    return True\n+</source>\n+\n+If the above procedure, or an equivalent, returns false, script execution MUST fail and terminate\n+immediately.\n+\n+This ensures that all compatible vault inputs can be batched into shared\n+corresponding trigger or recovery outputs while preserving their entire input value.\n+\n+\n+== Policy changes ==\n+\n+In order to prevent possible pinning attacks, recovery transactions must be replaceable.\n+\n+* When validating an <code>OP_VAULT_RECOVER</code> input being spent, the script MUST fail (by policy, not consensus) and terminate immediately if both<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is not marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], and\n+*# the version of the recovery transaction has an nVersion other than 3.\n+\n+If the script containing <code>OP_VAULT_RECOVER</code> is 34 bytes or less<ref>34 bytes is the length of a recovery script that consists solely of <code><recovery-sPK-hash> OP_VAULT_RECOVER</code>.</ref>, let\n+it be called \"unauthorized,\" because there is no script guarding the recovery\n+process. In order to prevent pinning attacks in the case of unauthorized\n+recovery - since the spend of the input (and the structure of the\n+transaction) is not authorized by a signed signature message - the output structure of\n+unauthorized recovery transaction is limited.\n+\n+* If the recovery is unauthorized, the recovery transaction MUST (by policy) abide by the following constraints:\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output which is not ''recoveryOut'' is not an [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchor], the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+== Implementation ==\n+\n+A sample implementation is available on bitcoin-inquisition [https://github.com/jamesob/bitcoin/tree/2023-01-opvault-inq here], with an associated [https://github.com/bitcoin-inquisition/bitcoin/pull/21 pull request].\n+\n+\n+== Applications ==",
      "path": "bip-0345.mediawiki",
      "position": 394,
      "original_position": 393,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "4aae726be9610a675b362e66f539ce0d5f903a5f",
      "in_reply_to_id": 1325073237,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Might be better to have this as a separate BIP, separate the consensus spec from the application advice -- presumably once the consensus change is made, application devs will be more interesting in reading about the application advice than the consensus details?",
      "created_at": "2023-10-13T06:27:45Z",
      "updated_at": "2023-10-13T06:27:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1357818371",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1357818371"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 394,
      "original_line": 393,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1358281872",
      "pull_request_review_id": 1676530558,
      "id": 1358281872,
      "node_id": "PRRC_kwDOAN28mc5Q9byQ",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===",
      "path": "bip-0345.mediawiki",
      "position": 227,
      "original_position": 227,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": 1357788739,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> OP_VAULT_FREEZE\r\n\r\nI assume this is the ranamed \"RECOVERY\"\r\n\r\n> If the amount is -1 that represents the remaining value from this input.\r\n\r\nDrilling down into this idea as before, it probably conceptually helps to drill down precisely what this case means. \r\n\r\ne.g., per input script execution, the remaining value starts at total input value, and simply decrements for every `OP_*VAULT` invocation, flooring at 0? I think that still allows most realistic use-cases where certain amounts are locked in at destinations, with the remaining being put somewhere else. Collateral could be done by specifying the value explicitly after whatever `-1` vault operation was done.\r\n\r\nHere was my attempt at a rework which avoids additional interpreter state, in case you hadn't seen it https://github.com/jamesob/bips/pull/4\r\n\r\nI think functionally these are very similar?",
      "created_at": "2023-10-13T13:39:36Z",
      "updated_at": "2023-10-13T13:41:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1358281872",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1358281872"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 227,
      "original_line": 227,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1359142205",
      "pull_request_review_id": 1677775300,
      "id": 1359142205,
      "node_id": "PRRC_kwDOAN28mc5RAt09",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===",
      "path": "bip-0345.mediawiki",
      "position": 227,
      "original_position": 227,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": 1357788739,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> > OP_VAULT_FREEZE\r\n> I assume this is the ranamed \"RECOVERY\"\r\n\r\nErr, yeah; I started writing that comment making more changes to the behaviour and wanted to be able to redefine VAULT_RECOVER in terms of my suggestion, so gave it a new name to make it clearer which is old and which is new. Then removed those changes, but didn't change the name back.\r\n\r\n> > If the amount is -1 that represents the remaining value from this input.\r\n> \r\n> Drilling down into this idea as before, it probably conceptually helps to drill down precisely what this case means.\r\n> \r\n> e.g., per input script execution, the remaining value starts at total input value, and simply decrements for every `OP_*VAULT` invocation, flooring at 0? I think that still allows most realistic use-cases where certain amounts are locked in at destinations, with the remaining being put somewhere else. Collateral could be done by specifying the value explicitly after whatever `-1` vault operation was done.\r\n\r\nYes. At start of script execution, define `uint64_t vault_balance = input_amt;`. Every time a vault operation occurs:\r\n\r\n * if the amount is `-1`, increment the expected balance for the output at idx by `vault_balance`; set `vault_balance=0`\r\n * otherwise, increment the expected balance for the output at idx by `amount`; set `vault_balance = vault_balance - min(amount, vault_balance)`\r\n\r\n> Here was my attempt at a rework which avoids additional interpreter state, in case you hadn't seen it [jamesob#4](https://github.com/jamesob/bips/pull/4)\r\n\r\nI think I'd forgotten it so reinvented it from scratch; but yeah, pretty much the same. I guess I think the `-1` approach is probably better given you can't do maths in script on amounts more 21.475 BTC; so \"10 BTC to A, 20 BTC to B, the rest to C\" would be hard to specify, even when all the explicit amounts are representable as a 4B `CScriptNum`.\r\n\r\nI suppose one other behaviour that could be allowed is \"-1 1000 OP_FALSE OP_VAULT_FREEZE\" (that is idx=-1, sPK=empty, amount>0) to allow some of the funds to be spent arbitrarily, eg to miner/watchtower fees.",
      "created_at": "2023-10-14T04:30:31Z",
      "updated_at": "2023-10-14T04:30:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1359142205",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1359142205"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 227,
      "original_line": 227,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1373455526",
      "pull_request_review_id": 1700084752,
      "id": 1373455526,
      "node_id": "PRRC_kwDOAN28mc5R3USm",
      "diff_hunk": "@@ -0,0 +1,1113 @@\n+<mxfile host=\"app.diagrams.net\" modified=\"2023-03-23T20:50:16.927Z\" agent=\"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\" etag=\"MVPrlQq-FqlMbts0SwvB\" version=\"21.1.0\" type=\"device\" pages=\"8\">\n+  <diagram id=\"qHG0FeF2aWp-aiau7VVg\" name=\"Basic flow\">\n+    <mxGraphModel dx=\"2162\" dy=\"1316\" grid=\"1\" gridSize=\"10\" guides=\"1\" tooltips=\"1\" connect=\"1\" arrows=\"1\" fold=\"1\" page=\"1\" pageScale=\"1\" pageWidth=\"850\" pageHeight=\"1100\" math=\"0\" shadow=\"0\">\n+      <root>\n+        <mxCell id=\"0\" />\n+        <mxCell id=\"1\" parent=\"0\" />\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-5\" value=\"\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\" parent=\"1\" source=\"b8DSxFJpJzC5LI19bmsF-1\" target=\"b8DSxFJpJzC5LI19bmsF-3\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-8\" value=\"&lt;div&gt;Sign with trigger key&lt;/div&gt;\" style=\"edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\" parent=\"b8DSxFJpJzC5LI19bmsF-5\" vertex=\"1\" connectable=\"0\">\n+          <mxGeometry x=\"-0.3102\" y=\"-1\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"1\" y=\"6\" as=\"offset\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-6\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=1;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;strokeColor=default;dashed=1;\" parent=\"1\" source=\"b8DSxFJpJzC5LI19bmsF-1\" target=\"b8DSxFJpJzC5LI19bmsF-2\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-7\" value=\"Reveal recovery &lt;br&gt;scriptPubKey&lt;br&gt;and (if applicable)&lt;br&gt;satisfy recovery &lt;br&gt;auth. script\" style=\"edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\" parent=\"b8DSxFJpJzC5LI19bmsF-6\" vertex=\"1\" connectable=\"0\">\n+          <mxGeometry x=\"-0.17\" y=\"2\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"52\" y=\"57\" as=\"offset\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-1\" value=\"&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;b&gt;Vault transaction&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;i style=&quot;background-color: initial;&quot;&gt;&amp;lt;recovery-params&amp;gt;&lt;/i&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;lt;&lt;i&gt;spend-delay&lt;/i&gt;&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;lt;&lt;i&gt;trigger-sPK-hash&lt;/i&gt;&amp;gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;OP_VAULT&lt;/b&gt;&lt;br&gt;&lt;/div&gt;\" style=\"rounded=1;whiteSpace=wrap;html=1;labelPosition=center;verticalLabelPosition=middle;align=center;verticalAlign=middle;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"190\" y=\"250\" width=\"140\" height=\"100\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-2\" value=\"&lt;b&gt;Recovery transaction&lt;br&gt;&lt;/b&gt;&lt;br&gt;[outputs controlled &lt;br&gt;by recovery keys]\" style=\"rounded=1;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"443\" y=\"420\" width=\"130\" height=\"70\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-9\" style=\"edgeStyle=orthogonalEdgeStyle;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;dashed=1;strokeColor=default;endArrow=none;endFill=0;rounded=1;\" parent=\"1\" source=\"b8DSxFJpJzC5LI19bmsF-3\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"400\" y=\"300\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"iAfIXZV-x1gRYHwice2W-8\" value=\"Recover from trigger,&lt;br style=&quot;font-size: 11px;&quot;&gt;before withdrawal&lt;br style=&quot;font-size: 11px;&quot;&gt;confirms\" style=\"edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];fontSize=11;\" parent=\"b8DSxFJpJzC5LI19bmsF-9\" vertex=\"1\" connectable=\"0\">\n+          <mxGeometry x=\"0.4001\" y=\"-1\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"-13\" y=\"19\" as=\"offset\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-11\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;strokeColor=default;\" parent=\"1\" source=\"b8DSxFJpJzC5LI19bmsF-3\" target=\"b8DSxFJpJzC5LI19bmsF-10\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-12\" value=\"&lt;div&gt;Wait &lt;i&gt;spend-delay&lt;/i&gt; blocks &lt;b&gt;&amp;amp;&amp;amp;&lt;/b&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;outputs match target hash&lt;br&gt;&lt;/div&gt;\" style=\"edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\" parent=\"b8DSxFJpJzC5LI19bmsF-11\" vertex=\"1\" connectable=\"0\">\n+          <mxGeometry x=\"-0.302\" y=\"2\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"1\" y=\"4\" as=\"offset\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"oT6HpDHtKCBb9ui_6_kA-1\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=1;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.001;exitY=0.406;exitDx=0;exitDy=0;entryX=0.001;entryY=0.595;entryDx=0;entryDy=0;dashed=1;endArrow=classic;endFill=1;entryPerimeter=0;exitPerimeter=0;\" parent=\"1\" source=\"b8DSxFJpJzC5LI19bmsF-3\" target=\"b8DSxFJpJzC5LI19bmsF-1\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\">\n+            <Array as=\"points\">\n+              <mxPoint x=\"90\" y=\"441\" />\n+              <mxPoint x=\"90\" y=\"310\" />\n+            </Array>\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"oT6HpDHtKCBb9ui_6_kA-2\" value=\"Optional &lt;br&gt;partial-balance&lt;br&gt;revault\" style=\"edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\" parent=\"oT6HpDHtKCBb9ui_6_kA-1\" vertex=\"1\" connectable=\"0\">\n+          <mxGeometry x=\"0.1091\" y=\"1\" relative=\"1\" as=\"geometry\">\n+            <mxPoint y=\"13\" as=\"offset\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-3\" value=\"&lt;div&gt;&lt;b&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;Trigger transaction&lt;/span&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;i style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/i&gt;&lt;/div&gt;&lt;div&gt;&lt;i style=&quot;background-color: initial;&quot;&gt;&amp;lt;recovery-params&amp;gt;&lt;/i&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;lt;&lt;i&gt;spend-delay&lt;/i&gt;&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;lt;&lt;i&gt;target-outputs-hash&lt;/i&gt;&amp;gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;OP_UNVAULT&lt;/b&gt;&lt;br&gt;&lt;/div&gt;\" style=\"rounded=1;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"190\" y=\"400\" width=\"140\" height=\"100\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-10\" value=\"&lt;b&gt;Withdrawal transaction&lt;br&gt;&lt;/b&gt;&lt;br&gt;[dynamically chosen target outputs]\" style=\"rounded=1;whiteSpace=wrap;html=1;align=center;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"190\" y=\"567\" width=\"140\" height=\"73\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-14\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;exitPerimeter=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;strokeColor=default;\" parent=\"1\" source=\"b8DSxFJpJzC5LI19bmsF-13\" target=\"b8DSxFJpJzC5LI19bmsF-1\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-13\" value=\"\" style=\"points=[[0.145,0.145,0],[0.5,0,0],[0.855,0.145,0],[1,0.5,0],[0.855,0.855,0],[0.5,1,0],[0.145,0.855,0],[0,0.5,0]];shape=mxgraph.bpmn.event;html=1;verticalLabelPosition=bottom;labelBackgroundColor=#ffffff;verticalAlign=top;align=center;perimeter=ellipsePerimeter;outlineConnect=0;aspect=fixed;outline=standard;symbol=general;rounded=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"245\" y=\"200\" width=\"30\" height=\"30\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"BqwL7Yf8YW1r5e_O7xE0-1\" value=\"\" style=\"shadow=0;dashed=0;html=1;strokeColor=none;fillColor=#4495D1;labelPosition=center;verticalLabelPosition=bottom;verticalAlign=top;align=center;outlineConnect=0;shape=mxgraph.veeam.time;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"158\" y=\"512\" width=\"30\" height=\"30\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"BqwL7Yf8YW1r5e_O7xE0-2\" value=\"\" style=\"sketch=0;pointerEvents=1;shadow=0;dashed=0;html=1;strokeColor=none;fillColor=#505050;labelPosition=center;verticalLabelPosition=bottom;verticalAlign=top;outlineConnect=0;align=center;shape=mxgraph.office.security.key_permissions;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"183\" y=\"358\" width=\"15\" height=\"33\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"oT6HpDHtKCBb9ui_6_kA-7\" value=\"\" style=\"endArrow=none;html=1;rounded=1;entryX=1;entryY=0.25;entryDx=0;entryDy=0;exitX=0;exitY=0.25;exitDx=0;exitDy=0;\" parent=\"1\" source=\"b8DSxFJpJzC5LI19bmsF-1\" target=\"b8DSxFJpJzC5LI19bmsF-1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"190\" y=\"280\" as=\"sourcePoint\" />\n+            <mxPoint x=\"240\" y=\"230\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"oT6HpDHtKCBb9ui_6_kA-8\" value=\"\" style=\"endArrow=none;html=1;rounded=1;entryX=1;entryY=0.25;entryDx=0;entryDy=0;exitX=0;exitY=0.25;exitDx=0;exitDy=0;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"190\" y=\"427\" as=\"sourcePoint\" />\n+            <mxPoint x=\"330\" y=\"427\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"oT6HpDHtKCBb9ui_6_kA-9\" value=\"\" style=\"endArrow=none;html=1;rounded=1;entryX=1;entryY=0.25;entryDx=0;entryDy=0;exitX=0;exitY=0.25;exitDx=0;exitDy=0;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"190\" y=\"596\" as=\"sourcePoint\" />\n+            <mxPoint x=\"330\" y=\"596\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"oT6HpDHtKCBb9ui_6_kA-10\" value=\"\" style=\"endArrow=none;html=1;rounded=1;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"443\" y=\"446\" as=\"sourcePoint\" />\n+            <mxPoint x=\"573\" y=\"446\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"LweIh1WkpCqs_c0vHIex-1\" value=\"\" style=\"endArrow=none;html=1;rounded=1;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"393\" y=\"236\" as=\"sourcePoint\" />\n+            <mxPoint x=\"413\" y=\"236\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"LweIh1WkpCqs_c0vHIex-2\" value=\"Withdrawal path\" style=\"text;strokeColor=none;align=left;fillColor=none;html=1;verticalAlign=middle;whiteSpace=wrap;rounded=0;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"415\" y=\"221\" width=\"90\" height=\"30\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"LweIh1WkpCqs_c0vHIex-3\" value=\"\" style=\"endArrow=none;html=1;rounded=1;dashed=1;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"393\" y=\"252\" as=\"sourcePoint\" />\n+            <mxPoint x=\"413\" y=\"252\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"LweIh1WkpCqs_c0vHIex-4\" value=\"Optional path\" style=\"text;strokeColor=none;align=left;fillColor=none;html=1;verticalAlign=middle;whiteSpace=wrap;rounded=0;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"416\" y=\"237\" width=\"90\" height=\"30\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"iAfIXZV-x1gRYHwice2W-2\" value=\"\" style=\"endArrow=classic;html=1;rounded=0;strokeColor=default;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"359\" y=\"449.76\" as=\"sourcePoint\" />\n+            <mxPoint x=\"369\" y=\"449.76\" as=\"targetPoint\" />\n+            <Array as=\"points\">\n+              <mxPoint x=\"359\" y=\"449.76\" />\n+            </Array>\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"iAfIXZV-x1gRYHwice2W-4\" value=\"\" style=\"endArrow=classic;html=1;rounded=0;strokeColor=default;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"399\" y=\"299.76\" as=\"sourcePoint\" />\n+            <mxPoint x=\"409\" y=\"299.76\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"iAfIXZV-x1gRYHwice2W-5\" value=\"\" style=\"endArrow=classic;html=1;rounded=0;strokeColor=default;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"150\" y=\"440\" as=\"sourcePoint\" />\n+            <mxPoint x=\"140\" y=\"440\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+      </root>\n+    </mxGraphModel>\n+  </diagram>\n+  <diagram id=\"hQFg2SRqlWPJF2oUK6n1\" name=\"Batch sweep\">\n+    <mxGraphModel dx=\"1430\" dy=\"1768\" grid=\"1\" gridSize=\"10\" guides=\"1\" tooltips=\"1\" connect=\"1\" arrows=\"1\" fold=\"1\" page=\"1\" pageScale=\"1\" pageWidth=\"850\" pageHeight=\"1100\" math=\"0\" shadow=\"0\">\n+      <root>\n+        <mxCell id=\"0\" />\n+        <mxCell id=\"1\" parent=\"0\" />\n+        <mxCell id=\"DGUraX8pYsX29eg1CZX8-1\" value=\"\" style=\"rounded=1;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"636\" y=\"415\" width=\"138\" height=\"160\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"DGUraX8pYsX29eg1CZX8-2\" value=\"\" style=\"endArrow=none;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\" parent=\"1\" source=\"DGUraX8pYsX29eg1CZX8-1\" target=\"DGUraX8pYsX29eg1CZX8-1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"660\" y=\"519.5\" as=\"sourcePoint\" />\n+            <mxPoint x=\"710\" y=\"469.5\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"DGUraX8pYsX29eg1CZX8-3\" value=\"&lt;b style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/b&gt;\" style=\"rounded=1;whiteSpace=wrap;html=1;align=left;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"722\" y=\"440\" width=\"100\" height=\"80\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-11\" value=\"\" style=\"rounded=1;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"380\" y=\"300\" width=\"138\" height=\"122\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-12\" value=\"\" style=\"endArrow=none;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\" parent=\"1\" source=\"IMLKYxiTQTyD-2dyPs5i-11\" target=\"IMLKYxiTQTyD-2dyPs5i-11\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"398\" y=\"352\" as=\"sourcePoint\" />\n+            <mxPoint x=\"448\" y=\"302\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-13\" value=\"&lt;b style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/b&gt;\" style=\"rounded=1;whiteSpace=wrap;html=1;align=left;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"460\" y=\"313\" width=\"100\" height=\"83\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-16\" value=\"\" style=\"rounded=1;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"400\" y=\"499\" width=\"115\" height=\"138\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-17\" value=\"\" style=\"endArrow=none;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"435\" y=\"637\" as=\"sourcePoint\" />\n+            <mxPoint x=\"435\" y=\"499\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-18\" value=\"&lt;b style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/b&gt;\" style=\"rounded=1;whiteSpace=wrap;html=1;align=left;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"457\" y=\"516\" width=\"100\" height=\"101\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-27\" value=\"\" style=\"rounded=1;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"165\" y=\"420\" width=\"138\" height=\"140\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-28\" value=\"\" style=\"endArrow=none;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"201\" y=\"560\" as=\"sourcePoint\" />\n+            <mxPoint x=\"201\" y=\"420\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-29\" value=\"&lt;b style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/b&gt;\" style=\"rounded=1;whiteSpace=wrap;html=1;align=left;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"230\" y=\"437\" width=\"100\" height=\"101\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-30\" value=\"&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;b&gt;scriptPubKey&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;border-color: var(--border-color); line-height: 4.8px;&quot;&gt;&lt;i style=&quot;border-color: var(--border-color);&quot;&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;&lt;font style=&quot;border-color: var(--border-color);&quot; color=&quot;#0066cc&quot;&gt;recov-hash&amp;nbsp;&lt;/font&gt;&lt;font style=&quot;border-color: var(--border-color);&quot; color=&quot;#00060d&quot;&gt;...&lt;/font&gt;&lt;/b&gt;&amp;nbsp;&lt;/i&gt;&lt;/p&gt;&lt;p style=&quot;border-color: var(--border-color); line-height: 4.8px;&quot;&gt;&amp;nbsp; OP_VAULT&lt;/p&gt;&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;b style=&quot;background-color: initial;&quot;&gt;amount&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;a3&lt;/span&gt;&lt;/p&gt;\" style=\"text;html=1;resizable=0;autosize=1;align=left;verticalAlign=middle;points=[];fillColor=none;strokeColor=none;rounded=0;dashed=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"461\" y=\"513.5\" width=\"100\" height=\"110\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-31\" value=\"\" style=\"rounded=1;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"134\" y=\"270\" width=\"88\" height=\"122\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-32\" value=\"\" style=\"endArrow=none;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"157\" y=\"392\" as=\"sourcePoint\" />\n+            <mxPoint x=\"157\" y=\"270\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-33\" value=\"&lt;b style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/b&gt;\" style=\"rounded=1;whiteSpace=wrap;html=1;align=left;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"180\" y=\"282\" width=\"100\" height=\"101\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-34\" value=\"&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;b&gt;scriptPubKey&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;i&gt;&lt;b style=&quot;&quot;&gt;&lt;font color=&quot;#0066cc&quot;&gt;recov-hash &lt;/font&gt;&lt;font color=&quot;#00060d&quot;&gt;...&lt;/font&gt;&lt;/b&gt;&amp;nbsp;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&amp;nbsp; OP_VAULT&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 120%;&quot;&gt;&lt;b&gt;amount&lt;/b&gt;&lt;br&gt;a1&lt;/p&gt;\" style=\"text;html=1;resizable=0;autosize=1;align=left;verticalAlign=middle;points=[];fillColor=none;strokeColor=none;rounded=0;dashed=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"183\" y=\"271\" width=\"100\" height=\"120\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-52\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0;exitY=0.25;exitDx=0;exitDy=0;\" parent=\"1\" source=\"IMLKYxiTQTyD-2dyPs5i-38\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"280\" y=\"333\" as=\"targetPoint\" />\n+            <Array as=\"points\">\n+              <mxPoint x=\"340\" y=\"333\" />\n+            </Array>\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-38\" value=\"\" style=\"rounded=0;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"340\" y=\"319\" width=\"90\" height=\"60\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-39\" value=\"&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;b&gt;witness&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 40%;&quot;&gt;[&lt;i&gt;trigger-key&amp;nbsp;&lt;/i&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 40%;&quot;&gt;&amp;nbsp; signature]&lt;/p&gt;\" style=\"text;html=1;resizable=0;autosize=1;align=left;verticalAlign=middle;points=[];fillColor=none;strokeColor=none;rounded=0;dashed=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"353\" y=\"310\" width=\"90\" height=\"80\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMagvj_H5wSyhYbexlPS-2\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=1;orthogonalLoop=1;jettySize=auto;html=1;exitX=0;exitY=0.5;exitDx=0;exitDy=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;\" parent=\"1\" target=\"IMLKYxiTQTyD-2dyPs5i-18\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"600\" y=\"538\" as=\"sourcePoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-54\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=1;orthogonalLoop=1;jettySize=auto;html=1;exitX=0;exitY=0.25;exitDx=0;exitDy=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;\" parent=\"1\" target=\"IMLKYxiTQTyD-2dyPs5i-13\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"600\" y=\"448.5\" as=\"sourcePoint\" />\n+            <Array as=\"points\">\n+              <mxPoint x=\"580\" y=\"449\" />\n+              <mxPoint x=\"580\" y=\"355\" />\n+            </Array>\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMagvj_H5wSyhYbexlPS-1\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0;exitY=0.367;exitDx=0;exitDy=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;exitPerimeter=0;\" parent=\"1\" source=\"IMLKYxiTQTyD-2dyPs5i-43\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"600\" y=\"491.5\" as=\"sourcePoint\" />\n+            <mxPoint x=\"330\" y=\"486.5\" as=\"targetPoint\" />\n+            <Array as=\"points\">\n+              <mxPoint x=\"600\" y=\"487\" />\n+              <mxPoint x=\"465\" y=\"487\" />\n+            </Array>\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-43\" value=\"Script-path reveal\" style=\"rounded=0;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"600\" y=\"473\" width=\"90\" height=\"35\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-20\" value=\"&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;b&gt;scriptPubKey&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;border-color: var(--border-color); line-height: 4.8px;&quot;&gt;&lt;i style=&quot;border-color: var(--border-color);&quot;&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;&lt;font style=&quot;border-color: var(--border-color);&quot; color=&quot;#0066cc&quot;&gt;recov-hash&amp;nbsp;&lt;/font&gt;&lt;font style=&quot;border-color: var(--border-color);&quot; color=&quot;#00060d&quot;&gt;...&lt;/font&gt;&lt;/b&gt;&amp;nbsp;&lt;/i&gt;&lt;/p&gt;&lt;p style=&quot;border-color: var(--border-color); line-height: 4.8px;&quot;&gt;&lt;span style=&quot;border-color: var(--border-color); background-color: initial;&quot;&gt;&amp;nbsp; OP_VAULT&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 120%;&quot;&gt;&lt;b&gt;amount&lt;/b&gt;&lt;br&gt;a2&lt;/p&gt;\" style=\"text;html=1;resizable=0;autosize=1;align=left;verticalAlign=middle;points=[];fillColor=none;strokeColor=none;rounded=0;dashed=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"233\" y=\"430\" width=\"100\" height=\"120\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-53\" value=\"\" style=\"group\" parent=\"1\" vertex=\"1\" connectable=\"0\">\n+          <mxGeometry x=\"465\" y=\"307.5\" width=\"120\" height=\"95\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-15\" value=\"&lt;p style=&quot;line-height: 10%;&quot;&gt;&lt;b&gt;scriptPubKey&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;border-color: var(--border-color); line-height: 4.8px;&quot;&gt;&lt;i style=&quot;border-color: var(--border-color);&quot;&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;&lt;font style=&quot;border-color: var(--border-color);&quot; color=&quot;#0066cc&quot;&gt;recov-hash&amp;nbsp;&lt;/font&gt;&lt;font style=&quot;border-color: var(--border-color);&quot; color=&quot;#00060d&quot;&gt;...&lt;/font&gt;&lt;/b&gt;&amp;nbsp;&lt;/i&gt;&lt;/p&gt;&lt;p style=&quot;border-color: var(--border-color); line-height: 4.8px;&quot;&gt;&lt;span style=&quot;border-color: var(--border-color); background-color: initial;&quot;&gt;&amp;nbsp; OP_UNVAULT&lt;/span&gt;&lt;/p&gt;\" style=\"text;html=1;resizable=0;autosize=1;align=left;verticalAlign=middle;points=[];fillColor=none;strokeColor=none;rounded=0;dashed=1;\" parent=\"IMLKYxiTQTyD-2dyPs5i-53\" vertex=\"1\">",
      "path": "bip-0345/vaults.drawio",
      "position": 262,
      "original_position": 262,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": null,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "OP_UNVAULT doesn't exist anymore, and batch-sweep doesn't seem to be included anywhere; perhaps this should be dropped from the source file?",
      "created_at": "2023-10-26T16:39:52Z",
      "updated_at": "2023-10-26T16:40:06Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1373455526",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1373455526"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 262,
      "original_line": 262,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1383805007",
      "pull_request_review_id": 1715940443,
      "id": 1383805007,
      "node_id": "PRRC_kwDOAN28mc5SezBP",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 235,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": 1357794539,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "(or `push_count` might be a clearer name?)",
      "created_at": "2023-11-06T18:43:55Z",
      "updated_at": "2023-11-06T18:43:55Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1383805007",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1383805007"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 235,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440917374",
      "pull_request_review_id": 1803029353,
      "id": 1440917374,
      "node_id": "PRRC_kwDOAN28mc5V4qd-",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 235,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": 1357794539,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-01-03T20:32:28Z",
      "updated_at": "2024-01-03T21:12:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1440917374",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440917374"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 235,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440920861",
      "pull_request_review_id": 1803029353,
      "id": 1440920861,
      "node_id": "PRRC_kwDOAN28mc5V4rUd",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 246,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": 1357801965,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2024-01-03T20:36:00Z",
      "updated_at": "2024-01-03T21:12:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1440920861",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440920861"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 246,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440925639",
      "pull_request_review_id": 1803029353,
      "id": 1440925639,
      "node_id": "PRRC_kwDOAN28mc5V4sfH",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 265,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": 1357805922,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Added, and the single allowable negative value (-1) for `<revault-vout-idx>` is fixed above.",
      "created_at": "2024-01-03T20:40:56Z",
      "updated_at": "2024-01-03T21:12:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1440925639",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440925639"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 265,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440937942",
      "pull_request_review_id": 1803029353,
      "id": 1440937942,
      "node_id": "PRRC_kwDOAN28mc5V4vfW",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Decrement the per-script sigops budget (see [https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#user-content-Resource_limits BIP-0342]) by 60<ref>'''Why is the sigops cost for OP_VAULT set to 60?''' To determine the validity of a trigger output, OP_VAULT must perform an EC multiplication and hashing proportional to the length of the control block in order to generate the output's expected TapTweak. This has been measured to have a cost in the worst case (max length control block) of roughly twice a Schnorr verification. Because the hashing cost could be mitigated by caching midstate, the cost is 60 and not 100.</ref>; if the budget is brought below zero, script execution MUST fail and terminate immediately.\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a version 1 witness program, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 273,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": 1357814856,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Just removing this line as it probably creates more confusion than it resolves.",
      "created_at": "2024-01-03T20:53:33Z",
      "updated_at": "2024-01-03T21:12:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1440937942",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440937942"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 273,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440941013",
      "pull_request_review_id": 1803029353,
      "id": 1440941013,
      "node_id": "PRRC_kwDOAN28mc5V4wPV",
      "diff_hunk": "@@ -0,0 +1,683 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a witness program of the same version and same tapleaf version as the currently executing script, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 277,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "4aae726be9610a675b362e66f539ce0d5f903a5f",
      "in_reply_to_id": 1325069886,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed the spelling issue and added an explanatory note to the recommendation, which hopefully makes it more easily understood.",
      "created_at": "2024-01-03T20:56:38Z",
      "updated_at": "2024-01-03T21:12:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1440941013",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440941013"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 277,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440946237",
      "pull_request_review_id": 1803029353,
      "id": 1440946237,
      "node_id": "PRRC_kwDOAN28mc5V4xg9",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Decrement the per-script sigops budget (see [https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#user-content-Resource_limits BIP-0342]) by 60<ref>'''Why is the sigops cost for OP_VAULT set to 60?''' To determine the validity of a trigger output, OP_VAULT must perform an EC multiplication and hashing proportional to the length of the control block in order to generate the output's expected TapTweak. This has been measured to have a cost in the worst case (max length control block) of roughly twice a Schnorr verification. Because the hashing cost could be mitigated by caching midstate, the cost is 60 and not 100.</ref>; if the budget is brought below zero, script execution MUST fail and terminate immediately.\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a version 1 witness program, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.\n+** Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.\n+* Queue a deferred check<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref> that ensures the satoshis for this input's <code>nValue</code> minus <code><revault-amount></code> are included within the output <code>nValue</code> found at <code><trigger-vout-idx></code>.\n+* Queue a deferred check that ensures <code><revault-amount></code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code><revault-vout-idx></code>.\n+** These deferred checks could be characterized in terms of the pseudocode below (in ''Deferred checks'') as<br /><code>TriggerCheck(input_amount, <revault-amount>, <trigger-vout-idx>, <revault-vout-idx>)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.",
      "path": "bip-0345.mediawiki",
      "position": 284,
      "original_position": 284,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": 1357811848,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Otherwise to abid by cleanstack (in the common case) we'd have to append an `OP_TRUE` to each script following the `OP_VAULT*` invocation. I figure why not save the byte?",
      "created_at": "2024-01-03T21:02:01Z",
      "updated_at": "2024-01-03T21:12:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1440946237",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440946237"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 284,
      "original_line": 284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440949961",
      "pull_request_review_id": 1803029353,
      "id": 1440949961,
      "node_id": "PRRC_kwDOAN28mc5V4ybJ",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Decrement the per-script sigops budget (see [https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#user-content-Resource_limits BIP-0342]) by 60<ref>'''Why is the sigops cost for OP_VAULT set to 60?''' To determine the validity of a trigger output, OP_VAULT must perform an EC multiplication and hashing proportional to the length of the control block in order to generate the output's expected TapTweak. This has been measured to have a cost in the worst case (max length control block) of roughly twice a Schnorr verification. Because the hashing cost could be mitigated by caching midstate, the cost is 60 and not 100.</ref>; if the budget is brought below zero, script execution MUST fail and terminate immediately.\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a version 1 witness program, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.\n+** Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.\n+* Queue a deferred check<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref> that ensures the satoshis for this input's <code>nValue</code> minus <code><revault-amount></code> are included within the output <code>nValue</code> found at <code><trigger-vout-idx></code>.\n+* Queue a deferred check that ensures <code><revault-amount></code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code><revault-vout-idx></code>.\n+** These deferred checks could be characterized in terms of the pseudocode below (in ''Deferred checks'') as<br /><code>TriggerCheck(input_amount, <revault-amount>, <trigger-vout-idx>, <revault-vout-idx>)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== <code>OP_VAULT_RECOVER</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT_RECOVER</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<recovery-sPK-hash>\n+<recovery-vout-idx>\n+</source>\n+\n+where\n+\n+* <code><recovery-sPK-hash></code> is a 32-byte data push.\n+** If this is not 32 bytes in length, script execution when spending this output MUST fail and terminate immediately.\n+* <code><recovery-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the recovery output.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output at index <code><recovery-vout-idx></code> be called ''recoveryOut''.\n+* If the scriptPubKey of ''recoveryOut'' does not have a tagged hash equal to <code><recovery-sPK-hash></code> (<code>tagged_hash(\"VaultRecoverySPK\", recoveryOut.scriptPubKey) == recovery-sPK-hash</code>, where <code>tagged_hash()</code> is from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code]), script execution when spending this output MUST fail and terminate immediately.\n+** Implementation recommendation: if ''recoveryOut'' does not have an <code>nValue</code> greater than or equal to this input's amount, the script SHOULD fail and terminate immediately.\n+* Queue a deferred check that ensures the <code>nValue</code> of ''recoveryOut'' contains the entire <code>nValue</code> of this input.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** This deferred check could be characterized in terms of the pseudocode below as <code>RecoveryCheck(<recovery-vout-idx>, input_amount)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== Deferred check evaluation ===\n+\n+Once all inputs for a transaction are validated per the rules above, any\n+deferred checks queued MUST be evaluated.\n+\n+The Python pseudocode for this is as follows:\n+\n+<source lang=\"python\">\n+class TriggerCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT (withdrawal trigger).\"\"\"\n+    input_amount: int\n+    revault_amount: int\n+    trigger_vout_idx: int\n+    revault_vout_idx: int\n+\n+\n+class RecoveryCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT_RECOVER.\"\"\"\n+    input_amount: int\n+    vout_idx: int\n+\n+\n+def validate_deferred_checks(checks: [DeferredCheck], tx: Transaction) -> bool:\n+    \"\"\"\n+    Ensure that all value from vault inputs being triggered or recovered is preserved\n+    in suitable output nValues.\n+    \"\"\"\n+    # Map to hold expected output values.\n+    out_map: Dict[int, int] = defaultdict(lambda: 0)\n+\n+    for c in checks:\n+        if isinstance(c, TriggerCheck):\n+            out_map[c.trigger_vout_idx] += (c.input_amount - c.revault_amount)\n+\n+            if c.revault_amount > 0:\n+                out_map[c.revault_vout_idx] += c.revault_amount\n+\n+        elif isinstance(c, RecoveryCheck):\n+            out_map[c.vout_idx] += c.input_amount\n+\n+    for (vout_idx, amount_sats) in out_map.items():\n+        # Trigger/recovery value can be greater than the constituent vault input\n+        # amounts.\n+        if tx.vout[vout_idx].nValue < amount_sats:\n+            return False\n+\n+    return True\n+</source>\n+\n+If the above procedure, or an equivalent, returns false, script execution MUST fail and terminate\n+immediately.\n+\n+This ensures that all compatible vault inputs can be batched into shared\n+corresponding trigger or recovery outputs while preserving their entire input value.\n+\n+\n+== Policy changes ==",
      "path": "bip-0345.mediawiki",
      "position": 370,
      "original_position": 370,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": 1357816644,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I disagree - I think this piece of policy is an important shim in this proposal because it forces awareness of a pinning vector. If we remove this policy requirement, we can add a recommendation somewhere, but I'm not sure of any benefit or possible use of not following that policy constraint. \r\n\r\nThis section is relatively short and the associated code is too, so I think it would be kind of silly to remove it for no good reason other than BIPs apparently shouldn't talk about policy.\r\n\r\nIf there is some practical reason _not_ to enforce this policy, I would be very curious to hear it.",
      "created_at": "2024-01-03T21:06:00Z",
      "updated_at": "2024-01-03T21:12:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1440949961",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440949961"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 370,
      "original_line": 370,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440951896",
      "pull_request_review_id": 1803029353,
      "id": 1440951896,
      "node_id": "PRRC_kwDOAN28mc5V4y5Y",
      "diff_hunk": "@@ -0,0 +1,683 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a witness program of the same version and same tapleaf version as the currently executing script, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.\n+** Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.\n+* Queue a deferred check<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref> that ensures the satoshis for this input's <code>nValue</code> minus <code><revault-amount></code> are included within the output <code>nValue</code> found at <code><trigger-vout-idx></code>.\n+* Queue a deferred check that ensures <code><revault-amount></code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code><revault-vout-idx></code>.\n+** These deferred checks could be characterized in terms of the pseudocode below (in ''Deferred checks'') as<br /><code>TriggerCheck(input_amount, <revault-amount>, <trigger-vout-idx>, <revault-vout-idx>)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== <code>OP_VAULT_RECOVER</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT_RECOVER</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<recovery-sPK-hash>\n+<recovery-vout-idx>\n+</source>\n+\n+where\n+\n+* <code><recovery-sPK-hash></code> is a 32-byte data push.\n+** If this is not 32 bytes in length, script execution when spending this output MUST fail and terminate immediately.\n+* <code><recovery-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the recovery output.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output at index <code><recovery-vout-idx></code> be called ''recoveryOut''.\n+* If the scriptPubKey of ''recoveryOut'' does not have a tagged hash equal to <code><recovery-sPK-hash></code> (<code>tagged_hash(\"VaultRecoverySPK\", recoveryOut.scriptPubKey) == recovery-sPK-hash</code>, where <code>tagged_hash()</code> is from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code]), script execution when spending this output MUST fail and terminate immediately.\n+** Implementation recommendation: if ''recoveryOut'' does not have an <code>nValue</code> greater than or equal to this input's amount, the script SHOULD fail and terminate immediately.\n+* Queue a deferred check that ensures the <code>nValue</code> of ''recoveryOut'' contains the entire <code>nValue</code> of this input.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** This deferred check could be characterized in terms of the pseudocode below as <code>RecoveryCheck(<recovery-vout-idx>, input_amount)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== Deferred check evaluation ===\n+\n+Once all inputs for a transaction are validated per the rules above, any\n+deferred checks queued MUST be evaluated.\n+\n+The Python pseudocode for this is as follows:\n+\n+<source lang=\"python\">\n+class TriggerCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT (withdrawal trigger).\"\"\"\n+    input_amount: int\n+    revault_amount: int\n+    trigger_vout_idx: int\n+    revault_vout_idx: int\n+\n+\n+class RecoveryCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT_RECOVER.\"\"\"\n+    input_amount: int\n+    vout_idx: int\n+\n+\n+def validate_deferred_checks(checks: [DeferredCheck], tx: Transaction) -> bool:\n+    \"\"\"\n+    Ensure that all value from vault inputs being triggered or recovered is preserved\n+    in suitable output nValues.\n+    \"\"\"\n+    # Map to hold expected output values.\n+    out_map: Dict[int, int] = defaultdict(lambda: 0)\n+\n+    for c in checks:\n+        if isinstance(c, TriggerCheck):\n+            out_map[c.trigger_vout_idx] += (c.input_amount - c.revault_amount)\n+\n+            if c.revault_amount > 0:\n+                out_map[c.revault_vout_idx] += c.revault_amount\n+\n+        elif isinstance(c, RecoveryCheck):\n+            out_map[c.vout_idx] += c.input_amount\n+\n+    for (vout_idx, amount_sats) in out_map.items():\n+        # Trigger/recovery value can be greater than the constituent vault input\n+        # amounts.\n+        if tx.vout[vout_idx].nValue < amount_sats:\n+            return False\n+\n+    return True\n+</source>\n+\n+If the above procedure, or an equivalent, returns false, script execution MUST fail and terminate\n+immediately.\n+\n+This ensures that all compatible vault inputs can be batched into shared\n+corresponding trigger or recovery outputs while preserving their entire input value.\n+\n+\n+== Policy changes ==\n+\n+In order to prevent possible pinning attacks, recovery transactions must be replaceable.\n+\n+* When validating an <code>OP_VAULT_RECOVER</code> input being spent, the script MUST fail (by policy, not consensus) and terminate immediately if both<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is not marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], and\n+*# the version of the recovery transaction has an nVersion other than 3.\n+\n+If the script containing <code>OP_VAULT_RECOVER</code> is 34 bytes or less<ref>34 bytes is the length of a recovery script that consists solely of <code><recovery-sPK-hash> OP_VAULT_RECOVER</code>.</ref>, let\n+it be called \"unauthorized,\" because there is no script guarding the recovery\n+process. In order to prevent pinning attacks in the case of unauthorized\n+recovery - since the spend of the input (and the structure of the\n+transaction) is not authorized by a signed signature message - the output structure of\n+unauthorized recovery transaction is limited.\n+\n+* If the recovery is unauthorized, the recovery transaction MUST (by policy) abide by the following constraints:\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output which is not ''recoveryOut'' is not an [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchor], the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+== Implementation ==\n+\n+A sample implementation is available on bitcoin-inquisition [https://github.com/jamesob/bitcoin/tree/2023-01-opvault-inq here], with an associated [https://github.com/bitcoin-inquisition/bitcoin/pull/21 pull request].\n+\n+\n+== Applications ==",
      "path": "bip-0345.mediawiki",
      "position": 394,
      "original_position": 393,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "4aae726be9610a675b362e66f539ce0d5f903a5f",
      "in_reply_to_id": 1325073237,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If many others also feel the applications section should be separated out, I can do that. However I should note that I intentionally bundled them together to avoid, e.g. the bad usability seen in the CLTV/CSV/nLockTime BIPs, which require having three separate BIPs open to fully understand the behavior. I think there is high utility in bundling the most common use of OP_VAULT along with its specification.",
      "created_at": "2024-01-03T21:07:53Z",
      "updated_at": "2024-01-03T21:12:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1440951896",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440951896"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 394,
      "original_line": 393,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440952968",
      "pull_request_review_id": 1803029353,
      "id": 1440952968,
      "node_id": "PRRC_kwDOAN28mc5V4zKI",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Decrement the per-script sigops budget (see [https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#user-content-Resource_limits BIP-0342]) by 60<ref>'''Why is the sigops cost for OP_VAULT set to 60?''' To determine the validity of a trigger output, OP_VAULT must perform an EC multiplication and hashing proportional to the length of the control block in order to generate the output's expected TapTweak. This has been measured to have a cost in the worst case (max length control block) of roughly twice a Schnorr verification. Because the hashing cost could be mitigated by caching midstate, the cost is 60 and not 100.</ref>; if the budget is brought below zero, script execution MUST fail and terminate immediately.\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a version 1 witness program, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.\n+** Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.\n+* Queue a deferred check<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref> that ensures the satoshis for this input's <code>nValue</code> minus <code><revault-amount></code> are included within the output <code>nValue</code> found at <code><trigger-vout-idx></code>.\n+* Queue a deferred check that ensures <code><revault-amount></code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code><revault-vout-idx></code>.\n+** These deferred checks could be characterized in terms of the pseudocode below (in ''Deferred checks'') as<br /><code>TriggerCheck(input_amount, <revault-amount>, <trigger-vout-idx>, <revault-vout-idx>)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== <code>OP_VAULT_RECOVER</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT_RECOVER</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<recovery-sPK-hash>\n+<recovery-vout-idx>\n+</source>\n+\n+where\n+\n+* <code><recovery-sPK-hash></code> is a 32-byte data push.\n+** If this is not 32 bytes in length, script execution when spending this output MUST fail and terminate immediately.\n+* <code><recovery-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the recovery output.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output at index <code><recovery-vout-idx></code> be called ''recoveryOut''.\n+* If the scriptPubKey of ''recoveryOut'' does not have a tagged hash equal to <code><recovery-sPK-hash></code> (<code>tagged_hash(\"VaultRecoverySPK\", recoveryOut.scriptPubKey) == recovery-sPK-hash</code>, where <code>tagged_hash()</code> is from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code]), script execution when spending this output MUST fail and terminate immediately.\n+** Implementation recommendation: if ''recoveryOut'' does not have an <code>nValue</code> greater than or equal to this input's amount, the script SHOULD fail and terminate immediately.\n+* Queue a deferred check that ensures the <code>nValue</code> of ''recoveryOut'' contains the entire <code>nValue</code> of this input.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** This deferred check could be characterized in terms of the pseudocode below as <code>RecoveryCheck(<recovery-vout-idx>, input_amount)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== Deferred check evaluation ===\n+\n+Once all inputs for a transaction are validated per the rules above, any\n+deferred checks queued MUST be evaluated.\n+\n+The Python pseudocode for this is as follows:\n+\n+<source lang=\"python\">\n+class TriggerCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT (withdrawal trigger).\"\"\"\n+    input_amount: int\n+    revault_amount: int\n+    trigger_vout_idx: int\n+    revault_vout_idx: int\n+\n+\n+class RecoveryCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT_RECOVER.\"\"\"\n+    input_amount: int\n+    vout_idx: int\n+\n+\n+def validate_deferred_checks(checks: [DeferredCheck], tx: Transaction) -> bool:\n+    \"\"\"\n+    Ensure that all value from vault inputs being triggered or recovered is preserved\n+    in suitable output nValues.\n+    \"\"\"\n+    # Map to hold expected output values.\n+    out_map: Dict[int, int] = defaultdict(lambda: 0)\n+\n+    for c in checks:\n+        if isinstance(c, TriggerCheck):\n+            out_map[c.trigger_vout_idx] += (c.input_amount - c.revault_amount)\n+\n+            if c.revault_amount > 0:\n+                out_map[c.revault_vout_idx] += c.revault_amount\n+\n+        elif isinstance(c, RecoveryCheck):\n+            out_map[c.vout_idx] += c.input_amount\n+\n+    for (vout_idx, amount_sats) in out_map.items():\n+        # Trigger/recovery value can be greater than the constituent vault input\n+        # amounts.\n+        if tx.vout[vout_idx].nValue < amount_sats:\n+            return False\n+\n+    return True\n+</source>\n+\n+If the above procedure, or an equivalent, returns false, script execution MUST fail and terminate\n+immediately.\n+\n+This ensures that all compatible vault inputs can be batched into shared\n+corresponding trigger or recovery outputs while preserving their entire input value.\n+\n+\n+== Policy changes ==\n+\n+In order to prevent possible pinning attacks, recovery transactions must be replaceable.\n+\n+* When validating an <code>OP_VAULT_RECOVER</code> input being spent, the script MUST fail (by policy, not consensus) and terminate immediately if both<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is not marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], and\n+*# the version of the recovery transaction has an nVersion other than 3.\n+\n+If the script containing <code>OP_VAULT_RECOVER</code> is 34 bytes or less<ref>34 bytes is the length of a recovery script that consists solely of <code><recovery-sPK-hash> OP_VAULT_RECOVER</code>.</ref>, let\n+it be called \"unauthorized,\" because there is no script guarding the recovery\n+process. In order to prevent pinning attacks in the case of unauthorized\n+recovery - since the spend of the input (and the structure of the\n+transaction) is not authorized by a signed signature message - the output structure of\n+unauthorized recovery transaction is limited.\n+\n+* If the recovery is unauthorized, the recovery transaction MUST (by policy) abide by the following constraints:\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output which is not ''recoveryOut'' is not an [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchor], the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+== Implementation ==\n+\n+A sample implementation is available on bitcoin-inquisition [https://github.com/jamesob/bitcoin/tree/2023-01-opvault-inq here], with an associated [https://github.com/bitcoin-inquisition/bitcoin/pull/21 pull request].\n+\n+\n+== Applications ==\n+\n+The specification above, perhaps surprisingly, does not specifically cover how a relative timelocked withdrawal process with a fixed target is implemented. The tapleaf update semantics specified in <code>OP_VAULT</code> as well as the output-based authorization enabled by <code>OP_VAULT_RECOVER</code> can be used to implement a vault, but they are incomplete without two other pieces:\n+\n+* a way to enforce relative timelocks, like <code>OP_CHECKSEQUENCEVERIFY</code>, and\n+* a way to enforce that proposed withdrawals are ultimately being spent to a precise set of outputs, like <code>OP_CHECKTEMPLATEVERIFY</code>.\n+\n+These two pieces are combined with the tapleaf update capabilities of\n+<code>OP_VAULT</code> to create a vault, described below.\n+\n+=== Creating a vault ===\n+\n+In order to vault coins, they can be spent into a witness v1 <code>scriptPubKey</code>\n+that contains a taptree of the form\n+\n+<source>\n+tr(<internal-pubkey>,\n+  leaves = {\n+    recover: \n+      <recovery-sPK-hash> OP_VAULT_RECOVER,\n+\n+    trigger: \n+      <trigger-auth-pubkey> OP_CHECKSIGVERIFY                     (i)\n+      <spend-delay> 2 $leaf-update-script-body OP_VAULT,          (ii)\n+\n+    ... [ possibly other leaves ]\n+  }\n+)\n+</source>",
      "path": "bip-0345.mediawiki",
      "position": 422,
      "original_position": 422,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": 1357817076,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If someone wants to contribute I'll be happy to incorporate them.",
      "created_at": "2024-01-03T21:08:55Z",
      "updated_at": "2024-01-03T21:12:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1440952968",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440952968"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 422,
      "original_line": 422,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440956172",
      "pull_request_review_id": 1803029353,
      "id": 1440956172,
      "node_id": "PRRC_kwDOAN28mc5V4z8M",
      "diff_hunk": "@@ -0,0 +1,683 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a witness program of the same version and same tapleaf version as the currently executing script, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.\n+** Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.\n+* Queue a deferred check<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref> that ensures the satoshis for this input's <code>nValue</code> minus <code><revault-amount></code> are included within the output <code>nValue</code> found at <code><trigger-vout-idx></code>.\n+* Queue a deferred check that ensures <code><revault-amount></code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code><revault-vout-idx></code>.\n+** These deferred checks could be characterized in terms of the pseudocode below (in ''Deferred checks'') as<br /><code>TriggerCheck(input_amount, <revault-amount>, <trigger-vout-idx>, <revault-vout-idx>)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== <code>OP_VAULT_RECOVER</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT_RECOVER</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<recovery-sPK-hash>\n+<recovery-vout-idx>\n+</source>\n+\n+where\n+\n+* <code><recovery-sPK-hash></code> is a 32-byte data push.\n+** If this is not 32 bytes in length, script execution when spending this output MUST fail and terminate immediately.\n+* <code><recovery-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the recovery output.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output at index <code><recovery-vout-idx></code> be called ''recoveryOut''.\n+* If the scriptPubKey of ''recoveryOut'' does not have a tagged hash equal to <code><recovery-sPK-hash></code> (<code>tagged_hash(\"VaultRecoverySPK\", recoveryOut.scriptPubKey) == recovery-sPK-hash</code>, where <code>tagged_hash()</code> is from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code]), script execution when spending this output MUST fail and terminate immediately.\n+** Implementation recommendation: if ''recoveryOut'' does not have an <code>nValue</code> greater than or equal to this input's amount, the script SHOULD fail and terminate immediately.\n+* Queue a deferred check that ensures the <code>nValue</code> of ''recoveryOut'' contains the entire <code>nValue</code> of this input.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** This deferred check could be characterized in terms of the pseudocode below as <code>RecoveryCheck(<recovery-vout-idx>, input_amount)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== Deferred check evaluation ===\n+\n+Once all inputs for a transaction are validated per the rules above, any\n+deferred checks queued MUST be evaluated.\n+\n+The Python pseudocode for this is as follows:\n+\n+<source lang=\"python\">\n+class TriggerCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT (withdrawal trigger).\"\"\"\n+    input_amount: int\n+    revault_amount: int\n+    trigger_vout_idx: int\n+    revault_vout_idx: int\n+\n+\n+class RecoveryCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT_RECOVER.\"\"\"\n+    input_amount: int\n+    vout_idx: int\n+\n+\n+def validate_deferred_checks(checks: [DeferredCheck], tx: Transaction) -> bool:\n+    \"\"\"\n+    Ensure that all value from vault inputs being triggered or recovered is preserved\n+    in suitable output nValues.\n+    \"\"\"\n+    # Map to hold expected output values.\n+    out_map: Dict[int, int] = defaultdict(lambda: 0)\n+\n+    for c in checks:\n+        if isinstance(c, TriggerCheck):\n+            out_map[c.trigger_vout_idx] += (c.input_amount - c.revault_amount)\n+\n+            if c.revault_amount > 0:\n+                out_map[c.revault_vout_idx] += c.revault_amount\n+\n+        elif isinstance(c, RecoveryCheck):\n+            out_map[c.vout_idx] += c.input_amount\n+\n+    for (vout_idx, amount_sats) in out_map.items():\n+        # Trigger/recovery value can be greater than the constituent vault input\n+        # amounts.\n+        if tx.vout[vout_idx].nValue < amount_sats:\n+            return False\n+\n+    return True\n+</source>\n+\n+If the above procedure, or an equivalent, returns false, script execution MUST fail and terminate\n+immediately.\n+\n+This ensures that all compatible vault inputs can be batched into shared\n+corresponding trigger or recovery outputs while preserving their entire input value.\n+\n+\n+== Policy changes ==\n+\n+In order to prevent possible pinning attacks, recovery transactions must be replaceable.\n+\n+* When validating an <code>OP_VAULT_RECOVER</code> input being spent, the script MUST fail (by policy, not consensus) and terminate immediately if both<ref>'''Why are recovery transactions required to be replaceable?''' In the case of unauthorized recoveries, an attacker may attempt to pin recovery transactions by broadcasting a \"rebundled\" version with a low fee rate. Vault owners must be able to overcome this with replacement. In the case of authorized recovery, if an attacker steals the recovery authorization key, the attacker may try to pin the recovery transaction during theft. Requiring replaceability ensures that the owner can always raise the fee rate of the recovery transaction, even if they are RBF rule #3 griefed in the process.</ref>\n+*# the input is not marked as opt-in replaceable by having an nSequence number less than <code>0xffffffff - 1</code>, per [https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki BIP-0125], and\n+*# the version of the recovery transaction has an nVersion other than 3.\n+\n+If the script containing <code>OP_VAULT_RECOVER</code> is 34 bytes or less<ref>34 bytes is the length of a recovery script that consists solely of <code><recovery-sPK-hash> OP_VAULT_RECOVER</code>.</ref>, let\n+it be called \"unauthorized,\" because there is no script guarding the recovery\n+process. In order to prevent pinning attacks in the case of unauthorized\n+recovery - since the spend of the input (and the structure of the\n+transaction) is not authorized by a signed signature message - the output structure of\n+unauthorized recovery transaction is limited.\n+\n+* If the recovery is unauthorized, the recovery transaction MUST (by policy) abide by the following constraints:\n+** If the spending transaction has more than two outputs, the script MUST fail and terminate immediately.\n+** If the spending transaction has two outputs, and the output which is not ''recoveryOut'' is not an [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchor], the script MUST fail and terminate immediately.<ref>'''Why can unauthorized recoveries only process a single recovery path?''' Because there is no signature required for unauthorized recoveries, if additional outputs were allowed, someone observing a recovery in the mempool would be able to rebundle and broadcast the recovery with a lower fee rate.</ref>\n+\n+== Implementation ==\n+\n+A sample implementation is available on bitcoin-inquisition [https://github.com/jamesob/bitcoin/tree/2023-01-opvault-inq here], with an associated [https://github.com/bitcoin-inquisition/bitcoin/pull/21 pull request].\n+\n+\n+== Applications ==\n+\n+The specification above, perhaps surprisingly, does not specifically cover how a relative timelocked withdrawal process with a fixed target is implemented. The tapleaf update semantics specified in <code>OP_VAULT</code> as well as the output-based authorization enabled by <code>OP_VAULT_RECOVER</code> can be used to implement a vault, but they are incomplete without two other pieces:\n+\n+* a way to enforce relative timelocks, like <code>OP_CHECKSEQUENCEVERIFY</code>, and\n+* a way to enforce that proposed withdrawals are ultimately being spent to a precise set of outputs, like <code>OP_CHECKTEMPLATEVERIFY</code>.\n+\n+These two pieces are combined with the tapleaf update capabilities of\n+<code>OP_VAULT</code> to create a vault, described below.\n+\n+=== Creating a vault ===\n+\n+In order to vault coins, they can be spent into a witness v1 <code>scriptPubKey</code>\n+that contains a taptree of the form\n+\n+<source>\n+tr(<internal-pubkey>,\n+  leaves = {\n+    recover: \n+      <recovery-sPK-hash> OP_VAULT_RECOVER,\n+\n+    trigger: \n+      <trigger-auth-pubkey> OP_CHECKSIGVERIFY                     (i)\n+      <spend-delay> 2 $leaf-update-script-body OP_VAULT,          (ii)\n+\n+    ... [ possibly other leaves ]\n+  }\n+)\n+</source>\n+where\n+* <code>$leaf-update-script-body</code> is, for example, <code>OP_CHECKSEQUENCEVERIFY OP_DROP OP_CHECKTEMPLATEVERIFY</code>.\n+** This is one example of a trigger script, but ''any'' script fragment can be used, allowing the creation of different types of vaults. For example, you could use <code>OP_CHECKSEQUENCEVERIFY OP_DROP OP_CHECKSIG</code> to do a time-delayed transfer of the coins to another key. This also future-proofs <code>OP_VAULT</code> for future scripting capabilities.\n+* The script fragment in <code>(i)</code> is called the \"trigger authorization,\" because it gates triggering the withdrawal. This can be done in whatever manner the wallet designer would like.\n+* The script fragment in <code>(ii)</code> is the incomplete <code>OP_VAULT</code> invocation - it will be completed once the rest of the parameters (the CTV target hash, trigger vout index, and revault vout index) are provided by the trigger transaction witness.\n+\n+Typically, the internal key for the vault taproot output will be specified so\n+that it is controlled by the same descriptor as the recovery path, which\n+facilitates another (though probably unused) means of recovering the vault\n+output to the recovery path. This has the potential advantage of recovering the\n+coin without ever revealing it was a vault. \n+\n+Otherwise, the internal key can be chosen to be an unspendable NUMS point to\n+force execution of the taptree contents.\n+\n+=== Triggering a withdrawal ===\n+\n+To make use of the vault, and spend it towards some output, we construct a spend\n+of the above <code>tr()</code> output that simply replaces the \"trigger\" leaf with the \n+full leaf-update script (in this case, a timelocked CTV script):\n+\n+<source>\n+Witness stack:\n+\n+- <revault-amount>\n+- <revault-vout-idx> (-1 if none)\n+- <trigger-vout-idx>\n+- <target-CTV-hash>\n+- <trigger-auth-pubkey-signature>\n+- [ \"trigger\" leaf script contents ]\n+- [ taproot control block prompting a script-path spend to \"trigger\" leaf ]\n+\n+Output scripts:\n+\n+[\n+  tr(<internal-pubkey>,\n+    leaves = {\n+      recover: \n+        <recovery-sPK-hash> OP_VAULT_RECOVER,               <--  unchanged\n+\n+      trigger:\n+        <target-CTV-hash> <spend-delay> \n+        OP_CHECKSEQUENCEVERIFY OP_DROP OP_CHECKTEMPLATEVERIFY  <--  changed per the \n+                                                                    leaf-update\n+                                                                    rules of OP_VAULT\n+       ... [ possibly other leaves ]\n+     }\n+   ),                                                               \n+\n+   [ optional revault output with the\n+     same sPK as the original vault output ],\n+]\n+</source>\n+\n+<code>OP_VAULT</code> has allowed the taptree to be transformed so that the trigger leaf\n+becomes a timelocked CTV script, which is what actually facilitates the announced\n+withdrawal. The withdrawal is interruptible by the recovery path because the\n+\"recover\" leaf is preserved exactly from the original taptree.\n+\n+Note that the CTV hash is specified at spend time using the witness stack, and\n+\"locked in\" via the <code>OP_VAULT</code> spend rules which assert its existence in the output.\n+\n+The vault funds can be recovered at any time prior to the spend of the\n+timelocked CTV script by way of a script-path spend using the \"recover\" leaf.\n+\n+\n+=== Recovery authorization ===\n+\n+When configuring a vault, the user must decide if they want to have the\n+recovery process gated by a script fragment prefixing the\n+<code>OP_VAULT_RECOVER</code> instruction in the \"recover\" leaf. Its use\n+entails trade-offs.\n+\n+==== Unauthorized recovery ====\n+\n+Unauthorized recovery simplifies vault use in that recovery never requires additional information aside from the location of the vault outpoints and the recovery path - the \"authorization\" is simply the reveal of the recovery path, i.e. the preimage of <code><recovery-sPK-hash></code>. \n+\n+But because this reveal is the only authorization necessary to spend the vault coins to recovery, the user must expect to recover all such vaults at once, since an observer can replay this recovery (provided they know the outpoints).\n+\n+Additionally, unauthorized recovery across multiple distinct recovery paths\n+cannot be done in the same transaction, and fee control is more constrained:\n+because the output structure is limited for unauthorized recovery, fee\n+management relies either on inputs which are completely spent to fees or the\n+use of the optional ephemeral anchor and package relay.\n+\n+These limitations are to avoid pinning attacks.\n+\n+==== Authorized recovery ====\n+\n+With authorized recovery, the user must keep track of an additional piece of information: how to solve the recovery authorization script fragment when recovery is required. \n+\n+If this key is lost, the user will be unable to initiate the recovery process for their coins. If an attacker obtains the recovery key, they may grief the user during the recovery process by constructing a low fee rate recovery transaction and broadcasting it (though they will not be able to pin because of the replaceability requirement on recovery transactions).\n+\n+However, authorized recovery configurations have significant benefits. Batched recoveries are possible for vaults with otherwise incompatible recovery parameters. Fee management is much more flexible, since authorized recovery transactions are \"free form\" and unrelated inputs and outputs can be added, potentially to handle fees.\n+\n+==== Recommendation: use a simple, offline recovery authorization key seed ====\n+\n+The benefits of batching and fee management that authorized recovery provides are significant. If the recovery authorization key falls into the hands of an attacker, the outcome is not catastrophic, whereas if the user loses their recovery authorization key as well as their trigger key, the result is likely coin loss. Consequently, the author's recommendation is to use a simple seed for the recovery authorization key that can be written down offline and replicated. \n+\n+Note that the recovery authorization key '''is not''' the recovery path key, and\n+this is '''much different''' than any recommendation on how to generate the\n+recovery path key itself.\n+\n+=== Address reuse and recovery ===\n+\n+When creating a vault, four factors affect the resulting P2TR address:\n+# The internal pubkey (likely belonging to the recovery wallet)\n+# The recovery leaf\n+# The trigger leaf\n+# Any other leaves that exist in the taptree\n+\n+The end user has the option of varying certain contents along descriptors in\n+order to avoid reusing vault addresses without affecting key management, e.g.\n+the trigger authorization pubkeys.\n+\n+Note that when using unauthorized recovery, the reveal of the\n+recovery scriptPubKey will allow any observer to initiate the recovery process\n+for any vault with matching recovery params, provided they are able to locate\n+the vault outpoints. As a result, it is recommended to expect that \n+'''all outputs sharing an identical unauthorized <code><recovery-sPK-hash></code> should be recovered together'''.\n+\n+This situation can be avoided with a comparable key management model by varying\n+the generation of each vault's recovery scriptPubKey along a single descriptor,\n+but note that this will prevent recovering multiple separate vaults into a single\n+recovery output.\n+\n+Varying the internal pubkey will prevent batching the trigger of multiple vault\n+inputs into a single trigger output; consequently it is recommended that users\n+instead vary some component of the trigger leaf script if address reuse is\n+undesirable. Users could vary the trigger pubkey along a descriptor, keeping\n+the recovery path and internal-pubkey the same, which both avoids reusing\n+addresses and allows batched trigger and recovery operations.\n+\n+==== Recommendation: generate new recovery addresses for new trigger keys ====\n+\n+If using unauthorized recovery, it is recommended that you do not share recovery scriptPubKeys\n+across separate trigger keys. If one trigger key is compromised, that will necessitate the (unauthorized)\n+recovery of all vaults with that trigger key, which will reveal the recovery path preimage. This\n+means that an observer might be able to initiate recovery for vaults controlled by an uncompromised\n+trigger key.\n+\n+==== Fee management ====\n+\n+Fees can be managed in a variety of ways, but it's worth noting that both\n+trigger and recovery transactions must preserve the total value of vault\n+inputs, so vaulted values cannot be repurposed to pay for fees. This does not\n+apply to the withdrawal transaction, which can allocate value arbitrarily.\n+\n+In the case of vaults that use recovery authorization, all transactions can\n+\"bring their own fees\" in the form of unrelated inputs and outputs. These\n+transactions are also free to specify ephemeral anchors, once the related relay\n+policies are deployed. This means that vaults using recovery authorization have\n+no dependence on the deploy of v3 relay policy.\n+\n+For vaults using unauthorized recovery, the recovery\n+transaction relies on the use of either fully-spent fee inputs or an ephemeral\n+anchor output. This means that vaults which do not use recovery authorization\n+are essentially dependent on v3 transaction relay policy being deployed.\n+",
      "path": "bip-0345.mediawiki",
      "position": 581,
      "original_position": 580,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "4aae726be9610a675b362e66f539ce0d5f903a5f",
      "in_reply_to_id": 1325090436,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Correct - \"fully spent fee inputs\" there confirms your question.",
      "created_at": "2024-01-03T21:11:21Z",
      "updated_at": "2024-01-03T21:12:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1440956172",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440956172"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 581,
      "original_line": 580,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440958116",
      "pull_request_review_id": 1803076372,
      "id": 1440958116,
      "node_id": "PRRC_kwDOAN28mc5V40ak",
      "diff_hunk": "@@ -0,0 +1,1113 @@\n+<mxfile host=\"app.diagrams.net\" modified=\"2023-03-23T20:50:16.927Z\" agent=\"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36\" etag=\"MVPrlQq-FqlMbts0SwvB\" version=\"21.1.0\" type=\"device\" pages=\"8\">\n+  <diagram id=\"qHG0FeF2aWp-aiau7VVg\" name=\"Basic flow\">\n+    <mxGraphModel dx=\"2162\" dy=\"1316\" grid=\"1\" gridSize=\"10\" guides=\"1\" tooltips=\"1\" connect=\"1\" arrows=\"1\" fold=\"1\" page=\"1\" pageScale=\"1\" pageWidth=\"850\" pageHeight=\"1100\" math=\"0\" shadow=\"0\">\n+      <root>\n+        <mxCell id=\"0\" />\n+        <mxCell id=\"1\" parent=\"0\" />\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-5\" value=\"\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;\" parent=\"1\" source=\"b8DSxFJpJzC5LI19bmsF-1\" target=\"b8DSxFJpJzC5LI19bmsF-3\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-8\" value=\"&lt;div&gt;Sign with trigger key&lt;/div&gt;\" style=\"edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\" parent=\"b8DSxFJpJzC5LI19bmsF-5\" vertex=\"1\" connectable=\"0\">\n+          <mxGeometry x=\"-0.3102\" y=\"-1\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"1\" y=\"6\" as=\"offset\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-6\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=1;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;strokeColor=default;dashed=1;\" parent=\"1\" source=\"b8DSxFJpJzC5LI19bmsF-1\" target=\"b8DSxFJpJzC5LI19bmsF-2\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-7\" value=\"Reveal recovery &lt;br&gt;scriptPubKey&lt;br&gt;and (if applicable)&lt;br&gt;satisfy recovery &lt;br&gt;auth. script\" style=\"edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\" parent=\"b8DSxFJpJzC5LI19bmsF-6\" vertex=\"1\" connectable=\"0\">\n+          <mxGeometry x=\"-0.17\" y=\"2\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"52\" y=\"57\" as=\"offset\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-1\" value=\"&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;b&gt;Vault transaction&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;&lt;i style=&quot;background-color: initial;&quot;&gt;&amp;lt;recovery-params&amp;gt;&lt;/i&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;lt;&lt;i&gt;spend-delay&lt;/i&gt;&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;lt;&lt;i&gt;trigger-sPK-hash&lt;/i&gt;&amp;gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;OP_VAULT&lt;/b&gt;&lt;br&gt;&lt;/div&gt;\" style=\"rounded=1;whiteSpace=wrap;html=1;labelPosition=center;verticalLabelPosition=middle;align=center;verticalAlign=middle;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"190\" y=\"250\" width=\"140\" height=\"100\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-2\" value=\"&lt;b&gt;Recovery transaction&lt;br&gt;&lt;/b&gt;&lt;br&gt;[outputs controlled &lt;br&gt;by recovery keys]\" style=\"rounded=1;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"443\" y=\"420\" width=\"130\" height=\"70\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-9\" style=\"edgeStyle=orthogonalEdgeStyle;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;dashed=1;strokeColor=default;endArrow=none;endFill=0;rounded=1;\" parent=\"1\" source=\"b8DSxFJpJzC5LI19bmsF-3\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"400\" y=\"300\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"iAfIXZV-x1gRYHwice2W-8\" value=\"Recover from trigger,&lt;br style=&quot;font-size: 11px;&quot;&gt;before withdrawal&lt;br style=&quot;font-size: 11px;&quot;&gt;confirms\" style=\"edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];fontSize=11;\" parent=\"b8DSxFJpJzC5LI19bmsF-9\" vertex=\"1\" connectable=\"0\">\n+          <mxGeometry x=\"0.4001\" y=\"-1\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"-13\" y=\"19\" as=\"offset\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-11\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;strokeColor=default;\" parent=\"1\" source=\"b8DSxFJpJzC5LI19bmsF-3\" target=\"b8DSxFJpJzC5LI19bmsF-10\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-12\" value=\"&lt;div&gt;Wait &lt;i&gt;spend-delay&lt;/i&gt; blocks &lt;b&gt;&amp;amp;&amp;amp;&lt;/b&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;outputs match target hash&lt;br&gt;&lt;/div&gt;\" style=\"edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\" parent=\"b8DSxFJpJzC5LI19bmsF-11\" vertex=\"1\" connectable=\"0\">\n+          <mxGeometry x=\"-0.302\" y=\"2\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"1\" y=\"4\" as=\"offset\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"oT6HpDHtKCBb9ui_6_kA-1\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=1;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.001;exitY=0.406;exitDx=0;exitDy=0;entryX=0.001;entryY=0.595;entryDx=0;entryDy=0;dashed=1;endArrow=classic;endFill=1;entryPerimeter=0;exitPerimeter=0;\" parent=\"1\" source=\"b8DSxFJpJzC5LI19bmsF-3\" target=\"b8DSxFJpJzC5LI19bmsF-1\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\">\n+            <Array as=\"points\">\n+              <mxPoint x=\"90\" y=\"441\" />\n+              <mxPoint x=\"90\" y=\"310\" />\n+            </Array>\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"oT6HpDHtKCBb9ui_6_kA-2\" value=\"Optional &lt;br&gt;partial-balance&lt;br&gt;revault\" style=\"edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];\" parent=\"oT6HpDHtKCBb9ui_6_kA-1\" vertex=\"1\" connectable=\"0\">\n+          <mxGeometry x=\"0.1091\" y=\"1\" relative=\"1\" as=\"geometry\">\n+            <mxPoint y=\"13\" as=\"offset\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-3\" value=\"&lt;div&gt;&lt;b&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;Trigger transaction&lt;/span&gt;&lt;br&gt;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&lt;i style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/i&gt;&lt;/div&gt;&lt;div&gt;&lt;i style=&quot;background-color: initial;&quot;&gt;&amp;lt;recovery-params&amp;gt;&lt;/i&gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&amp;lt;&lt;i&gt;spend-delay&lt;/i&gt;&amp;gt;&lt;/div&gt;&lt;div&gt;&amp;lt;&lt;i&gt;target-outputs-hash&lt;/i&gt;&amp;gt;&lt;br&gt;&lt;/div&gt;&lt;div&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;OP_UNVAULT&lt;/b&gt;&lt;br&gt;&lt;/div&gt;\" style=\"rounded=1;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"190\" y=\"400\" width=\"140\" height=\"100\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-10\" value=\"&lt;b&gt;Withdrawal transaction&lt;br&gt;&lt;/b&gt;&lt;br&gt;[dynamically chosen target outputs]\" style=\"rounded=1;whiteSpace=wrap;html=1;align=center;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"190\" y=\"567\" width=\"140\" height=\"73\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-14\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;exitPerimeter=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;strokeColor=default;\" parent=\"1\" source=\"b8DSxFJpJzC5LI19bmsF-13\" target=\"b8DSxFJpJzC5LI19bmsF-1\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"b8DSxFJpJzC5LI19bmsF-13\" value=\"\" style=\"points=[[0.145,0.145,0],[0.5,0,0],[0.855,0.145,0],[1,0.5,0],[0.855,0.855,0],[0.5,1,0],[0.145,0.855,0],[0,0.5,0]];shape=mxgraph.bpmn.event;html=1;verticalLabelPosition=bottom;labelBackgroundColor=#ffffff;verticalAlign=top;align=center;perimeter=ellipsePerimeter;outlineConnect=0;aspect=fixed;outline=standard;symbol=general;rounded=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"245\" y=\"200\" width=\"30\" height=\"30\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"BqwL7Yf8YW1r5e_O7xE0-1\" value=\"\" style=\"shadow=0;dashed=0;html=1;strokeColor=none;fillColor=#4495D1;labelPosition=center;verticalLabelPosition=bottom;verticalAlign=top;align=center;outlineConnect=0;shape=mxgraph.veeam.time;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"158\" y=\"512\" width=\"30\" height=\"30\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"BqwL7Yf8YW1r5e_O7xE0-2\" value=\"\" style=\"sketch=0;pointerEvents=1;shadow=0;dashed=0;html=1;strokeColor=none;fillColor=#505050;labelPosition=center;verticalLabelPosition=bottom;verticalAlign=top;outlineConnect=0;align=center;shape=mxgraph.office.security.key_permissions;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"183\" y=\"358\" width=\"15\" height=\"33\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"oT6HpDHtKCBb9ui_6_kA-7\" value=\"\" style=\"endArrow=none;html=1;rounded=1;entryX=1;entryY=0.25;entryDx=0;entryDy=0;exitX=0;exitY=0.25;exitDx=0;exitDy=0;\" parent=\"1\" source=\"b8DSxFJpJzC5LI19bmsF-1\" target=\"b8DSxFJpJzC5LI19bmsF-1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"190\" y=\"280\" as=\"sourcePoint\" />\n+            <mxPoint x=\"240\" y=\"230\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"oT6HpDHtKCBb9ui_6_kA-8\" value=\"\" style=\"endArrow=none;html=1;rounded=1;entryX=1;entryY=0.25;entryDx=0;entryDy=0;exitX=0;exitY=0.25;exitDx=0;exitDy=0;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"190\" y=\"427\" as=\"sourcePoint\" />\n+            <mxPoint x=\"330\" y=\"427\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"oT6HpDHtKCBb9ui_6_kA-9\" value=\"\" style=\"endArrow=none;html=1;rounded=1;entryX=1;entryY=0.25;entryDx=0;entryDy=0;exitX=0;exitY=0.25;exitDx=0;exitDy=0;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"190\" y=\"596\" as=\"sourcePoint\" />\n+            <mxPoint x=\"330\" y=\"596\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"oT6HpDHtKCBb9ui_6_kA-10\" value=\"\" style=\"endArrow=none;html=1;rounded=1;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"443\" y=\"446\" as=\"sourcePoint\" />\n+            <mxPoint x=\"573\" y=\"446\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"LweIh1WkpCqs_c0vHIex-1\" value=\"\" style=\"endArrow=none;html=1;rounded=1;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"393\" y=\"236\" as=\"sourcePoint\" />\n+            <mxPoint x=\"413\" y=\"236\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"LweIh1WkpCqs_c0vHIex-2\" value=\"Withdrawal path\" style=\"text;strokeColor=none;align=left;fillColor=none;html=1;verticalAlign=middle;whiteSpace=wrap;rounded=0;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"415\" y=\"221\" width=\"90\" height=\"30\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"LweIh1WkpCqs_c0vHIex-3\" value=\"\" style=\"endArrow=none;html=1;rounded=1;dashed=1;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"393\" y=\"252\" as=\"sourcePoint\" />\n+            <mxPoint x=\"413\" y=\"252\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"LweIh1WkpCqs_c0vHIex-4\" value=\"Optional path\" style=\"text;strokeColor=none;align=left;fillColor=none;html=1;verticalAlign=middle;whiteSpace=wrap;rounded=0;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"416\" y=\"237\" width=\"90\" height=\"30\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"iAfIXZV-x1gRYHwice2W-2\" value=\"\" style=\"endArrow=classic;html=1;rounded=0;strokeColor=default;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"359\" y=\"449.76\" as=\"sourcePoint\" />\n+            <mxPoint x=\"369\" y=\"449.76\" as=\"targetPoint\" />\n+            <Array as=\"points\">\n+              <mxPoint x=\"359\" y=\"449.76\" />\n+            </Array>\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"iAfIXZV-x1gRYHwice2W-4\" value=\"\" style=\"endArrow=classic;html=1;rounded=0;strokeColor=default;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"399\" y=\"299.76\" as=\"sourcePoint\" />\n+            <mxPoint x=\"409\" y=\"299.76\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"iAfIXZV-x1gRYHwice2W-5\" value=\"\" style=\"endArrow=classic;html=1;rounded=0;strokeColor=default;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"150\" y=\"440\" as=\"sourcePoint\" />\n+            <mxPoint x=\"140\" y=\"440\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+      </root>\n+    </mxGraphModel>\n+  </diagram>\n+  <diagram id=\"hQFg2SRqlWPJF2oUK6n1\" name=\"Batch sweep\">\n+    <mxGraphModel dx=\"1430\" dy=\"1768\" grid=\"1\" gridSize=\"10\" guides=\"1\" tooltips=\"1\" connect=\"1\" arrows=\"1\" fold=\"1\" page=\"1\" pageScale=\"1\" pageWidth=\"850\" pageHeight=\"1100\" math=\"0\" shadow=\"0\">\n+      <root>\n+        <mxCell id=\"0\" />\n+        <mxCell id=\"1\" parent=\"0\" />\n+        <mxCell id=\"DGUraX8pYsX29eg1CZX8-1\" value=\"\" style=\"rounded=1;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"636\" y=\"415\" width=\"138\" height=\"160\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"DGUraX8pYsX29eg1CZX8-2\" value=\"\" style=\"endArrow=none;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\" parent=\"1\" source=\"DGUraX8pYsX29eg1CZX8-1\" target=\"DGUraX8pYsX29eg1CZX8-1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"660\" y=\"519.5\" as=\"sourcePoint\" />\n+            <mxPoint x=\"710\" y=\"469.5\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"DGUraX8pYsX29eg1CZX8-3\" value=\"&lt;b style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/b&gt;\" style=\"rounded=1;whiteSpace=wrap;html=1;align=left;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"722\" y=\"440\" width=\"100\" height=\"80\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-11\" value=\"\" style=\"rounded=1;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"380\" y=\"300\" width=\"138\" height=\"122\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-12\" value=\"\" style=\"endArrow=none;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\" parent=\"1\" source=\"IMLKYxiTQTyD-2dyPs5i-11\" target=\"IMLKYxiTQTyD-2dyPs5i-11\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"398\" y=\"352\" as=\"sourcePoint\" />\n+            <mxPoint x=\"448\" y=\"302\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-13\" value=\"&lt;b style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/b&gt;\" style=\"rounded=1;whiteSpace=wrap;html=1;align=left;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"460\" y=\"313\" width=\"100\" height=\"83\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-16\" value=\"\" style=\"rounded=1;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"400\" y=\"499\" width=\"115\" height=\"138\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-17\" value=\"\" style=\"endArrow=none;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"435\" y=\"637\" as=\"sourcePoint\" />\n+            <mxPoint x=\"435\" y=\"499\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-18\" value=\"&lt;b style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/b&gt;\" style=\"rounded=1;whiteSpace=wrap;html=1;align=left;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"457\" y=\"516\" width=\"100\" height=\"101\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-27\" value=\"\" style=\"rounded=1;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"165\" y=\"420\" width=\"138\" height=\"140\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-28\" value=\"\" style=\"endArrow=none;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"201\" y=\"560\" as=\"sourcePoint\" />\n+            <mxPoint x=\"201\" y=\"420\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-29\" value=\"&lt;b style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/b&gt;\" style=\"rounded=1;whiteSpace=wrap;html=1;align=left;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"230\" y=\"437\" width=\"100\" height=\"101\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-30\" value=\"&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;b&gt;scriptPubKey&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;border-color: var(--border-color); line-height: 4.8px;&quot;&gt;&lt;i style=&quot;border-color: var(--border-color);&quot;&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;&lt;font style=&quot;border-color: var(--border-color);&quot; color=&quot;#0066cc&quot;&gt;recov-hash&amp;nbsp;&lt;/font&gt;&lt;font style=&quot;border-color: var(--border-color);&quot; color=&quot;#00060d&quot;&gt;...&lt;/font&gt;&lt;/b&gt;&amp;nbsp;&lt;/i&gt;&lt;/p&gt;&lt;p style=&quot;border-color: var(--border-color); line-height: 4.8px;&quot;&gt;&amp;nbsp; OP_VAULT&lt;/p&gt;&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;b style=&quot;background-color: initial;&quot;&gt;amount&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;a3&lt;/span&gt;&lt;/p&gt;\" style=\"text;html=1;resizable=0;autosize=1;align=left;verticalAlign=middle;points=[];fillColor=none;strokeColor=none;rounded=0;dashed=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"461\" y=\"513.5\" width=\"100\" height=\"110\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-31\" value=\"\" style=\"rounded=1;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"134\" y=\"270\" width=\"88\" height=\"122\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-32\" value=\"\" style=\"endArrow=none;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;\" parent=\"1\" edge=\"1\">\n+          <mxGeometry width=\"50\" height=\"50\" relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"157\" y=\"392\" as=\"sourcePoint\" />\n+            <mxPoint x=\"157\" y=\"270\" as=\"targetPoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-33\" value=\"&lt;b style=&quot;background-color: initial;&quot;&gt;&lt;br&gt;&lt;/b&gt;\" style=\"rounded=1;whiteSpace=wrap;html=1;align=left;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"180\" y=\"282\" width=\"100\" height=\"101\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-34\" value=\"&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;b&gt;scriptPubKey&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&lt;i&gt;&lt;b style=&quot;&quot;&gt;&lt;font color=&quot;#0066cc&quot;&gt;recov-hash &lt;/font&gt;&lt;font color=&quot;#00060d&quot;&gt;...&lt;/font&gt;&lt;/b&gt;&amp;nbsp;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;span style=&quot;background-color: initial;&quot;&gt;&amp;nbsp; OP_VAULT&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 120%;&quot;&gt;&lt;b&gt;amount&lt;/b&gt;&lt;br&gt;a1&lt;/p&gt;\" style=\"text;html=1;resizable=0;autosize=1;align=left;verticalAlign=middle;points=[];fillColor=none;strokeColor=none;rounded=0;dashed=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"183\" y=\"271\" width=\"100\" height=\"120\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-52\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0;exitY=0.25;exitDx=0;exitDy=0;\" parent=\"1\" source=\"IMLKYxiTQTyD-2dyPs5i-38\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"280\" y=\"333\" as=\"targetPoint\" />\n+            <Array as=\"points\">\n+              <mxPoint x=\"340\" y=\"333\" />\n+            </Array>\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-38\" value=\"\" style=\"rounded=0;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"340\" y=\"319\" width=\"90\" height=\"60\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-39\" value=\"&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;b&gt;witness&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 40%;&quot;&gt;[&lt;i&gt;trigger-key&amp;nbsp;&lt;/i&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 40%;&quot;&gt;&amp;nbsp; signature]&lt;/p&gt;\" style=\"text;html=1;resizable=0;autosize=1;align=left;verticalAlign=middle;points=[];fillColor=none;strokeColor=none;rounded=0;dashed=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"353\" y=\"310\" width=\"90\" height=\"80\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMagvj_H5wSyhYbexlPS-2\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=1;orthogonalLoop=1;jettySize=auto;html=1;exitX=0;exitY=0.5;exitDx=0;exitDy=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;\" parent=\"1\" target=\"IMLKYxiTQTyD-2dyPs5i-18\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"600\" y=\"538\" as=\"sourcePoint\" />\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-54\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=1;orthogonalLoop=1;jettySize=auto;html=1;exitX=0;exitY=0.25;exitDx=0;exitDy=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;\" parent=\"1\" target=\"IMLKYxiTQTyD-2dyPs5i-13\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"600\" y=\"448.5\" as=\"sourcePoint\" />\n+            <Array as=\"points\">\n+              <mxPoint x=\"580\" y=\"449\" />\n+              <mxPoint x=\"580\" y=\"355\" />\n+            </Array>\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMagvj_H5wSyhYbexlPS-1\" style=\"edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0;exitY=0.367;exitDx=0;exitDy=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;exitPerimeter=0;\" parent=\"1\" source=\"IMLKYxiTQTyD-2dyPs5i-43\" edge=\"1\">\n+          <mxGeometry relative=\"1\" as=\"geometry\">\n+            <mxPoint x=\"600\" y=\"491.5\" as=\"sourcePoint\" />\n+            <mxPoint x=\"330\" y=\"486.5\" as=\"targetPoint\" />\n+            <Array as=\"points\">\n+              <mxPoint x=\"600\" y=\"487\" />\n+              <mxPoint x=\"465\" y=\"487\" />\n+            </Array>\n+          </mxGeometry>\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-43\" value=\"Script-path reveal\" style=\"rounded=0;whiteSpace=wrap;html=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"600\" y=\"473\" width=\"90\" height=\"35\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-20\" value=\"&lt;p style=&quot;line-height: 40%;&quot;&gt;&lt;b&gt;scriptPubKey&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;border-color: var(--border-color); line-height: 4.8px;&quot;&gt;&lt;i style=&quot;border-color: var(--border-color);&quot;&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;&lt;font style=&quot;border-color: var(--border-color);&quot; color=&quot;#0066cc&quot;&gt;recov-hash&amp;nbsp;&lt;/font&gt;&lt;font style=&quot;border-color: var(--border-color);&quot; color=&quot;#00060d&quot;&gt;...&lt;/font&gt;&lt;/b&gt;&amp;nbsp;&lt;/i&gt;&lt;/p&gt;&lt;p style=&quot;border-color: var(--border-color); line-height: 4.8px;&quot;&gt;&lt;span style=&quot;border-color: var(--border-color); background-color: initial;&quot;&gt;&amp;nbsp; OP_VAULT&lt;/span&gt;&lt;/p&gt;&lt;p style=&quot;line-height: 120%;&quot;&gt;&lt;b&gt;amount&lt;/b&gt;&lt;br&gt;a2&lt;/p&gt;\" style=\"text;html=1;resizable=0;autosize=1;align=left;verticalAlign=middle;points=[];fillColor=none;strokeColor=none;rounded=0;dashed=1;\" parent=\"1\" vertex=\"1\">\n+          <mxGeometry x=\"233\" y=\"430\" width=\"100\" height=\"120\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-53\" value=\"\" style=\"group\" parent=\"1\" vertex=\"1\" connectable=\"0\">\n+          <mxGeometry x=\"465\" y=\"307.5\" width=\"120\" height=\"95\" as=\"geometry\" />\n+        </mxCell>\n+        <mxCell id=\"IMLKYxiTQTyD-2dyPs5i-15\" value=\"&lt;p style=&quot;line-height: 10%;&quot;&gt;&lt;b&gt;scriptPubKey&lt;/b&gt;&lt;/p&gt;&lt;p style=&quot;border-color: var(--border-color); line-height: 4.8px;&quot;&gt;&lt;i style=&quot;border-color: var(--border-color);&quot;&gt;&lt;b style=&quot;border-color: var(--border-color);&quot;&gt;&lt;font style=&quot;border-color: var(--border-color);&quot; color=&quot;#0066cc&quot;&gt;recov-hash&amp;nbsp;&lt;/font&gt;&lt;font style=&quot;border-color: var(--border-color);&quot; color=&quot;#00060d&quot;&gt;...&lt;/font&gt;&lt;/b&gt;&amp;nbsp;&lt;/i&gt;&lt;/p&gt;&lt;p style=&quot;border-color: var(--border-color); line-height: 4.8px;&quot;&gt;&lt;span style=&quot;border-color: var(--border-color); background-color: initial;&quot;&gt;&amp;nbsp; OP_UNVAULT&lt;/span&gt;&lt;/p&gt;\" style=\"text;html=1;resizable=0;autosize=1;align=left;verticalAlign=middle;points=[];fillColor=none;strokeColor=none;rounded=0;dashed=1;\" parent=\"IMLKYxiTQTyD-2dyPs5i-53\" vertex=\"1\">",
      "path": "bip-0345/vaults.drawio",
      "position": 262,
      "original_position": 262,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": 1373455526,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Dropped the unused diagram.",
      "created_at": "2024-01-03T21:13:18Z",
      "updated_at": "2024-01-03T21:13:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1440958116",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440958116"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 262,
      "original_line": 262,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440965727",
      "pull_request_review_id": 1803085323,
      "id": 1440965727,
      "node_id": "PRRC_kwDOAN28mc5V42Rf",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.",
      "path": "bip-0345.mediawiki",
      "position": null,
      "original_position": 263,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": 1357805436,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed",
      "created_at": "2024-01-03T21:21:08Z",
      "updated_at": "2024-01-03T21:21:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1440965727",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1440965727"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 263,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1443106864",
      "pull_request_review_id": 1806374291,
      "id": 1443106864,
      "node_id": "PRRC_kwDOAN28mc5WBBAw",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Decrement the per-script sigops budget (see [https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#user-content-Resource_limits BIP-0342]) by 60<ref>'''Why is the sigops cost for OP_VAULT set to 60?''' To determine the validity of a trigger output, OP_VAULT must perform an EC multiplication and hashing proportional to the length of the control block in order to generate the output's expected TapTweak. This has been measured to have a cost in the worst case (max length control block) of roughly twice a Schnorr verification. Because the hashing cost could be mitigated by caching midstate, the cost is 60 and not 100.</ref>; if the budget is brought below zero, script execution MUST fail and terminate immediately.\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a version 1 witness program, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.\n+** Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.\n+* Queue a deferred check<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref> that ensures the satoshis for this input's <code>nValue</code> minus <code><revault-amount></code> are included within the output <code>nValue</code> found at <code><trigger-vout-idx></code>.\n+* Queue a deferred check that ensures <code><revault-amount></code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code><revault-vout-idx></code>.\n+** These deferred checks could be characterized in terms of the pseudocode below (in ''Deferred checks'') as<br /><code>TriggerCheck(input_amount, <revault-amount>, <trigger-vout-idx>, <revault-vout-idx>)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.",
      "path": "bip-0345.mediawiki",
      "position": 284,
      "original_position": 284,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": 1357811848,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You'll normally have a signature check as well, so can just use `CHECKSIG` to get a 1 and save the byte that way? I think the only case where it could make sense to not have a signature would be with `VAULT_RECOVER`, which is the (hopefully) extremely rare case where you're probably not worried about a witness byte anyway?",
      "created_at": "2024-01-05T16:42:43Z",
      "updated_at": "2024-01-05T16:42:43Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1443106864",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1443106864"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 284,
      "original_line": 284,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1443109495",
      "pull_request_review_id": 1806378382,
      "id": 1443109495,
      "node_id": "PRRC_kwDOAN28mc5WBBp3",
      "diff_hunk": "@@ -0,0 +1,684 @@\n+<pre>\n+  BIP: 345\n+  Layer: Consensus (soft fork)\n+  Title: OP_VAULT\n+  Author: James O'Beirne <vaults@au92.org>\n+          Greg Sanders <gsanders87@gmail.com>\n+          Anthony Towns <aj@erisian.com.au>\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0345\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2023-02-03\n+  License: BSD-3-Clause\n+  Post-History: 2023-01-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-January/021318.html [bitcoin-dev] OP_VAULT announcment\n+                2023-03-01: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html [bitcoin-dev] BIP for OP_VAULT\n+</pre>\n+\n+\n+== Introduction ==\n+\n+This BIP proposes two new tapscript opcodes that add consensus support for a specialized\n+covenant: <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>. These opcodes, in conjunction with\n+<code>OP_CHECKTEMPLATEVERIFY</code>\n+([https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki BIP-0119]),\n+allow users to enforce a delay period before designated coins may be spent to\n+an arbitrary destination, with the exception of a prespecified \"recovery\" path.\n+At any time prior to final withdrawal, the coins can be spent to the\n+recovery path.\n+\n+\n+=== Motivation ===\n+\n+The hazard of custodying Bitcoin is well-known. Users of Bitcoin must go to\n+significant effort to secure their private keys, and hope that once provisioned\n+their custody system does not yield to any number of evolving and\n+persistent threats. Users have little means to intervene once a compromise is\n+detected. This proposal introduces a mechanism that significantly\n+mitigates the worst-case outcome of key compromise: coin loss.\n+\n+Introducing a way to intervene during unexpected spends allows users to\n+incorporate highly secure key storage methods or unusual fallback strategies\n+that are only exercised in the worst case, and which may otherwise be\n+operationally prohibitive. The goal of this proposal is to make this strategy\n+usable for custodians of any size with minimal complication.\n+\n+==== Example uses ====\n+\n+A common configuration for an individual custodying Bitcoin is \"single\n+signature and passphrase\" using a hardware wallet. A user with such a\n+configuration might be concerned about the risk associated with relying on a\n+single manufacturer for key management, as well as physical access to the\n+hardware. \n+\n+This individual can use <code>OP_VAULT</code> to make use of a highly secure\n+key as the unlikely recovery path, while using their existing signing procedure\n+as the withdrawal trigger key with a configured spend delay of e.g. 1 day. \n+\n+The recovery path key can be of a highly secure nature that might otherwise\n+make it impractical for daily use. For example, the key could be generated in\n+some analog fashion, or on an old computer that is then destroyed, with the\n+private key replicated only in paper form. Or the key could be a 2-of-3\n+multisig using devices from different manufacturers. Perhaps the key is\n+geographically or socially distributed. \n+\n+Since it can be any Bitcoin script policy, the recovery key can include a\n+number of spending conditions, e.g. a time-delayed fallback to an \"easier\"\n+recovery method, in case the highly secure key winds up being ''too'' highly\n+secure. \n+\n+The user can run software on their mobile device that monitors the blockchain\n+for spends of the vault outpoints. If the vaulted coins move in an unexpected\n+way, the user can immediately sweep them to the recovery path, but spending the\n+coins on a daily basis works in the same way it did prior to vaulting (aside\n+from the spend delay).\n+\n+Institutional custodians of Bitcoin may use vaults in similar fashion.\n+\n+===== Provable timelocks =====\n+\n+This proposal provides a mitigation to the \n+[https://web.archive.org/web/20230210123933/https://xkcd.com/538/ \"$5 wrench attack.\"] By\n+setting the spend delay to, say, a week, and using as the recovery path a\n+script that enforces a longer relative timelock, the owner of the vault can\n+prove that he is unable to access its value immediately. To the author's\n+knowledge, this is the only way to configure this defense without rolling\n+timelocked coins for perpetuity or relying on a trusted third party.\n+\n+== Goals ==\n+\n+[[File:bip-0345/vaults-Basic.png|frame|center]]\n+\n+Vaults in Bitcoin have been discussed formally since 2016\n+([http://fc16.ifca.ai/bitcoin/papers/MES16.pdf MES16]) and informally since [https://web.archive.org/web/20160220215151/https://bitcointalk.org/index.php?topic=511881.0 2014]. The value of\n+having a configurable delay period with recovery capability in light of an\n+unexpected spend has been widely recognized. \n+\n+The only way to implement vaults given the existing consensus rules, aside from\n+[https://github.com/revault emulating vaults with large multisig\n+configurations], is to use presigned transactions created with a one-time-use\n+key. This approach was first demonstrated\n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017755.html in 2020].\n+\n+Unfortunately, this approach has a number of practical shortcomings:\n+* generating and securely deleting ephemeral keys, which are used to emulate the vault covenant, is required,\n+* amounts and withdrawal patterns must be precommitted to,\n+* there is a necessity to precommit to an address that the funds must pass through on their way to the final withdrawal target, which is likely only known at unvault time,\n+* the particular fee management technique or wallet must be decided upon vault creation,\n+* coin loss follows if a vault address is reused,\n+* the transaction data that represents the \"bearer asset\" of the vault must be stored for perpetuity, otherwise value is lost, and\n+* the vault creation ceremony must be performed each time a new balance is to be deposited.\n+\n+The deployment of a \"precomputed\" covenant mechanism like\n+[https://github.com/bitcoin/bips/blob/master/bip-0119.mediawiki OP_CHECKTEMPLATEVERIFY] or\n+[https://github.com/bitcoin/bips/blob/master/bip-0118.mediawiki SIGHASH_ANYPREVOUT] \n+would both remove the necessity to use an ephemeral key, since the\n+covenant is enforced on-chain, and lessen the burden of sensitive data storage,\n+since the necessary transactions can be generated from a set of compact\n+parameters. This approach was demonstrated [https://github.com/jamesob/simple-ctv-vault in\n+2022].\n+\n+However, the limitations of precomputation still apply: amounts,\n+destinations, and fee management are all fixed. Funds must flow through a fixed\n+intermediary to their final destination. Batch operations, which may be vital\n+for successful recovery during fee spikes or short spend delay, are not possible.\n+\n+[[File:bip-0345/withdrawal-comparison.drawio.png|frame|center]]\n+\n+Having a \"general\" covenant mechanism that can encode arbitrary transactional\n+state machines would allow us to solve these issues, but at the cost of complex\n+and large scripts that would probably be duplicated many times over in the\n+blockchain. The particular design and deployment timeline of such a general\n+framework is also uncertain. This approach was demonstrated\n+[https://blog.blockstream.com/en-covenants-in-elements-alpha/ in 2016].\n+\n+This proposal intends to address the problems outlined above by\n+providing a delay period/recovery path use with minimal transactional and\n+operational overhead using a specialized covenant.\n+\n+The design goals of the proposal are:\n+\n+* '''efficient reuse of an existing vault configuration.'''<ref>'''Why does this support address reuse?''' The proposal doesn't rely on or encourage address reuse, but certain uses are unsafe if address reuse cannot be handled - for example, if a custodian gives its users a vault address to deposit to, it cannot enforce that those users make a single deposit for each address.</ref> A single vault configuration, whether the same literal <code>scriptPubKey</code> or not, should be able to “receive” multiple deposits. \n+\n+* '''batched operations''' for recovery and withdrawal to allow managing multiple vault coins efficiently.\n+\n+* '''unbounded partial withdrawals''', which allows users to withdraw partial vault balances without having to perform the setup ceremony for a new vault.\n+\n+* '''dynamic unvault targets''', which allow the proposed withdrawal target for a vault to be specified at withdrawal time rather than when the vault is first created. This would remove the need for a prespecified, intermediate wallet that only exists to route unvaulted funds to their desired destination.\n+\n+* '''dynamic fee management''' that, like dynamic targets, defers the specification of fee rates and source to unvault time rather than vault creation time.\n+\n+These goals are accompanied by basic safety considerations (e.g. not being\n+vulnerable to mempool pinning) and a desire for concision, both in terms of the number\n+of outputs created as well as script sizes.\n+\n+This proposal is designed to be compatible with any future sighash modes (e.g. <code>SIGHASH_GROUP</code>) or fee management strategies (e.g. [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-September/018168.html transaction sponsors]) that may be introduced. Use of these opcodes will benefit from, but do not strictly rely on, [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-September/020937.html v3 transaction relay] and [https://github.com/instagibbs/bips/blob/ephemeral_anchor/bip-ephemeralanchors.mediawiki ephemeral anchors].\n+\n+== Design ==\n+\n+In typical usage, a vault is created by encumbering coins under a\n+taptree [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki (BIP-341)]\n+containing at least two leaves: one with an <code>OP_VAULT</code>-containing script that\n+facilitates the expected withdrawal process, and another leaf with\n+<code>OP_VAULT_RECOVER</code> which ensures the coins can be recovered \n+at any time prior to withdrawal finalization.\n+\n+The rules of <code>OP_VAULT</code> ensure the timelocked, interruptible\n+withdrawal by allowing a spending transaction to replace the\n+<code>OP_VAULT</code> tapleaf with a prespecified script template, allowing for\n+some parameters to be set at spend (trigger) time. All other leaves in the\n+taptree must be unchanged in the destination output, which preserves the recovery path as well as any\n+other spending conditions originally included in the vault. This is similar to\n+the <code>TAPLEAF_UPDATE_VERIFY</code> design that was proposed \n+[https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2021-September/019419.html in 2021].\n+\n+These tapleaf replacement rules, described more precisely below, ensure a\n+timelocked withdrawal, where the timelock is fixed by the original\n+<code>OP_VAULT</code> parameters, to a fixed set of outputs (via\n+<code>OP_CHECKTEMPLATEVERIFY</code><ref>'''Why is <code>OP_CHECKTEMPLATEVERIFY</code> (BIP-119) relied upon for this proposal?''' During the withdrawal process, the proposed final destination for value being withdrawn must be committed to. <code>OP_CTV</code> is the simplest, safest way to commit the spend of some coins to a particular set of outputs. An earlier version of this proposal attempted to use a simpler, but similar method, of locking the spend of coins to a set of outputs, but this method introduced txid malleability.<br />Note that if some other method of locking spends to a particular set of outputs should be deployed, that method can be used in the <code>OP_VAULT</code> <code><leaf-update-script-body></code> with no changes.</ref>) which is chosen when the withdrawal\n+process is triggered.\n+\n+While <code>OP_CHECKTEMPLATEVERIFY</code> is used in this proposal as the\n+preferred method to bind the proposed withdrawal to a particular set of final\n+outputs, <code>OP_VAULT</code> is composable with other (and future) opcodes to\n+facilitate other kinds of withdrawal processes.\n+\n+[[File:bip-0345/opvault.drawio.png|frame|center]]\n+\n+\n+=== Transaction types ===\n+\n+The vault has a number of stages, some of them optional:\n+\n+* '''vault transaction''': encumbers some coins into a Taproot structure that includes at least one <code>OP_VAULT</code> leaf and one <code>OP_VAULT_RECOVER</code> leaf.\n+\n+* '''trigger transaction''': spends one or more <code>OP_VAULT</code>-tapleaf inputs into an output which is encumbered by a timelocked withdrawal to a fixed set of outputs, chosen at trigger time. This publicly broadcasts the intent to withdraw to some specific set of outputs.<br /><br />The trigger transaction may have an additional output which allocates some of the vault balance into a partial \"revault,\" which simply encumbers the revaulted portion of the value into the same <code>scriptPubKey</code> as the <code>OP_VAULT</code>-containing input(s) being spent.\n+\n+* '''withdrawal transaction''': spends the timelocked, destination-locked trigger inputs into a compatible set of final withdrawal outputs (per, e.g., a <code>CHECKTEMPLATEVERIFY</code> hash), after the trigger inputs have matured per the spend delay. Timelocked CTV transactions are the motivating usage of OP_VAULT, but any script template can be specified during the creation of the vault.\n+\n+* '''recovery transaction''': spends one or more vault inputs via <code>OP_VAULT_RECOVER</code> tapleaf to the prespecified recovery path, which can be done at any point before the withdrawal transaction confirms. Each input can optionally require a witness satisfying a specified ''recovery authorization'' script, an optional script prefixing the <code>OP_VAULT_RECOVER</code> fragment. The use of recovery authorization has certain trade-offs discussed later.\n+\n+\n+=== Fee management ===\n+\n+A primary consideration of this proposal is how fee management is handled.\n+Providing dynamic fee management is critical to the operation of a vault, since \n+\n+* precalculated fees are prone to making transactions unconfirmable in high fee environments, and\n+* a fee wallet that is prespecified might be compromised or lost before use.\n+\n+But dynamic fee management can introduce\n+[https://bitcoinops.org/en/topics/transaction-pinning/ pinning vectors]. Care\n+has been taken to avoid unnecessarily introducing these vectors when using the new \n+destination-based spending policies that this proposal introduces.\n+\n+Originally, this proposal had a hard dependency on reformed transaction\n+nVersion=3 policies, including ephemeral anchors, but it has since been revised\n+to simply benefit from these changes in policy as well as other potential fee\n+management mechanisms.\n+\n+\n+== Specification ==\n+\n+The tapscript opcodes <code>OP_SUCCESS187</code> (<code>0xbb</code>) and\n+<code>OP_SUCCESS188</code> (<code>0xbc</code>) are constrained with new rules\n+to implement <code>OP_VAULT</code> and <code>OP_VAULT_RECOVER</code>,\n+respectively.\n+\n+=== <code>OP_VAULT</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT</code> (<code>OP_SUCCESS187</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<leaf-update-script-body>\n+<n-pushes>\n+[ n leaf-update script data items ... ]\n+<trigger-vout-idx> \n+<revault-vout-idx>\n+<revault-amount>\n+</source>\n+\n+where\n+\n+* <code><leaf-update-script-body></code> is a minimally-encoded data push of a serialized script. <ref>In conjunction with the leaf-update data items, it dictates the tapleaf script in the output taptree that will replace the one currently executing.</ref>\n+** Otherwise, script execution MUST fail and terminate immediately.\n+\n+* <code><n-pushes></code> is an up to 4-byte <code>CScriptNum</code>-encoded number indicating how many leaf-update script items should be popped off the stack. <ref>'''Why only prepending with data pushes?''' Prepending the <code>leaf-update-script-body</code> with opcodes opens up the door to prepending OP_SUCCESSX opcodes, to name a single issue only, side-stepping the validation that was meant to be run by the committed script.</ref>\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0, script execution when spending this output MUST fail and terminate immediately.\n+** If there are fewer than 3 items following the <code><n-pushes></code> items on the stack, script execution when spending this output MUST fail and terminate immediately. In other words, after popping <code><leaf-update-script-body></code>, there must be at least <code>3 + <n-pushes></code> items remaining on the stack.\n+\n+* The following <code><n-pushes></code> stack items are popped off the stack and prefixed as minimally-encoded push-data arguments to the <code><leaf-update-script-body></code> to construct the expected tapleaf replacement script.\n+\n+* <code><trigger-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the output which, in conjunction with an optional revault output, carries forward the value of this input, and has an identical taptree aside from the currently executing leaf.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+* <code><revault-vout-idx></code> is an up to 4-byte CScriptNum-encoded number optionally indicating the index of an output which, in conjunction with the trigger output, carries forward the value of this input, and has an identical scriptPubKey to the current input.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is negative and not equal to -1, script execution when spending this output MUST fail and terminate immediately.<ref>'''Why is -1 the only allowable negative value for revault-vout-idx?''' A negative revault index indicates that no revault output exists; if this value were allowed to be any negative number, the witness could be malleated (and bloated) while a transaction is waiting for confirmation.</ref>\n+\n+* <code><revault-amount></code> is an up to 7-byte CScriptNum-encoded number indicating the number of satoshis being revaulted.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is not greater than or equal to 0, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is non-zero but <code><revault-vout-idx></code> is negative, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Decrement the per-script sigops budget (see [https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#user-content-Resource_limits BIP-0342]) by 60<ref>'''Why is the sigops cost for OP_VAULT set to 60?''' To determine the validity of a trigger output, OP_VAULT must perform an EC multiplication and hashing proportional to the length of the control block in order to generate the output's expected TapTweak. This has been measured to have a cost in the worst case (max length control block) of roughly twice a Schnorr verification. Because the hashing cost could be mitigated by caching midstate, the cost is 60 and not 100.</ref>; if the budget is brought below zero, script execution MUST fail and terminate immediately.\n+* Let the output designated by <code><trigger-vout-idx></code> be called ''triggerOut''.\n+* If the scriptPubKey of ''triggerOut'' is not a version 1 witness program, script execution MUST fail and terminate immediately.\n+* Let the script constructed by taking the <code><leaf-update-script-body></code> and prefixing it with minimally-encoded data pushes of the <code><n-pushes></code> leaf-update script data items be called the ''leaf-update-script''.\n+** Note: the leaf-update data items will be in the same order in the ''leaf-update-script'' as they appeared on the stack.\n+* If the scriptPubKey of ''triggerOut'' does not match that of a taptree that is identical to that of the currently evaluated input, but with the leaf script substituted for ''leaf-update-script'', script execution when spending this output MUST fail and terminate immediately.\n+** Note: the parity bit of the resulting taproot output is allowed to vary, so both values for the new output must be checked.\n+* Let the output designated by <code><revault-vout-idx></code> (if the index value is non-negative) be called ''revaultOut''.\n+* If the scriptPubKey of ''revaultOut'' is not equal to the scriptPubKey of the input being spent, script execution when spending this output MUST fail and terminate immediately.\n+* Implemetation recommendation: if the sum of the amounts of ''triggerOut'' and ''revaultOut'' (if any) are not greater than or equal to the value of this input, script execution when spending this output SHOULD fail and terminate immediately.\n+** Amount checks are ultimately done with deferred checks, but this check can help short-circuit obviously invalid spends.\n+* Queue a deferred check<ref>'''What is a deferred check and why does this proposal require them for correct script evaluation?''' A deferred check is a validation check that is executed only after all input scripts have been validated, and is based on aggregate information collected during each input's EvalScript run.<br /><br />Currently, the validity of each input is (usually) checked concurrently across all inputs in a transaction. Because this proposal allows batching the spend of multiple vault inputs into a single recovery or withdrawal output, we need a mechanism to ensure that all expected values per output can be summed and then checked. This necessitates the introduction of an \"aggregating\" set of checks which can only be executed after each input's script is evaluated. Note that similar functionality would be required for batch input validation or cross-input signature aggregation.</ref> that ensures the satoshis for this input's <code>nValue</code> minus <code><revault-amount></code> are included within the output <code>nValue</code> found at <code><trigger-vout-idx></code>.\n+* Queue a deferred check that ensures <code><revault-amount></code> satoshis, if non-zero, are included within the output's <code>nValue</code> found at <code><revault-vout-idx></code>.\n+** These deferred checks could be characterized in terms of the pseudocode below (in ''Deferred checks'') as<br /><code>TriggerCheck(input_amount, <revault-amount>, <trigger-vout-idx>, <revault-vout-idx>)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== <code>OP_VAULT_RECOVER</code> evaluation ===\n+\n+When evaluating <code>OP_VAULT_RECOVER</code> (<code>OP_SUCCESS188</code>,\n+<code>0xbb</code>), the expected format of the stack, shown top to bottom, is:\n+\n+<source>\n+<recovery-sPK-hash>\n+<recovery-vout-idx>\n+</source>\n+\n+where\n+\n+* <code><recovery-sPK-hash></code> is a 32-byte data push.\n+** If this is not 32 bytes in length, script execution when spending this output MUST fail and terminate immediately.\n+* <code><recovery-vout-idx></code> is an up to 4-byte CScriptNum-encoded number indicating the index of the recovery output.\n+** If this value does not decode to a valid CScriptNum, script execution when spending this output MUST fail and terminate immediately.\n+** If this value is less than 0 or is greater than or equal to the number of outputs, script execution when spending this output MUST fail and terminate immediately.\n+\n+After the stack is parsed, the following validation checks are performed:\n+\n+* Let the output at index <code><recovery-vout-idx></code> be called ''recoveryOut''.\n+* If the scriptPubKey of ''recoveryOut'' does not have a tagged hash equal to <code><recovery-sPK-hash></code> (<code>tagged_hash(\"VaultRecoverySPK\", recoveryOut.scriptPubKey) == recovery-sPK-hash</code>, where <code>tagged_hash()</code> is from the [https://github.com/bitcoin/bips/blob/master/bip-0340/reference.py BIP-0340 reference code]), script execution when spending this output MUST fail and terminate immediately.\n+** Implementation recommendation: if ''recoveryOut'' does not have an <code>nValue</code> greater than or equal to this input's amount, the script SHOULD fail and terminate immediately.\n+* Queue a deferred check that ensures the <code>nValue</code> of ''recoveryOut'' contains the entire <code>nValue</code> of this input.<ref>'''How do recovery transactions pay for fees?''' If the recovery is unauthorized, fees are attached either via CPFP with an ephemeral anchor or as inputs which are solely spent to fees (i.e. no change output). If the recovery is authorized, fees can be attached in any manner, e.g. unrelated inputs and outputs or CPFP via anchor.</ref>\n+** This deferred check could be characterized in terms of the pseudocode below as <code>RecoveryCheck(<recovery-vout-idx>, input_amount)</code>.\n+\n+If none of the conditions fail, a single true value (<code>0x01</code>) is left on the stack.\n+\n+=== Deferred check evaluation ===\n+\n+Once all inputs for a transaction are validated per the rules above, any\n+deferred checks queued MUST be evaluated.\n+\n+The Python pseudocode for this is as follows:\n+\n+<source lang=\"python\">\n+class TriggerCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT (withdrawal trigger).\"\"\"\n+    input_amount: int\n+    revault_amount: int\n+    trigger_vout_idx: int\n+    revault_vout_idx: int\n+\n+\n+class RecoveryCheck:\n+    \"\"\"Queued by evaluation of OP_VAULT_RECOVER.\"\"\"\n+    input_amount: int\n+    vout_idx: int\n+\n+\n+def validate_deferred_checks(checks: [DeferredCheck], tx: Transaction) -> bool:\n+    \"\"\"\n+    Ensure that all value from vault inputs being triggered or recovered is preserved\n+    in suitable output nValues.\n+    \"\"\"\n+    # Map to hold expected output values.\n+    out_map: Dict[int, int] = defaultdict(lambda: 0)\n+\n+    for c in checks:\n+        if isinstance(c, TriggerCheck):\n+            out_map[c.trigger_vout_idx] += (c.input_amount - c.revault_amount)\n+\n+            if c.revault_amount > 0:\n+                out_map[c.revault_vout_idx] += c.revault_amount\n+\n+        elif isinstance(c, RecoveryCheck):\n+            out_map[c.vout_idx] += c.input_amount\n+\n+    for (vout_idx, amount_sats) in out_map.items():\n+        # Trigger/recovery value can be greater than the constituent vault input\n+        # amounts.\n+        if tx.vout[vout_idx].nValue < amount_sats:\n+            return False\n+\n+    return True\n+</source>\n+\n+If the above procedure, or an equivalent, returns false, script execution MUST fail and terminate\n+immediately.\n+\n+This ensures that all compatible vault inputs can be batched into shared\n+corresponding trigger or recovery outputs while preserving their entire input value.\n+\n+\n+== Policy changes ==",
      "path": "bip-0345.mediawiki",
      "position": 370,
      "original_position": 370,
      "commit_id": "de9ef59307f5d94883eefd2c6691c67d358d915a",
      "original_commit_id": "eb3fb727c31dd348a63992d22a35558e031174f9",
      "in_reply_to_id": 1357816644,
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I would have suggested just having a separate BIP for the policy approach, but apparently policy is now out of scope for BIPs so... The point of separating would have been that the consensus changes could continue to work even as policy evolves over time, so locking in a description of a policy could become confusing when that policy becomes outdated.",
      "created_at": "2024-01-05T16:45:24Z",
      "updated_at": "2024-01-05T16:45:24Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1421#discussion_r1443109495",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1443109495"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1421"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 370,
      "original_line": 370,
      "side": "RIGHT"
    }
  ]
}