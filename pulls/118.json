{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/118",
    "id": 24135871,
    "node_id": "MDExOlB1bGxSZXF1ZXN0MjQxMzU4NzE=",
    "html_url": "https://github.com/bitcoin/bips/pull/118",
    "diff_url": "https://github.com/bitcoin/bips/pull/118.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/118.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/118",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/118/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/118/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/118/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/b05bc1ef5348a4d50bc3012865534b73dbc2164d",
    "number": 118,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "BIP65 CHECKLOCKTIMEVERIFY",
    "user": {
      "login": "petertodd",
      "id": 7042,
      "node_id": "MDQ6VXNlcjcwNDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/petertodd",
      "html_url": "https://github.com/petertodd",
      "followers_url": "https://api.github.com/users/petertodd/followers",
      "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
      "organizations_url": "https://api.github.com/users/petertodd/orgs",
      "repos_url": "https://api.github.com/users/petertodd/repos",
      "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/petertodd/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "@gmaxwell As discussed.\n",
    "labels": [],
    "created_at": "2014-11-10T09:49:04Z",
    "updated_at": "2014-11-12T15:24:08Z",
    "closed_at": "2014-11-12T10:31:19Z",
    "mergeable_state": "unknown",
    "merged_at": "2014-11-12T10:31:19Z",
    "merge_commit_sha": "e0c1abd9589fccc71d938b74d297de19db72d380",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "petertodd:bip65-checklocktimeverify",
      "ref": "bip65-checklocktimeverify",
      "sha": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 13728580,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMzcyODU4MA==",
        "name": "bips",
        "full_name": "petertodd/bips",
        "owner": {
          "login": "petertodd",
          "id": 7042,
          "node_id": "MDQ6VXNlcjcwNDI=",
          "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/petertodd",
          "html_url": "https://github.com/petertodd",
          "followers_url": "https://api.github.com/users/petertodd/followers",
          "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
          "organizations_url": "https://api.github.com/users/petertodd/orgs",
          "repos_url": "https://api.github.com/users/petertodd/repos",
          "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/petertodd/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/petertodd/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/petertodd/bips",
        "archive_url": "https://api.github.com/repos/petertodd/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/petertodd/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/petertodd/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/petertodd/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/petertodd/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/petertodd/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/petertodd/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/petertodd/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/petertodd/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/petertodd/bips/contributors",
        "deployments_url": "https://api.github.com/repos/petertodd/bips/deployments",
        "downloads_url": "https://api.github.com/repos/petertodd/bips/downloads",
        "events_url": "https://api.github.com/repos/petertodd/bips/events",
        "forks_url": "https://api.github.com/repos/petertodd/bips/forks",
        "git_commits_url": "https://api.github.com/repos/petertodd/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/petertodd/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/petertodd/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/petertodd/bips.git",
        "issue_comment_url": "https://api.github.com/repos/petertodd/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/petertodd/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/petertodd/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/petertodd/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/petertodd/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/petertodd/bips/languages",
        "merges_url": "https://api.github.com/repos/petertodd/bips/merges",
        "milestones_url": "https://api.github.com/repos/petertodd/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/petertodd/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/petertodd/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/petertodd/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:petertodd/bips.git",
        "stargazers_url": "https://api.github.com/repos/petertodd/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/petertodd/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/petertodd/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/petertodd/bips/subscription",
        "tags_url": "https://api.github.com/repos/petertodd/bips/tags",
        "teams_url": "https://api.github.com/repos/petertodd/bips/teams",
        "trees_url": "https://api.github.com/repos/petertodd/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/petertodd/bips.git",
        "hooks_url": "https://api.github.com/repos/petertodd/bips/hooks",
        "svn_url": "https://github.com/petertodd/bips",
        "homepage": "bitcoin.org",
        "language": "Protocol Buffer",
        "forks_count": 0,
        "stargazers_count": 10,
        "watchers_count": 10,
        "size": 1393,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2016-01-13T19:56:51Z",
        "created_at": "2013-10-20T23:05:31Z",
        "updated_at": "2023-07-16T05:45:53Z"
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "6d120e62af832d822544f8bf3d5e97900234f59a",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5535,
        "stargazers_count": 8220,
        "watchers_count": 8220,
        "size": 13787,
        "default_branch": "master",
        "open_issues_count": 112,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-08-01T12:09:15Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2023-08-01T09:08:43Z"
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 290,
    "deletions": 0,
    "changed_files": 2,
    "commits": 2,
    "review_comments": 16,
    "comments": 4
  },
  "events": [
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTQ1MzE3Mzc6NWY2Y2IwNGQ5YzI4Yjc2ZjMzZjE4ZGJmNDM5MjNjODg4NjBjMjU5Mg==",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/5f6cb04d9c28b76f33f18dbf43923c88860c2592",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/5f6cb04d9c28b76f33f18dbf43923c88860c2592",
      "tree": {
        "sha": "f8f028c2be50528924ff94b820750fe59752e00f",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/f8f028c2be50528924ff94b820750fe59752e00f"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/6d120e62af832d822544f8bf3d5e97900234f59a",
          "sha": "6d120e62af832d822544f8bf3d5e97900234f59a",
          "html_url": "https://github.com/bitcoin/bips/commit/6d120e62af832d822544f8bf3d5e97900234f59a"
        }
      ],
      "message": "First draft",
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2014-11-10T09:43:48Z"
      },
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2014-10-01T12:59:26Z"
      },
      "sha": "5f6cb04d9c28b76f33f18dbf43923c88860c2592"
    },
    {
      "event": "mentioned",
      "id": 190672228,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTkwNjcyMjI4",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/190672228",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2014-11-10T09:49:04Z"
    },
    {
      "event": "subscribed",
      "id": 190672229,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDE5MDY3MjIyOQ==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/190672229",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2014-11-10T09:49:04Z"
    },
    {
      "event": "renamed",
      "id": 190672280,
      "node_id": "MDE3OlJlbmFtZWRUaXRsZUV2ZW50MTkwNjcyMjgw",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/190672280",
      "actor": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2014-11-10T09:49:11Z",
      "rename": {
        "from": "Bip65 checklocktimeverify",
        "to": "BIP65 checklocktimeverify"
      }
    },
    {
      "event": "renamed",
      "id": 190673306,
      "node_id": "MDE3OlJlbmFtZWRUaXRsZUV2ZW50MTkwNjczMzA2",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/190673306",
      "actor": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2014-11-10T09:50:52Z",
      "rename": {
        "from": "BIP65 checklocktimeverify",
        "to": "BIP65 CHECKLOCKTIMEVERIFY"
      }
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMTcxNDg3NDQ6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "head_ref_force_pushed",
      "id": 190762770,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTkwNzYyNzcw",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/190762770",
      "actor": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2014-11-10T13:22:48Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTQ1MzE3Mzc6YjA1YmMxZWY1MzQ4YTRkNTBiYzMwMTI4NjU1MzRiNzNkYmMyMTY0ZA==",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "tree": {
        "sha": "e0b984f63bd6a4d1b7653f47a9cb17d63ecadedc",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/e0b984f63bd6a4d1b7653f47a9cb17d63ecadedc"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree e0b984f63bd6a4d1b7653f47a9cb17d63ecadedc\nparent 5f6cb04d9c28b76f33f18dbf43923c88860c2592\nauthor Peter Todd <pete@petertodd.org> 1415612589 -0500\ncommitter Peter Todd <pete@petertodd.org> 1415625768 -0500\n\nBIP65 assigned for CHECKLOCKTIMEVERIFY\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGrBAABCACVBQJUYLwqXhSAAAAAABUAQGJsb2NraGFzaEBiaXRjb2luLm9yZzAw\nMDAwMDAwMDAwMDAwMDAwMWFmMmNmMWVhMTdlODkwM2ViN2YzZTU4MTRiYmMyMjRi\nMTQ3MmU1NjA0NWIzOGQvFIAAAAAAFQARcGthLWFkZHJlc3NAZ251cGcub3JncGV0\nZUBwZXRlcnRvZC5vcmcACgkQJIFAPaXwkfvYswf/dEBTxIbFozCk7ltimZ8G8Fnq\n7rDODL3S41n94bqsWy3xGLRaXUFdJzsOpukDqoDNIdZtzvd+5ziOXDmRTre4Xrp+\nBSKXwjRiNVBHCNgQ7TMU3/O9X6pNFrg3faAkbrHNX0hhpqG3yuqtAUuZvAM43Q9z\nSLuxTpnyzWa9RYU1yzxspk7asXOS5+OXFjY5GkN/dkleW+PcMIHFwMtF5Rm8zYR4\n9SzpN67vbYqbv+CsgiVfF1RHR8GzesI5NUiIzCvsarQdjDSjwwFqCgeWt1A/HuLR\nG4r3tlMQTA2wqby+EI7htWi3UpSAEu9A/Me5yOhZH2PWQ5Ahm9DuAHKekMhpJA==\n=hoFb\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/5f6cb04d9c28b76f33f18dbf43923c88860c2592",
          "sha": "5f6cb04d9c28b76f33f18dbf43923c88860c2592",
          "html_url": "https://github.com/bitcoin/bips/commit/5f6cb04d9c28b76f33f18dbf43923c88860c2592"
        }
      ],
      "message": "BIP65 assigned for CHECKLOCKTIMEVERIFY",
      "committer": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2014-11-10T13:22:48Z"
      },
      "author": {
        "name": "Peter Todd",
        "email": "pete@petertodd.org",
        "date": "2014-11-10T09:43:09Z"
      },
      "sha": "b05bc1ef5348a4d50bc3012865534b73dbc2164d"
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMTcxNDg3NDc6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "line-commented",
      "id": null,
      "node_id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMTcxNDg3NDk6djI=",
      "url": null,
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null
    },
    {
      "event": "referenced",
      "id": 191948728,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDE5MTk0ODcyOA==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/191948728",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "a3715c2de5a3df3b94c3335e6ea6924a566d9d58",
      "commit_url": "https://api.github.com/repos/bitcoin/bips/commits/a3715c2de5a3df3b94c3335e6ea6924a566d9d58",
      "created_at": "2014-11-12T10:31:19Z"
    },
    {
      "event": "merged",
      "id": 191948729,
      "node_id": "MDExOk1lcmdlZEV2ZW50MTkxOTQ4NzI5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/191948729",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "a3715c2de5a3df3b94c3335e6ea6924a566d9d58",
      "commit_url": "https://api.github.com/repos/bitcoin/bips/commits/a3715c2de5a3df3b94c3335e6ea6924a566d9d58",
      "created_at": "2014-11-12T10:31:19Z"
    },
    {
      "event": "closed",
      "id": 191948730,
      "node_id": "MDExOkNsb3NlZEV2ZW50MTkxOTQ4NzMw",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/191948730",
      "actor": {
        "login": "gmaxwell",
        "id": 858454,
        "node_id": "MDQ6VXNlcjg1ODQ1NA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gmaxwell",
        "html_url": "https://github.com/gmaxwell",
        "followers_url": "https://api.github.com/users/gmaxwell/followers",
        "following_url": "https://api.github.com/users/gmaxwell/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gmaxwell/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gmaxwell/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
        "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
        "repos_url": "https://api.github.com/users/gmaxwell/repos",
        "events_url": "https://api.github.com/users/gmaxwell/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2014-11-12T10:31:19Z"
    },
    {
      "event": "commented",
      "id": 62719821,
      "node_id": "MDEyOklzc3VlQ29tbWVudDYyNzE5ODIx",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/62719821",
      "actor": {
        "login": "ghost",
        "id": 10137,
        "node_id": "MDQ6VXNlcjEwMTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ghost",
        "html_url": "https://github.com/ghost",
        "followers_url": "https://api.github.com/users/ghost/followers",
        "following_url": "https://api.github.com/users/ghost/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ghost/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ghost/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
        "organizations_url": "https://api.github.com/users/ghost/orgs",
        "repos_url": "https://api.github.com/users/ghost/repos",
        "events_url": "https://api.github.com/users/ghost/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ghost/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2014-11-12T13:50:20Z",
      "updated_at": "2014-11-12T13:50:20Z",
      "author_association": "NONE",
      "body": "The process described under the escrow portion is technically not escrow.  Escrow is when a third party has control of the funds.\n",
      "user": {
        "login": "ghost",
        "id": 10137,
        "node_id": "MDQ6VXNlcjEwMTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ghost",
        "html_url": "https://github.com/ghost",
        "followers_url": "https://api.github.com/users/ghost/followers",
        "following_url": "https://api.github.com/users/ghost/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ghost/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ghost/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
        "organizations_url": "https://api.github.com/users/ghost/orgs",
        "repos_url": "https://api.github.com/users/ghost/repos",
        "events_url": "https://api.github.com/users/ghost/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ghost/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/118#issuecomment-62719821",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/118"
    },
    {
      "event": "commented",
      "id": 62726437,
      "node_id": "MDEyOklzc3VlQ29tbWVudDYyNzI2NDM3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/62726437",
      "actor": {
        "login": "hoffmabc",
        "id": 45482,
        "node_id": "MDQ6VXNlcjQ1NDgy",
        "avatar_url": "https://avatars.githubusercontent.com/u/45482?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hoffmabc",
        "html_url": "https://github.com/hoffmabc",
        "followers_url": "https://api.github.com/users/hoffmabc/followers",
        "following_url": "https://api.github.com/users/hoffmabc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hoffmabc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hoffmabc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hoffmabc/subscriptions",
        "organizations_url": "https://api.github.com/users/hoffmabc/orgs",
        "repos_url": "https://api.github.com/users/hoffmabc/repos",
        "events_url": "https://api.github.com/users/hoffmabc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hoffmabc/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2014-11-12T14:37:24Z",
      "updated_at": "2014-11-12T14:37:24Z",
      "author_association": "NONE",
      "body": "@millybitcoin I'm not sure what you mean by that. There is technically a third-party represented by the multisig signing group. It is not a single person but rather a group fulfilling this role. I believe this meets your definition perfectly fine.\n",
      "user": {
        "login": "hoffmabc",
        "id": 45482,
        "node_id": "MDQ6VXNlcjQ1NDgy",
        "avatar_url": "https://avatars.githubusercontent.com/u/45482?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hoffmabc",
        "html_url": "https://github.com/hoffmabc",
        "followers_url": "https://api.github.com/users/hoffmabc/followers",
        "following_url": "https://api.github.com/users/hoffmabc/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hoffmabc/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hoffmabc/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hoffmabc/subscriptions",
        "organizations_url": "https://api.github.com/users/hoffmabc/orgs",
        "repos_url": "https://api.github.com/users/hoffmabc/repos",
        "events_url": "https://api.github.com/users/hoffmabc/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hoffmabc/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/118#issuecomment-62726437",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/118"
    },
    {
      "event": "mentioned",
      "id": 192060232,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50MTkyMDYwMjMy",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/192060232",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": "2014-11-12T14:37:24Z"
    },
    {
      "event": "subscribed",
      "id": 192060233,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDE5MjA2MDIzMw==",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/192060233",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": "2014-11-12T14:37:24Z"
    },
    {
      "event": "commented",
      "id": 62731181,
      "node_id": "MDEyOklzc3VlQ29tbWVudDYyNzMxMTgx",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/62731181",
      "actor": {
        "login": "ghost",
        "id": 10137,
        "node_id": "MDQ6VXNlcjEwMTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ghost",
        "html_url": "https://github.com/ghost",
        "followers_url": "https://api.github.com/users/ghost/followers",
        "following_url": "https://api.github.com/users/ghost/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ghost/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ghost/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
        "organizations_url": "https://api.github.com/users/ghost/orgs",
        "repos_url": "https://api.github.com/users/ghost/repos",
        "events_url": "https://api.github.com/users/ghost/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ghost/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2014-11-12T15:02:25Z",
      "updated_at": "2014-11-12T15:02:49Z",
      "author_association": "NONE",
      "body": "It is not \"my definition,\" it is the normal definition of escrow which means a third party has custody of the funds.  This is also a legal definition and escrow operators normally need a special license and bonding because they have custody of the funds.  In my State an escrow agent needs a special license and needs to be fingerprinted.  \n\nIf you have a 2-of-3 transactions where 2 people are doing a transaction and a third party has authority to sign the transaction as a mediator then that is not escrow because the mediator does not have custody of the funds.\n\nMay people also confuse escrow with dispute resolution.  Dispute resolution is a separate and distinct process from escrow and is usually a conflict of interest for one party to do both.  You can see the agreement at escrow.com as an example of how these functions are separate\n",
      "user": {
        "login": "ghost",
        "id": 10137,
        "node_id": "MDQ6VXNlcjEwMTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ghost",
        "html_url": "https://github.com/ghost",
        "followers_url": "https://api.github.com/users/ghost/followers",
        "following_url": "https://api.github.com/users/ghost/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ghost/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ghost/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
        "organizations_url": "https://api.github.com/users/ghost/orgs",
        "repos_url": "https://api.github.com/users/ghost/repos",
        "events_url": "https://api.github.com/users/ghost/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ghost/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/118#issuecomment-62731181",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/118"
    },
    {
      "event": "commented",
      "id": 62734824,
      "node_id": "MDEyOklzc3VlQ29tbWVudDYyNzM0ODI0",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/62734824",
      "actor": {
        "login": "ghost",
        "id": 10137,
        "node_id": "MDQ6VXNlcjEwMTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ghost",
        "html_url": "https://github.com/ghost",
        "followers_url": "https://api.github.com/users/ghost/followers",
        "following_url": "https://api.github.com/users/ghost/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ghost/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ghost/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
        "organizations_url": "https://api.github.com/users/ghost/orgs",
        "repos_url": "https://api.github.com/users/ghost/repos",
        "events_url": "https://api.github.com/users/ghost/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ghost/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2014-11-12T15:24:07Z",
      "updated_at": "2014-11-12T15:24:07Z",
      "author_association": "NONE",
      "body": "maybe it should be labeled \"Escrow Alternative\" or \"Mediated Transaction\"\n",
      "user": {
        "login": "ghost",
        "id": 10137,
        "node_id": "MDQ6VXNlcjEwMTM3",
        "avatar_url": "https://avatars.githubusercontent.com/u/10137?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ghost",
        "html_url": "https://github.com/ghost",
        "followers_url": "https://api.github.com/users/ghost/followers",
        "following_url": "https://api.github.com/users/ghost/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ghost/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ghost/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ghost/subscriptions",
        "organizations_url": "https://api.github.com/users/ghost/orgs",
        "repos_url": "https://api.github.com/users/ghost/repos",
        "events_url": "https://api.github.com/users/ghost/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ghost/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/118#issuecomment-62734824",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/118"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20080015",
      "pull_request_review_id": null,
      "id": 20080015,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDgwMDE1",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.\n+\n+The nLockTime field in a transaction prevents the transaction from being mined\n+until either a certain block height, or block time, has been reached. By\n+comparing the argument to CHECKLOCKTIMEVERIFY against the nLockTime field, we\n+indirectly verify that the desired block height or block time has been reached;\n+until that block height or block time has been reached the transaction output\n+remains unspendable.\n+\n+\n+==Motivation==\n+\n+The nLockTime field in transactions makes it possible to prove that a\n+transaction output can be spent in the future: a valid signature for a\n+transaction with the desired nLockTime can be constructed, proving that it is\n+possible to spend the output with that signature when the nLockTime is reached.\n+An example where this technique is used is in micro-payment channels, where the\n+nLockTime field proves that should the receiver vanish the sender is guaranteed\n+to get all their escrowed funds back when the nLockTime is reached.\n+\n+However the nLockTime field is insufficient if you wish to prove that\n+transaction output ''can-not'' be spent until some time in the future, as there\n+is no way to prove that the secret keys corresponding to the pubkeys controling\n+the funds have not been used to create a valid signature.\n+\n+\n+===Escrow===\n+\n+If Alice and Bob jointly operate a business they may want to\n+ensure that all funds are kept in 2-of-2 multisig transaction outputs that\n+require the co-operation of both parties to spend. However, they recognise that\n+in exceptional circumstances such as either party getting \"hit by a bus\" they\n+need a backup plan to retrieve the funds. So they appoint their lawyer, Lenny,\n+to act as a third-party.\n+\n+With a standard 2-of-3 CHECKMULTISIG at any time Lenny could conspire with\n+either Alice or Bob to steal the funds illegitimately. Equally Lenny may prefer\n+not to have immediate access to the funds to discourage bad actors from\n+attempting to get the secret keys from him by force.\n+\n+However with CHECKLOCKTIMEVERIFY the funds can be stored in scriptPubKeys of\n+the form:\n+\n+    IF\n+        <now + 3 months> CHECKLOCKTIMEVERIFY DROP\n+        <Lenny's pubkey> CHECKSIGVERIFY\n+        1\n+    ELSE\n+        2\n+    ENDIF\n+    <Alice's pubkey> <Bob's pubkey> 2 CHECKMULTISIG\n+\n+At any time the funds can be spent with the following scriptSig:\n+\n+    <Alice's signature> <Bob's signature> 0\n+\n+After 3 months have passed Lenny and one of either Alice or Bob can spend the\n+funds with the following scriptSig:\n+\n+    <Alice/Bob's signature> <Lenny's signature> 1\n+\n+\n+===Non-interactive time-locked refunds===\n+\n+There exist a number of protocols where a transaction output is created that\n+the co-operation of both parties to spend the output. To ensure the failure of",
      "path": "bip-0065.mediawiki",
      "position": null,
      "original_position": 88,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "759c1f535bd9f0954687455ea09e412d296c3ac3",
      "in_reply_to_id": null,
      "user": {
        "login": "harding",
        "id": 61096,
        "node_id": "MDQ6VXNlcjYxMDk2",
        "avatar_url": "https://avatars.githubusercontent.com/u/61096?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/harding",
        "html_url": "https://github.com/harding",
        "followers_url": "https://api.github.com/users/harding/followers",
        "following_url": "https://api.github.com/users/harding/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/harding/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/harding/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/harding/subscriptions",
        "organizations_url": "https://api.github.com/users/harding/orgs",
        "repos_url": "https://api.github.com/users/harding/repos",
        "events_url": "https://api.github.com/users/harding/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/harding/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think there's a missing \"requires\" between line 87 and 88: \"is created that [requires] the co-operation of both parties\"\n",
      "created_at": "2014-11-10T12:58:36Z",
      "updated_at": "2014-11-10T13:22:48Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20080015",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20080015"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20080964",
      "pull_request_review_id": null,
      "id": 20080964,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDgwOTY0",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.\n+\n+The nLockTime field in a transaction prevents the transaction from being mined\n+until either a certain block height, or block time, has been reached. By\n+comparing the argument to CHECKLOCKTIMEVERIFY against the nLockTime field, we\n+indirectly verify that the desired block height or block time has been reached;\n+until that block height or block time has been reached the transaction output\n+remains unspendable.\n+\n+\n+==Motivation==\n+\n+The nLockTime field in transactions makes it possible to prove that a\n+transaction output can be spent in the future: a valid signature for a\n+transaction with the desired nLockTime can be constructed, proving that it is\n+possible to spend the output with that signature when the nLockTime is reached.\n+An example where this technique is used is in micro-payment channels, where the\n+nLockTime field proves that should the receiver vanish the sender is guaranteed\n+to get all their escrowed funds back when the nLockTime is reached.\n+\n+However the nLockTime field is insufficient if you wish to prove that\n+transaction output ''can-not'' be spent until some time in the future, as there\n+is no way to prove that the secret keys corresponding to the pubkeys controling\n+the funds have not been used to create a valid signature.\n+\n+\n+===Escrow===\n+\n+If Alice and Bob jointly operate a business they may want to\n+ensure that all funds are kept in 2-of-2 multisig transaction outputs that\n+require the co-operation of both parties to spend. However, they recognise that\n+in exceptional circumstances such as either party getting \"hit by a bus\" they\n+need a backup plan to retrieve the funds. So they appoint their lawyer, Lenny,\n+to act as a third-party.\n+\n+With a standard 2-of-3 CHECKMULTISIG at any time Lenny could conspire with\n+either Alice or Bob to steal the funds illegitimately. Equally Lenny may prefer\n+not to have immediate access to the funds to discourage bad actors from\n+attempting to get the secret keys from him by force.\n+\n+However with CHECKLOCKTIMEVERIFY the funds can be stored in scriptPubKeys of\n+the form:\n+\n+    IF\n+        <now + 3 months> CHECKLOCKTIMEVERIFY DROP\n+        <Lenny's pubkey> CHECKSIGVERIFY\n+        1\n+    ELSE\n+        2\n+    ENDIF\n+    <Alice's pubkey> <Bob's pubkey> 2 CHECKMULTISIG\n+\n+At any time the funds can be spent with the following scriptSig:\n+\n+    <Alice's signature> <Bob's signature> 0\n+\n+After 3 months have passed Lenny and one of either Alice or Bob can spend the\n+funds with the following scriptSig:\n+\n+    <Alice/Bob's signature> <Lenny's signature> 1\n+\n+\n+===Non-interactive time-locked refunds===\n+\n+There exist a number of protocols where a transaction output is created that\n+the co-operation of both parties to spend the output. To ensure the failure of",
      "path": "bip-0065.mediawiki",
      "position": null,
      "original_position": 88,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "759c1f535bd9f0954687455ea09e412d296c3ac3",
      "in_reply_to_id": null,
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks!\n",
      "created_at": "2014-11-10T13:22:54Z",
      "updated_at": "2014-11-10T13:22:54Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20080964",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20080964"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20083559",
      "pull_request_review_id": null,
      "id": 20083559,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDgzNTU5",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.\n+\n+The nLockTime field in a transaction prevents the transaction from being mined\n+until either a certain block height, or block time, has been reached. By\n+comparing the argument to CHECKLOCKTIMEVERIFY against the nLockTime field, we\n+indirectly verify that the desired block height or block time has been reached;\n+until that block height or block time has been reached the transaction output\n+remains unspendable.\n+\n+\n+==Motivation==\n+\n+The nLockTime field in transactions makes it possible to prove that a\n+transaction output can be spent in the future: a valid signature for a\n+transaction with the desired nLockTime can be constructed, proving that it is\n+possible to spend the output with that signature when the nLockTime is reached.\n+An example where this technique is used is in micro-payment channels, where the\n+nLockTime field proves that should the receiver vanish the sender is guaranteed\n+to get all their escrowed funds back when the nLockTime is reached.\n+\n+However the nLockTime field is insufficient if you wish to prove that\n+transaction output ''can-not'' be spent until some time in the future, as there\n+is no way to prove that the secret keys corresponding to the pubkeys controling\n+the funds have not been used to create a valid signature.\n+\n+\n+===Escrow===\n+\n+If Alice and Bob jointly operate a business they may want to\n+ensure that all funds are kept in 2-of-2 multisig transaction outputs that\n+require the co-operation of both parties to spend. However, they recognise that\n+in exceptional circumstances such as either party getting \"hit by a bus\" they\n+need a backup plan to retrieve the funds. So they appoint their lawyer, Lenny,\n+to act as a third-party.\n+\n+With a standard 2-of-3 CHECKMULTISIG at any time Lenny could conspire with\n+either Alice or Bob to steal the funds illegitimately. Equally Lenny may prefer\n+not to have immediate access to the funds to discourage bad actors from\n+attempting to get the secret keys from him by force.\n+\n+However with CHECKLOCKTIMEVERIFY the funds can be stored in scriptPubKeys of\n+the form:\n+\n+    IF\n+        <now + 3 months> CHECKLOCKTIMEVERIFY DROP\n+        <Lenny's pubkey> CHECKSIGVERIFY\n+        1\n+    ELSE\n+        2\n+    ENDIF\n+    <Alice's pubkey> <Bob's pubkey> 2 CHECKMULTISIG\n+\n+At any time the funds can be spent with the following scriptSig:\n+\n+    <Alice's signature> <Bob's signature> 0\n+\n+After 3 months have passed Lenny and one of either Alice or Bob can spend the\n+funds with the following scriptSig:\n+\n+    <Alice/Bob's signature> <Lenny's signature> 1\n+\n+\n+===Non-interactive time-locked refunds===\n+\n+There exist a number of protocols where a transaction output is created that\n+requires the co-operation of both parties to spend the output. To ensure the\n+failure of one party does not result in the funds becoming lost refund\n+transactions are setup in advance using nLockTime. These refund transactions\n+need to be created interactively, and additionaly, are currently vulnerable to\n+transaction mutability. CHECKLOCKTIMEVERIFY can be used in these protocols,\n+replacing the interactive setup with a non-interactive setup, and additionally,\n+making transaction mutability a non-issue.\n+\n+\n+====Two-factor wallets====\n+\n+Services like GreenAddress store Bitcoins with 2-of-2 multisig scriptPubKey's\n+such that one keypair is controlled by the user, and the other keypair is\n+controlled by the service. To spend funds the user uses locally installed\n+wallet software that generates one of the required signatures, and then uses a\n+2nd-factor authentication method to authorize the service to create the second\n+SIGHASH_NONE signature that is locked until some time in the future and sends\n+the user that signature for storage. If the user needs to spend their funds and\n+the service is not available, they wait until the nLockTime expires.\n+\n+The problem is there exist numerous occasions the user will not have a valid\n+signature for some or all of their transaction outputs. With\n+CHECKLOCKTIMEVERIFY rather than creating refund signatures on demand\n+scriptPubKeys of the following form are used instead:\n+\n+    IF\n+        <service pubkey> CHECKSIGVERIFY\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+    ENDIF\n+    <user pubkey> CHECKSIG\n+\n+Now the user is always able to spend their funds without the co-operation of\n+the service by waiting for the expiry time to be reached.\n+\n+\n+====Micropayment Channels====\n+\n+Jeremy Spilman style micropayment channels first setup a deposit controlled by\n+2-of-2 multisig, tx1, and then adjust a second transaction, tx2, that spends\n+the output of tx1 to payor and payee. Prior to publishing tx1 a refund\n+transaction is created, tx3, to ensure that should the payee vanish the payor\n+can get their deposit back. The process by which the refund transaction is\n+created is currently vulnerable to transaction mutability attacks, and\n+additionally, requires the payor to store the refund. Using the same\n+scriptPubKey from as in the Two-factor wallets example solves both these issues.\n+\n+\n+===Trustless Payments for Publishing Data===\n+\n+The PayPub protocol makes it possible to pay for information in a trustless way\n+by first proving that an encrypted file contains the desired data, and secondly\n+crafting scriptPubKeys used for payment such that spending them reveals the\n+encryption keys to the data. However the existing implementation has a\n+significant flaw: the publisher can delay the release of the keys indefinitely.\n+\n+This problem can be solved interactively with the refund transaction technique;\n+with CHECKLOCKTIMEVERIFY the problem can be non-interactively solved using\n+scriptPubKeys of the following form:\n+\n+    IF\n+        HASH160 <Hash160(encryption key)> EQUALVERIFY\n+        <publisher pubkey> CHECKSIG\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+        <buyer pubkey> CHECKSIG\n+    ENDIF\n+\n+The buyer of the data is now making a secure offer with an expiry time. If the\n+publisher fails to accept the offer before the expiry time is reached the buyer\n+can cancel the offer by spending the output.\n+\n+\n+===Proving sacrifice to miners' fees===\n+\n+Proving the sacrifice of some limited resource is a common technique in a\n+variety of cryptographic protocols. Proving sacrifices of coins to mining fees\n+has been proposed as a ''universal public good'' to which the sacrifice could\n+be directed, rather than simply destroying the coins. However doing so is\n+non-trivial, and even the best existing technqiue - announce-commit sacrifices\n+- could encourage mining centralization. CHECKLOCKTIMEVERIFY can be used to\n+create outputs that are provably spendable by anyone (thus to mining fees\n+assuming miners behave optimally and rationally) but only at a time\n+sufficiently far into the future that large miners profitably can't sell the\n+sacrifices at a discount.",
      "path": "bip-0065.mediawiki",
      "position": 172,
      "original_position": 172,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Specific example on how to ensure the transaction is mined prior to its output's lock time?\n",
      "created_at": "2014-11-10T14:18:51Z",
      "updated_at": "2014-11-10T14:19:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20083559",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20083559"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 172,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20083934",
      "pull_request_review_id": null,
      "id": 20083934,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDgzOTM0",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.\n+\n+The nLockTime field in a transaction prevents the transaction from being mined\n+until either a certain block height, or block time, has been reached. By\n+comparing the argument to CHECKLOCKTIMEVERIFY against the nLockTime field, we\n+indirectly verify that the desired block height or block time has been reached;\n+until that block height or block time has been reached the transaction output\n+remains unspendable.\n+\n+\n+==Motivation==\n+\n+The nLockTime field in transactions makes it possible to prove that a\n+transaction output can be spent in the future: a valid signature for a\n+transaction with the desired nLockTime can be constructed, proving that it is\n+possible to spend the output with that signature when the nLockTime is reached.\n+An example where this technique is used is in micro-payment channels, where the\n+nLockTime field proves that should the receiver vanish the sender is guaranteed\n+to get all their escrowed funds back when the nLockTime is reached.\n+\n+However the nLockTime field is insufficient if you wish to prove that\n+transaction output ''can-not'' be spent until some time in the future, as there\n+is no way to prove that the secret keys corresponding to the pubkeys controling\n+the funds have not been used to create a valid signature.\n+\n+\n+===Escrow===\n+\n+If Alice and Bob jointly operate a business they may want to\n+ensure that all funds are kept in 2-of-2 multisig transaction outputs that\n+require the co-operation of both parties to spend. However, they recognise that\n+in exceptional circumstances such as either party getting \"hit by a bus\" they\n+need a backup plan to retrieve the funds. So they appoint their lawyer, Lenny,\n+to act as a third-party.\n+\n+With a standard 2-of-3 CHECKMULTISIG at any time Lenny could conspire with\n+either Alice or Bob to steal the funds illegitimately. Equally Lenny may prefer\n+not to have immediate access to the funds to discourage bad actors from\n+attempting to get the secret keys from him by force.\n+\n+However with CHECKLOCKTIMEVERIFY the funds can be stored in scriptPubKeys of\n+the form:\n+\n+    IF\n+        <now + 3 months> CHECKLOCKTIMEVERIFY DROP\n+        <Lenny's pubkey> CHECKSIGVERIFY\n+        1\n+    ELSE\n+        2\n+    ENDIF\n+    <Alice's pubkey> <Bob's pubkey> 2 CHECKMULTISIG\n+\n+At any time the funds can be spent with the following scriptSig:\n+\n+    <Alice's signature> <Bob's signature> 0\n+\n+After 3 months have passed Lenny and one of either Alice or Bob can spend the\n+funds with the following scriptSig:\n+\n+    <Alice/Bob's signature> <Lenny's signature> 1\n+\n+\n+===Non-interactive time-locked refunds===\n+\n+There exist a number of protocols where a transaction output is created that\n+requires the co-operation of both parties to spend the output. To ensure the\n+failure of one party does not result in the funds becoming lost refund\n+transactions are setup in advance using nLockTime. These refund transactions\n+need to be created interactively, and additionaly, are currently vulnerable to\n+transaction mutability. CHECKLOCKTIMEVERIFY can be used in these protocols,\n+replacing the interactive setup with a non-interactive setup, and additionally,\n+making transaction mutability a non-issue.\n+\n+\n+====Two-factor wallets====\n+\n+Services like GreenAddress store Bitcoins with 2-of-2 multisig scriptPubKey's\n+such that one keypair is controlled by the user, and the other keypair is\n+controlled by the service. To spend funds the user uses locally installed\n+wallet software that generates one of the required signatures, and then uses a\n+2nd-factor authentication method to authorize the service to create the second\n+SIGHASH_NONE signature that is locked until some time in the future and sends\n+the user that signature for storage. If the user needs to spend their funds and\n+the service is not available, they wait until the nLockTime expires.\n+\n+The problem is there exist numerous occasions the user will not have a valid\n+signature for some or all of their transaction outputs. With\n+CHECKLOCKTIMEVERIFY rather than creating refund signatures on demand\n+scriptPubKeys of the following form are used instead:\n+\n+    IF\n+        <service pubkey> CHECKSIGVERIFY\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+    ENDIF\n+    <user pubkey> CHECKSIG\n+\n+Now the user is always able to spend their funds without the co-operation of\n+the service by waiting for the expiry time to be reached.\n+\n+\n+====Micropayment Channels====\n+\n+Jeremy Spilman style micropayment channels first setup a deposit controlled by\n+2-of-2 multisig, tx1, and then adjust a second transaction, tx2, that spends\n+the output of tx1 to payor and payee. Prior to publishing tx1 a refund\n+transaction is created, tx3, to ensure that should the payee vanish the payor\n+can get their deposit back. The process by which the refund transaction is\n+created is currently vulnerable to transaction mutability attacks, and\n+additionally, requires the payor to store the refund. Using the same\n+scriptPubKey from as in the Two-factor wallets example solves both these issues.\n+\n+\n+===Trustless Payments for Publishing Data===\n+\n+The PayPub protocol makes it possible to pay for information in a trustless way\n+by first proving that an encrypted file contains the desired data, and secondly\n+crafting scriptPubKeys used for payment such that spending them reveals the\n+encryption keys to the data. However the existing implementation has a\n+significant flaw: the publisher can delay the release of the keys indefinitely.\n+\n+This problem can be solved interactively with the refund transaction technique;\n+with CHECKLOCKTIMEVERIFY the problem can be non-interactively solved using\n+scriptPubKeys of the following form:\n+\n+    IF\n+        HASH160 <Hash160(encryption key)> EQUALVERIFY\n+        <publisher pubkey> CHECKSIG\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+        <buyer pubkey> CHECKSIG\n+    ENDIF\n+\n+The buyer of the data is now making a secure offer with an expiry time. If the\n+publisher fails to accept the offer before the expiry time is reached the buyer\n+can cancel the offer by spending the output.\n+\n+\n+===Proving sacrifice to miners' fees===\n+\n+Proving the sacrifice of some limited resource is a common technique in a\n+variety of cryptographic protocols. Proving sacrifices of coins to mining fees\n+has been proposed as a ''universal public good'' to which the sacrifice could\n+be directed, rather than simply destroying the coins. However doing so is\n+non-trivial, and even the best existing technqiue - announce-commit sacrifices\n+- could encourage mining centralization. CHECKLOCKTIMEVERIFY can be used to\n+create outputs that are provably spendable by anyone (thus to mining fees\n+assuming miners behave optimally and rationally) but only at a time\n+sufficiently far into the future that large miners profitably can't sell the\n+sacrifices at a discount.",
      "path": "bip-0065.mediawiki",
      "position": 172,
      "original_position": 172,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "in_reply_to_id": null,
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Point is, with CHECKLOCKTIMEVERIFY you don't have to prove that as it's a transaction output that can't be spent. All you need to do is prove that txout was created a prior to the lock time.\n",
      "created_at": "2014-11-10T14:26:36Z",
      "updated_at": "2014-11-10T14:26:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20083934",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20083934"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 172,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20084917",
      "pull_request_review_id": null,
      "id": 20084917,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDg0OTE3",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.\n+\n+The nLockTime field in a transaction prevents the transaction from being mined\n+until either a certain block height, or block time, has been reached. By\n+comparing the argument to CHECKLOCKTIMEVERIFY against the nLockTime field, we\n+indirectly verify that the desired block height or block time has been reached;\n+until that block height or block time has been reached the transaction output\n+remains unspendable.\n+\n+\n+==Motivation==\n+\n+The nLockTime field in transactions makes it possible to prove that a\n+transaction output can be spent in the future: a valid signature for a\n+transaction with the desired nLockTime can be constructed, proving that it is\n+possible to spend the output with that signature when the nLockTime is reached.\n+An example where this technique is used is in micro-payment channels, where the\n+nLockTime field proves that should the receiver vanish the sender is guaranteed\n+to get all their escrowed funds back when the nLockTime is reached.\n+\n+However the nLockTime field is insufficient if you wish to prove that\n+transaction output ''can-not'' be spent until some time in the future, as there\n+is no way to prove that the secret keys corresponding to the pubkeys controling\n+the funds have not been used to create a valid signature.\n+\n+\n+===Escrow===\n+\n+If Alice and Bob jointly operate a business they may want to\n+ensure that all funds are kept in 2-of-2 multisig transaction outputs that\n+require the co-operation of both parties to spend. However, they recognise that\n+in exceptional circumstances such as either party getting \"hit by a bus\" they\n+need a backup plan to retrieve the funds. So they appoint their lawyer, Lenny,\n+to act as a third-party.\n+\n+With a standard 2-of-3 CHECKMULTISIG at any time Lenny could conspire with\n+either Alice or Bob to steal the funds illegitimately. Equally Lenny may prefer\n+not to have immediate access to the funds to discourage bad actors from\n+attempting to get the secret keys from him by force.\n+\n+However with CHECKLOCKTIMEVERIFY the funds can be stored in scriptPubKeys of\n+the form:\n+\n+    IF\n+        <now + 3 months> CHECKLOCKTIMEVERIFY DROP\n+        <Lenny's pubkey> CHECKSIGVERIFY\n+        1\n+    ELSE\n+        2\n+    ENDIF\n+    <Alice's pubkey> <Bob's pubkey> 2 CHECKMULTISIG\n+\n+At any time the funds can be spent with the following scriptSig:\n+\n+    <Alice's signature> <Bob's signature> 0\n+\n+After 3 months have passed Lenny and one of either Alice or Bob can spend the\n+funds with the following scriptSig:\n+\n+    <Alice/Bob's signature> <Lenny's signature> 1\n+\n+\n+===Non-interactive time-locked refunds===\n+\n+There exist a number of protocols where a transaction output is created that\n+requires the co-operation of both parties to spend the output. To ensure the\n+failure of one party does not result in the funds becoming lost refund\n+transactions are setup in advance using nLockTime. These refund transactions\n+need to be created interactively, and additionaly, are currently vulnerable to\n+transaction mutability. CHECKLOCKTIMEVERIFY can be used in these protocols,\n+replacing the interactive setup with a non-interactive setup, and additionally,\n+making transaction mutability a non-issue.\n+\n+\n+====Two-factor wallets====\n+\n+Services like GreenAddress store Bitcoins with 2-of-2 multisig scriptPubKey's\n+such that one keypair is controlled by the user, and the other keypair is\n+controlled by the service. To spend funds the user uses locally installed\n+wallet software that generates one of the required signatures, and then uses a\n+2nd-factor authentication method to authorize the service to create the second\n+SIGHASH_NONE signature that is locked until some time in the future and sends\n+the user that signature for storage. If the user needs to spend their funds and\n+the service is not available, they wait until the nLockTime expires.\n+\n+The problem is there exist numerous occasions the user will not have a valid\n+signature for some or all of their transaction outputs. With\n+CHECKLOCKTIMEVERIFY rather than creating refund signatures on demand\n+scriptPubKeys of the following form are used instead:\n+\n+    IF\n+        <service pubkey> CHECKSIGVERIFY\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+    ENDIF\n+    <user pubkey> CHECKSIG\n+\n+Now the user is always able to spend their funds without the co-operation of\n+the service by waiting for the expiry time to be reached.\n+\n+\n+====Micropayment Channels====\n+\n+Jeremy Spilman style micropayment channels first setup a deposit controlled by\n+2-of-2 multisig, tx1, and then adjust a second transaction, tx2, that spends\n+the output of tx1 to payor and payee. Prior to publishing tx1 a refund\n+transaction is created, tx3, to ensure that should the payee vanish the payor\n+can get their deposit back. The process by which the refund transaction is\n+created is currently vulnerable to transaction mutability attacks, and\n+additionally, requires the payor to store the refund. Using the same\n+scriptPubKey from as in the Two-factor wallets example solves both these issues.\n+\n+\n+===Trustless Payments for Publishing Data===\n+\n+The PayPub protocol makes it possible to pay for information in a trustless way\n+by first proving that an encrypted file contains the desired data, and secondly\n+crafting scriptPubKeys used for payment such that spending them reveals the\n+encryption keys to the data. However the existing implementation has a\n+significant flaw: the publisher can delay the release of the keys indefinitely.\n+\n+This problem can be solved interactively with the refund transaction technique;\n+with CHECKLOCKTIMEVERIFY the problem can be non-interactively solved using\n+scriptPubKeys of the following form:\n+\n+    IF\n+        HASH160 <Hash160(encryption key)> EQUALVERIFY\n+        <publisher pubkey> CHECKSIG\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+        <buyer pubkey> CHECKSIG\n+    ENDIF\n+\n+The buyer of the data is now making a secure offer with an expiry time. If the\n+publisher fails to accept the offer before the expiry time is reached the buyer\n+can cancel the offer by spending the output.\n+\n+\n+===Proving sacrifice to miners' fees===\n+\n+Proving the sacrifice of some limited resource is a common technique in a\n+variety of cryptographic protocols. Proving sacrifices of coins to mining fees\n+has been proposed as a ''universal public good'' to which the sacrifice could\n+be directed, rather than simply destroying the coins. However doing so is\n+non-trivial, and even the best existing technqiue - announce-commit sacrifices\n+- could encourage mining centralization. CHECKLOCKTIMEVERIFY can be used to\n+create outputs that are provably spendable by anyone (thus to mining fees\n+assuming miners behave optimally and rationally) but only at a time\n+sufficiently far into the future that large miners profitably can't sell the\n+sacrifices at a discount.",
      "path": "bip-0065.mediawiki",
      "position": 172,
      "original_position": 172,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Created _and mined_ prior to the lock time. Nothing stops someone from holding on to a proof-of-sacrifice until they find the later-block themselves, and nothing guarantees the fair person's transaction will be mined until that point either...\n",
      "created_at": "2014-11-10T14:42:35Z",
      "updated_at": "2014-11-10T14:42:35Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20084917",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20084917"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 172,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20085058",
      "pull_request_review_id": null,
      "id": 20085058,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDg1MDU4",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.\n+\n+The nLockTime field in a transaction prevents the transaction from being mined\n+until either a certain block height, or block time, has been reached. By\n+comparing the argument to CHECKLOCKTIMEVERIFY against the nLockTime field, we\n+indirectly verify that the desired block height or block time has been reached;\n+until that block height or block time has been reached the transaction output\n+remains unspendable.\n+\n+\n+==Motivation==\n+\n+The nLockTime field in transactions makes it possible to prove that a\n+transaction output can be spent in the future: a valid signature for a\n+transaction with the desired nLockTime can be constructed, proving that it is\n+possible to spend the output with that signature when the nLockTime is reached.\n+An example where this technique is used is in micro-payment channels, where the\n+nLockTime field proves that should the receiver vanish the sender is guaranteed\n+to get all their escrowed funds back when the nLockTime is reached.\n+\n+However the nLockTime field is insufficient if you wish to prove that\n+transaction output ''can-not'' be spent until some time in the future, as there\n+is no way to prove that the secret keys corresponding to the pubkeys controling\n+the funds have not been used to create a valid signature.\n+\n+\n+===Escrow===\n+\n+If Alice and Bob jointly operate a business they may want to\n+ensure that all funds are kept in 2-of-2 multisig transaction outputs that\n+require the co-operation of both parties to spend. However, they recognise that\n+in exceptional circumstances such as either party getting \"hit by a bus\" they\n+need a backup plan to retrieve the funds. So they appoint their lawyer, Lenny,\n+to act as a third-party.\n+\n+With a standard 2-of-3 CHECKMULTISIG at any time Lenny could conspire with\n+either Alice or Bob to steal the funds illegitimately. Equally Lenny may prefer\n+not to have immediate access to the funds to discourage bad actors from\n+attempting to get the secret keys from him by force.\n+\n+However with CHECKLOCKTIMEVERIFY the funds can be stored in scriptPubKeys of\n+the form:\n+\n+    IF\n+        <now + 3 months> CHECKLOCKTIMEVERIFY DROP\n+        <Lenny's pubkey> CHECKSIGVERIFY\n+        1\n+    ELSE\n+        2\n+    ENDIF\n+    <Alice's pubkey> <Bob's pubkey> 2 CHECKMULTISIG\n+\n+At any time the funds can be spent with the following scriptSig:\n+\n+    <Alice's signature> <Bob's signature> 0\n+\n+After 3 months have passed Lenny and one of either Alice or Bob can spend the\n+funds with the following scriptSig:\n+\n+    <Alice/Bob's signature> <Lenny's signature> 1\n+\n+\n+===Non-interactive time-locked refunds===\n+\n+There exist a number of protocols where a transaction output is created that\n+requires the co-operation of both parties to spend the output. To ensure the\n+failure of one party does not result in the funds becoming lost refund\n+transactions are setup in advance using nLockTime. These refund transactions\n+need to be created interactively, and additionaly, are currently vulnerable to\n+transaction mutability. CHECKLOCKTIMEVERIFY can be used in these protocols,\n+replacing the interactive setup with a non-interactive setup, and additionally,\n+making transaction mutability a non-issue.\n+\n+\n+====Two-factor wallets====\n+\n+Services like GreenAddress store Bitcoins with 2-of-2 multisig scriptPubKey's\n+such that one keypair is controlled by the user, and the other keypair is\n+controlled by the service. To spend funds the user uses locally installed\n+wallet software that generates one of the required signatures, and then uses a\n+2nd-factor authentication method to authorize the service to create the second\n+SIGHASH_NONE signature that is locked until some time in the future and sends\n+the user that signature for storage. If the user needs to spend their funds and\n+the service is not available, they wait until the nLockTime expires.\n+\n+The problem is there exist numerous occasions the user will not have a valid\n+signature for some or all of their transaction outputs. With\n+CHECKLOCKTIMEVERIFY rather than creating refund signatures on demand\n+scriptPubKeys of the following form are used instead:\n+\n+    IF\n+        <service pubkey> CHECKSIGVERIFY\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+    ENDIF\n+    <user pubkey> CHECKSIG\n+\n+Now the user is always able to spend their funds without the co-operation of\n+the service by waiting for the expiry time to be reached.\n+\n+\n+====Micropayment Channels====\n+\n+Jeremy Spilman style micropayment channels first setup a deposit controlled by\n+2-of-2 multisig, tx1, and then adjust a second transaction, tx2, that spends\n+the output of tx1 to payor and payee. Prior to publishing tx1 a refund\n+transaction is created, tx3, to ensure that should the payee vanish the payor\n+can get their deposit back. The process by which the refund transaction is\n+created is currently vulnerable to transaction mutability attacks, and\n+additionally, requires the payor to store the refund. Using the same\n+scriptPubKey from as in the Two-factor wallets example solves both these issues.\n+\n+\n+===Trustless Payments for Publishing Data===\n+\n+The PayPub protocol makes it possible to pay for information in a trustless way\n+by first proving that an encrypted file contains the desired data, and secondly\n+crafting scriptPubKeys used for payment such that spending them reveals the\n+encryption keys to the data. However the existing implementation has a\n+significant flaw: the publisher can delay the release of the keys indefinitely.\n+\n+This problem can be solved interactively with the refund transaction technique;\n+with CHECKLOCKTIMEVERIFY the problem can be non-interactively solved using\n+scriptPubKeys of the following form:\n+\n+    IF\n+        HASH160 <Hash160(encryption key)> EQUALVERIFY\n+        <publisher pubkey> CHECKSIG\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+        <buyer pubkey> CHECKSIG\n+    ENDIF\n+\n+The buyer of the data is now making a secure offer with an expiry time. If the\n+publisher fails to accept the offer before the expiry time is reached the buyer\n+can cancel the offer by spending the output.\n+\n+\n+===Proving sacrifice to miners' fees===\n+\n+Proving the sacrifice of some limited resource is a common technique in a\n+variety of cryptographic protocols. Proving sacrifices of coins to mining fees\n+has been proposed as a ''universal public good'' to which the sacrifice could\n+be directed, rather than simply destroying the coins. However doing so is\n+non-trivial, and even the best existing technqiue - announce-commit sacrifices\n+- could encourage mining centralization. CHECKLOCKTIMEVERIFY can be used to\n+create outputs that are provably spendable by anyone (thus to mining fees\n+assuming miners behave optimally and rationally) but only at a time\n+sufficiently far into the future that large miners profitably can't sell the\n+sacrifices at a discount.",
      "path": "bip-0065.mediawiki",
      "position": 172,
      "original_position": 172,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "in_reply_to_id": null,
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think making that distinction is rather pedantic; in the context of the paragraph it should be obvious to anyone who might need proof-of-sacrifice that when we say an output is 'created' we mean the transaction has been mined.\n",
      "created_at": "2014-11-10T14:45:02Z",
      "updated_at": "2014-11-10T14:45:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20085058",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20085058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 172,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20085200",
      "pull_request_review_id": null,
      "id": 20085200,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDg1MjAw",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.\n+\n+The nLockTime field in a transaction prevents the transaction from being mined\n+until either a certain block height, or block time, has been reached. By\n+comparing the argument to CHECKLOCKTIMEVERIFY against the nLockTime field, we\n+indirectly verify that the desired block height or block time has been reached;\n+until that block height or block time has been reached the transaction output\n+remains unspendable.\n+\n+\n+==Motivation==\n+\n+The nLockTime field in transactions makes it possible to prove that a\n+transaction output can be spent in the future: a valid signature for a\n+transaction with the desired nLockTime can be constructed, proving that it is\n+possible to spend the output with that signature when the nLockTime is reached.\n+An example where this technique is used is in micro-payment channels, where the\n+nLockTime field proves that should the receiver vanish the sender is guaranteed\n+to get all their escrowed funds back when the nLockTime is reached.\n+\n+However the nLockTime field is insufficient if you wish to prove that\n+transaction output ''can-not'' be spent until some time in the future, as there\n+is no way to prove that the secret keys corresponding to the pubkeys controling\n+the funds have not been used to create a valid signature.\n+\n+\n+===Escrow===\n+\n+If Alice and Bob jointly operate a business they may want to\n+ensure that all funds are kept in 2-of-2 multisig transaction outputs that\n+require the co-operation of both parties to spend. However, they recognise that\n+in exceptional circumstances such as either party getting \"hit by a bus\" they\n+need a backup plan to retrieve the funds. So they appoint their lawyer, Lenny,\n+to act as a third-party.\n+\n+With a standard 2-of-3 CHECKMULTISIG at any time Lenny could conspire with\n+either Alice or Bob to steal the funds illegitimately. Equally Lenny may prefer\n+not to have immediate access to the funds to discourage bad actors from\n+attempting to get the secret keys from him by force.\n+\n+However with CHECKLOCKTIMEVERIFY the funds can be stored in scriptPubKeys of\n+the form:\n+\n+    IF\n+        <now + 3 months> CHECKLOCKTIMEVERIFY DROP\n+        <Lenny's pubkey> CHECKSIGVERIFY\n+        1\n+    ELSE\n+        2\n+    ENDIF\n+    <Alice's pubkey> <Bob's pubkey> 2 CHECKMULTISIG\n+\n+At any time the funds can be spent with the following scriptSig:\n+\n+    <Alice's signature> <Bob's signature> 0\n+\n+After 3 months have passed Lenny and one of either Alice or Bob can spend the\n+funds with the following scriptSig:\n+\n+    <Alice/Bob's signature> <Lenny's signature> 1\n+\n+\n+===Non-interactive time-locked refunds===\n+\n+There exist a number of protocols where a transaction output is created that\n+requires the co-operation of both parties to spend the output. To ensure the\n+failure of one party does not result in the funds becoming lost refund\n+transactions are setup in advance using nLockTime. These refund transactions\n+need to be created interactively, and additionaly, are currently vulnerable to\n+transaction mutability. CHECKLOCKTIMEVERIFY can be used in these protocols,\n+replacing the interactive setup with a non-interactive setup, and additionally,\n+making transaction mutability a non-issue.\n+\n+\n+====Two-factor wallets====\n+\n+Services like GreenAddress store Bitcoins with 2-of-2 multisig scriptPubKey's\n+such that one keypair is controlled by the user, and the other keypair is\n+controlled by the service. To spend funds the user uses locally installed\n+wallet software that generates one of the required signatures, and then uses a\n+2nd-factor authentication method to authorize the service to create the second\n+SIGHASH_NONE signature that is locked until some time in the future and sends\n+the user that signature for storage. If the user needs to spend their funds and\n+the service is not available, they wait until the nLockTime expires.\n+\n+The problem is there exist numerous occasions the user will not have a valid\n+signature for some or all of their transaction outputs. With\n+CHECKLOCKTIMEVERIFY rather than creating refund signatures on demand\n+scriptPubKeys of the following form are used instead:\n+\n+    IF\n+        <service pubkey> CHECKSIGVERIFY\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+    ENDIF\n+    <user pubkey> CHECKSIG\n+\n+Now the user is always able to spend their funds without the co-operation of\n+the service by waiting for the expiry time to be reached.\n+\n+\n+====Micropayment Channels====\n+\n+Jeremy Spilman style micropayment channels first setup a deposit controlled by\n+2-of-2 multisig, tx1, and then adjust a second transaction, tx2, that spends\n+the output of tx1 to payor and payee. Prior to publishing tx1 a refund\n+transaction is created, tx3, to ensure that should the payee vanish the payor\n+can get their deposit back. The process by which the refund transaction is\n+created is currently vulnerable to transaction mutability attacks, and\n+additionally, requires the payor to store the refund. Using the same\n+scriptPubKey from as in the Two-factor wallets example solves both these issues.\n+\n+\n+===Trustless Payments for Publishing Data===\n+\n+The PayPub protocol makes it possible to pay for information in a trustless way\n+by first proving that an encrypted file contains the desired data, and secondly\n+crafting scriptPubKeys used for payment such that spending them reveals the\n+encryption keys to the data. However the existing implementation has a\n+significant flaw: the publisher can delay the release of the keys indefinitely.\n+\n+This problem can be solved interactively with the refund transaction technique;\n+with CHECKLOCKTIMEVERIFY the problem can be non-interactively solved using\n+scriptPubKeys of the following form:\n+\n+    IF\n+        HASH160 <Hash160(encryption key)> EQUALVERIFY\n+        <publisher pubkey> CHECKSIG\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+        <buyer pubkey> CHECKSIG\n+    ENDIF\n+\n+The buyer of the data is now making a secure offer with an expiry time. If the\n+publisher fails to accept the offer before the expiry time is reached the buyer\n+can cancel the offer by spending the output.\n+\n+\n+===Proving sacrifice to miners' fees===\n+\n+Proving the sacrifice of some limited resource is a common technique in a\n+variety of cryptographic protocols. Proving sacrifices of coins to mining fees\n+has been proposed as a ''universal public good'' to which the sacrifice could\n+be directed, rather than simply destroying the coins. However doing so is\n+non-trivial, and even the best existing technqiue - announce-commit sacrifices\n+- could encourage mining centralization. CHECKLOCKTIMEVERIFY can be used to\n+create outputs that are provably spendable by anyone (thus to mining fees\n+assuming miners behave optimally and rationally) but only at a time\n+sufficiently far into the future that large miners profitably can't sell the\n+sacrifices at a discount.",
      "path": "bip-0065.mediawiki",
      "position": 172,
      "original_position": 172,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Anyhow, this use case is not supported by the current draft as far as I can see. If it is, an example would be helpful.\n",
      "created_at": "2014-11-10T14:47:03Z",
      "updated_at": "2014-11-10T14:47:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20085200",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20085200"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 172,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20085325",
      "pull_request_review_id": null,
      "id": 20085325,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDg1MzI1",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.",
      "path": "bip-0065.mediawiki",
      "position": 23,
      "original_position": 23,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This fails to distinguish between block-height and timestamp locktimes. Admittedly, this is just a summary, so maybe full details aren't needed here - but I don't see a proper Specification section in this BIP either.\n",
      "created_at": "2014-11-10T14:49:02Z",
      "updated_at": "2014-11-10T14:49:02Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20085325",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20085325"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 23,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20085506",
      "pull_request_review_id": null,
      "id": 20085506,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDg1NTA2",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.\n+\n+The nLockTime field in a transaction prevents the transaction from being mined\n+until either a certain block height, or block time, has been reached. By\n+comparing the argument to CHECKLOCKTIMEVERIFY against the nLockTime field, we\n+indirectly verify that the desired block height or block time has been reached;\n+until that block height or block time has been reached the transaction output\n+remains unspendable.\n+\n+\n+==Motivation==\n+\n+The nLockTime field in transactions makes it possible to prove that a\n+transaction output can be spent in the future: a valid signature for a\n+transaction with the desired nLockTime can be constructed, proving that it is\n+possible to spend the output with that signature when the nLockTime is reached.\n+An example where this technique is used is in micro-payment channels, where the\n+nLockTime field proves that should the receiver vanish the sender is guaranteed\n+to get all their escrowed funds back when the nLockTime is reached.\n+\n+However the nLockTime field is insufficient if you wish to prove that\n+transaction output ''can-not'' be spent until some time in the future, as there\n+is no way to prove that the secret keys corresponding to the pubkeys controling\n+the funds have not been used to create a valid signature.\n+\n+\n+===Escrow===\n+\n+If Alice and Bob jointly operate a business they may want to\n+ensure that all funds are kept in 2-of-2 multisig transaction outputs that\n+require the co-operation of both parties to spend. However, they recognise that\n+in exceptional circumstances such as either party getting \"hit by a bus\" they\n+need a backup plan to retrieve the funds. So they appoint their lawyer, Lenny,\n+to act as a third-party.\n+\n+With a standard 2-of-3 CHECKMULTISIG at any time Lenny could conspire with\n+either Alice or Bob to steal the funds illegitimately. Equally Lenny may prefer\n+not to have immediate access to the funds to discourage bad actors from\n+attempting to get the secret keys from him by force.\n+\n+However with CHECKLOCKTIMEVERIFY the funds can be stored in scriptPubKeys of\n+the form:\n+\n+    IF\n+        <now + 3 months> CHECKLOCKTIMEVERIFY DROP\n+        <Lenny's pubkey> CHECKSIGVERIFY\n+        1\n+    ELSE\n+        2\n+    ENDIF\n+    <Alice's pubkey> <Bob's pubkey> 2 CHECKMULTISIG\n+\n+At any time the funds can be spent with the following scriptSig:\n+\n+    <Alice's signature> <Bob's signature> 0\n+\n+After 3 months have passed Lenny and one of either Alice or Bob can spend the\n+funds with the following scriptSig:\n+\n+    <Alice/Bob's signature> <Lenny's signature> 1\n+\n+\n+===Non-interactive time-locked refunds===\n+\n+There exist a number of protocols where a transaction output is created that\n+requires the co-operation of both parties to spend the output. To ensure the\n+failure of one party does not result in the funds becoming lost refund\n+transactions are setup in advance using nLockTime. These refund transactions\n+need to be created interactively, and additionaly, are currently vulnerable to\n+transaction mutability. CHECKLOCKTIMEVERIFY can be used in these protocols,\n+replacing the interactive setup with a non-interactive setup, and additionally,\n+making transaction mutability a non-issue.\n+\n+\n+====Two-factor wallets====\n+\n+Services like GreenAddress store Bitcoins with 2-of-2 multisig scriptPubKey's\n+such that one keypair is controlled by the user, and the other keypair is\n+controlled by the service. To spend funds the user uses locally installed\n+wallet software that generates one of the required signatures, and then uses a\n+2nd-factor authentication method to authorize the service to create the second\n+SIGHASH_NONE signature that is locked until some time in the future and sends\n+the user that signature for storage. If the user needs to spend their funds and\n+the service is not available, they wait until the nLockTime expires.\n+\n+The problem is there exist numerous occasions the user will not have a valid\n+signature for some or all of their transaction outputs. With\n+CHECKLOCKTIMEVERIFY rather than creating refund signatures on demand\n+scriptPubKeys of the following form are used instead:\n+\n+    IF\n+        <service pubkey> CHECKSIGVERIFY\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+    ENDIF\n+    <user pubkey> CHECKSIG\n+\n+Now the user is always able to spend their funds without the co-operation of\n+the service by waiting for the expiry time to be reached.\n+\n+\n+====Micropayment Channels====\n+\n+Jeremy Spilman style micropayment channels first setup a deposit controlled by\n+2-of-2 multisig, tx1, and then adjust a second transaction, tx2, that spends\n+the output of tx1 to payor and payee. Prior to publishing tx1 a refund\n+transaction is created, tx3, to ensure that should the payee vanish the payor\n+can get their deposit back. The process by which the refund transaction is\n+created is currently vulnerable to transaction mutability attacks, and\n+additionally, requires the payor to store the refund. Using the same\n+scriptPubKey from as in the Two-factor wallets example solves both these issues.\n+\n+\n+===Trustless Payments for Publishing Data===\n+\n+The PayPub protocol makes it possible to pay for information in a trustless way\n+by first proving that an encrypted file contains the desired data, and secondly\n+crafting scriptPubKeys used for payment such that spending them reveals the\n+encryption keys to the data. However the existing implementation has a\n+significant flaw: the publisher can delay the release of the keys indefinitely.\n+\n+This problem can be solved interactively with the refund transaction technique;\n+with CHECKLOCKTIMEVERIFY the problem can be non-interactively solved using\n+scriptPubKeys of the following form:\n+\n+    IF\n+        HASH160 <Hash160(encryption key)> EQUALVERIFY\n+        <publisher pubkey> CHECKSIG\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+        <buyer pubkey> CHECKSIG\n+    ENDIF\n+\n+The buyer of the data is now making a secure offer with an expiry time. If the\n+publisher fails to accept the offer before the expiry time is reached the buyer\n+can cancel the offer by spending the output.\n+\n+\n+===Proving sacrifice to miners' fees===\n+\n+Proving the sacrifice of some limited resource is a common technique in a\n+variety of cryptographic protocols. Proving sacrifices of coins to mining fees\n+has been proposed as a ''universal public good'' to which the sacrifice could\n+be directed, rather than simply destroying the coins. However doing so is\n+non-trivial, and even the best existing technqiue - announce-commit sacrifices\n+- could encourage mining centralization. CHECKLOCKTIMEVERIFY can be used to\n+create outputs that are provably spendable by anyone (thus to mining fees\n+assuming miners behave optimally and rationally) but only at a time\n+sufficiently far into the future that large miners profitably can't sell the\n+sacrifices at a discount.",
      "path": "bip-0065.mediawiki",
      "position": 172,
      "original_position": 172,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "in_reply_to_id": null,
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What would you expect to see in the BIP for that usecase to be \"supported\"?\n",
      "created_at": "2014-11-10T14:52:22Z",
      "updated_at": "2014-11-10T14:52:22Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20085506",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20085506"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 172,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20085553",
      "pull_request_review_id": null,
      "id": 20085553,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDg1NTUz",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.",
      "path": "bip-0065.mediawiki",
      "position": 23,
      "original_position": 23,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "in_reply_to_id": null,
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The proper specification is the reference implementation, a very delibrate choice.\n",
      "created_at": "2014-11-10T14:53:01Z",
      "updated_at": "2014-11-10T14:53:01Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20085553",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20085553"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 23,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20085771",
      "pull_request_review_id": null,
      "id": 20085771,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDg1Nzcx",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.\n+\n+The nLockTime field in a transaction prevents the transaction from being mined\n+until either a certain block height, or block time, has been reached. By\n+comparing the argument to CHECKLOCKTIMEVERIFY against the nLockTime field, we\n+indirectly verify that the desired block height or block time has been reached;\n+until that block height or block time has been reached the transaction output\n+remains unspendable.\n+\n+\n+==Motivation==\n+\n+The nLockTime field in transactions makes it possible to prove that a\n+transaction output can be spent in the future: a valid signature for a\n+transaction with the desired nLockTime can be constructed, proving that it is\n+possible to spend the output with that signature when the nLockTime is reached.\n+An example where this technique is used is in micro-payment channels, where the\n+nLockTime field proves that should the receiver vanish the sender is guaranteed\n+to get all their escrowed funds back when the nLockTime is reached.\n+\n+However the nLockTime field is insufficient if you wish to prove that\n+transaction output ''can-not'' be spent until some time in the future, as there\n+is no way to prove that the secret keys corresponding to the pubkeys controling\n+the funds have not been used to create a valid signature.\n+\n+\n+===Escrow===\n+\n+If Alice and Bob jointly operate a business they may want to\n+ensure that all funds are kept in 2-of-2 multisig transaction outputs that\n+require the co-operation of both parties to spend. However, they recognise that\n+in exceptional circumstances such as either party getting \"hit by a bus\" they\n+need a backup plan to retrieve the funds. So they appoint their lawyer, Lenny,\n+to act as a third-party.\n+\n+With a standard 2-of-3 CHECKMULTISIG at any time Lenny could conspire with\n+either Alice or Bob to steal the funds illegitimately. Equally Lenny may prefer\n+not to have immediate access to the funds to discourage bad actors from\n+attempting to get the secret keys from him by force.\n+\n+However with CHECKLOCKTIMEVERIFY the funds can be stored in scriptPubKeys of\n+the form:\n+\n+    IF\n+        <now + 3 months> CHECKLOCKTIMEVERIFY DROP\n+        <Lenny's pubkey> CHECKSIGVERIFY\n+        1\n+    ELSE\n+        2\n+    ENDIF\n+    <Alice's pubkey> <Bob's pubkey> 2 CHECKMULTISIG\n+\n+At any time the funds can be spent with the following scriptSig:\n+\n+    <Alice's signature> <Bob's signature> 0\n+\n+After 3 months have passed Lenny and one of either Alice or Bob can spend the\n+funds with the following scriptSig:\n+\n+    <Alice/Bob's signature> <Lenny's signature> 1\n+\n+\n+===Non-interactive time-locked refunds===\n+\n+There exist a number of protocols where a transaction output is created that\n+requires the co-operation of both parties to spend the output. To ensure the\n+failure of one party does not result in the funds becoming lost refund\n+transactions are setup in advance using nLockTime. These refund transactions\n+need to be created interactively, and additionaly, are currently vulnerable to\n+transaction mutability. CHECKLOCKTIMEVERIFY can be used in these protocols,\n+replacing the interactive setup with a non-interactive setup, and additionally,\n+making transaction mutability a non-issue.\n+\n+\n+====Two-factor wallets====\n+\n+Services like GreenAddress store Bitcoins with 2-of-2 multisig scriptPubKey's\n+such that one keypair is controlled by the user, and the other keypair is\n+controlled by the service. To spend funds the user uses locally installed\n+wallet software that generates one of the required signatures, and then uses a\n+2nd-factor authentication method to authorize the service to create the second\n+SIGHASH_NONE signature that is locked until some time in the future and sends\n+the user that signature for storage. If the user needs to spend their funds and\n+the service is not available, they wait until the nLockTime expires.\n+\n+The problem is there exist numerous occasions the user will not have a valid\n+signature for some or all of their transaction outputs. With\n+CHECKLOCKTIMEVERIFY rather than creating refund signatures on demand\n+scriptPubKeys of the following form are used instead:\n+\n+    IF\n+        <service pubkey> CHECKSIGVERIFY\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+    ENDIF\n+    <user pubkey> CHECKSIG\n+\n+Now the user is always able to spend their funds without the co-operation of\n+the service by waiting for the expiry time to be reached.\n+\n+\n+====Micropayment Channels====\n+\n+Jeremy Spilman style micropayment channels first setup a deposit controlled by\n+2-of-2 multisig, tx1, and then adjust a second transaction, tx2, that spends\n+the output of tx1 to payor and payee. Prior to publishing tx1 a refund\n+transaction is created, tx3, to ensure that should the payee vanish the payor\n+can get their deposit back. The process by which the refund transaction is\n+created is currently vulnerable to transaction mutability attacks, and\n+additionally, requires the payor to store the refund. Using the same\n+scriptPubKey from as in the Two-factor wallets example solves both these issues.\n+\n+\n+===Trustless Payments for Publishing Data===\n+\n+The PayPub protocol makes it possible to pay for information in a trustless way\n+by first proving that an encrypted file contains the desired data, and secondly\n+crafting scriptPubKeys used for payment such that spending them reveals the\n+encryption keys to the data. However the existing implementation has a\n+significant flaw: the publisher can delay the release of the keys indefinitely.\n+\n+This problem can be solved interactively with the refund transaction technique;\n+with CHECKLOCKTIMEVERIFY the problem can be non-interactively solved using\n+scriptPubKeys of the following form:\n+\n+    IF\n+        HASH160 <Hash160(encryption key)> EQUALVERIFY\n+        <publisher pubkey> CHECKSIG\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+        <buyer pubkey> CHECKSIG\n+    ENDIF\n+\n+The buyer of the data is now making a secure offer with an expiry time. If the\n+publisher fails to accept the offer before the expiry time is reached the buyer\n+can cancel the offer by spending the output.\n+\n+\n+===Proving sacrifice to miners' fees===\n+\n+Proving the sacrifice of some limited resource is a common technique in a\n+variety of cryptographic protocols. Proving sacrifices of coins to mining fees\n+has been proposed as a ''universal public good'' to which the sacrifice could\n+be directed, rather than simply destroying the coins. However doing so is\n+non-trivial, and even the best existing technqiue - announce-commit sacrifices\n+- could encourage mining centralization. CHECKLOCKTIMEVERIFY can be used to\n+create outputs that are provably spendable by anyone (thus to mining fees\n+assuming miners behave optimally and rationally) but only at a time\n+sufficiently far into the future that large miners profitably can't sell the\n+sacrifices at a discount.",
      "path": "bip-0065.mediawiki",
      "position": 172,
      "original_position": 172,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "A way to convey \"<N blocks | N seconds> after the block height/time this transaction was mined in\"\n",
      "created_at": "2014-11-10T14:56:21Z",
      "updated_at": "2014-11-10T14:56:28Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20085771",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20085771"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 172,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20085838",
      "pull_request_review_id": null,
      "id": 20085838,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDg1ODM4",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.",
      "path": "bip-0065.mediawiki",
      "position": 23,
      "original_position": 23,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The specification should be documented in the BIP.\n",
      "created_at": "2014-11-10T14:57:18Z",
      "updated_at": "2014-11-10T14:57:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20085838",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20085838"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 23,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20086791",
      "pull_request_review_id": null,
      "id": 20086791,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDg2Nzkx",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.\n+\n+The nLockTime field in a transaction prevents the transaction from being mined\n+until either a certain block height, or block time, has been reached. By\n+comparing the argument to CHECKLOCKTIMEVERIFY against the nLockTime field, we\n+indirectly verify that the desired block height or block time has been reached;\n+until that block height or block time has been reached the transaction output\n+remains unspendable.\n+\n+\n+==Motivation==\n+\n+The nLockTime field in transactions makes it possible to prove that a\n+transaction output can be spent in the future: a valid signature for a\n+transaction with the desired nLockTime can be constructed, proving that it is\n+possible to spend the output with that signature when the nLockTime is reached.\n+An example where this technique is used is in micro-payment channels, where the\n+nLockTime field proves that should the receiver vanish the sender is guaranteed\n+to get all their escrowed funds back when the nLockTime is reached.\n+\n+However the nLockTime field is insufficient if you wish to prove that\n+transaction output ''can-not'' be spent until some time in the future, as there\n+is no way to prove that the secret keys corresponding to the pubkeys controling\n+the funds have not been used to create a valid signature.\n+\n+\n+===Escrow===\n+\n+If Alice and Bob jointly operate a business they may want to\n+ensure that all funds are kept in 2-of-2 multisig transaction outputs that\n+require the co-operation of both parties to spend. However, they recognise that\n+in exceptional circumstances such as either party getting \"hit by a bus\" they\n+need a backup plan to retrieve the funds. So they appoint their lawyer, Lenny,\n+to act as a third-party.\n+\n+With a standard 2-of-3 CHECKMULTISIG at any time Lenny could conspire with\n+either Alice or Bob to steal the funds illegitimately. Equally Lenny may prefer\n+not to have immediate access to the funds to discourage bad actors from\n+attempting to get the secret keys from him by force.\n+\n+However with CHECKLOCKTIMEVERIFY the funds can be stored in scriptPubKeys of\n+the form:\n+\n+    IF\n+        <now + 3 months> CHECKLOCKTIMEVERIFY DROP\n+        <Lenny's pubkey> CHECKSIGVERIFY\n+        1\n+    ELSE\n+        2\n+    ENDIF\n+    <Alice's pubkey> <Bob's pubkey> 2 CHECKMULTISIG\n+\n+At any time the funds can be spent with the following scriptSig:\n+\n+    <Alice's signature> <Bob's signature> 0\n+\n+After 3 months have passed Lenny and one of either Alice or Bob can spend the\n+funds with the following scriptSig:\n+\n+    <Alice/Bob's signature> <Lenny's signature> 1\n+\n+\n+===Non-interactive time-locked refunds===\n+\n+There exist a number of protocols where a transaction output is created that\n+requires the co-operation of both parties to spend the output. To ensure the\n+failure of one party does not result in the funds becoming lost refund\n+transactions are setup in advance using nLockTime. These refund transactions\n+need to be created interactively, and additionaly, are currently vulnerable to\n+transaction mutability. CHECKLOCKTIMEVERIFY can be used in these protocols,\n+replacing the interactive setup with a non-interactive setup, and additionally,\n+making transaction mutability a non-issue.\n+\n+\n+====Two-factor wallets====\n+\n+Services like GreenAddress store Bitcoins with 2-of-2 multisig scriptPubKey's\n+such that one keypair is controlled by the user, and the other keypair is\n+controlled by the service. To spend funds the user uses locally installed\n+wallet software that generates one of the required signatures, and then uses a\n+2nd-factor authentication method to authorize the service to create the second\n+SIGHASH_NONE signature that is locked until some time in the future and sends\n+the user that signature for storage. If the user needs to spend their funds and\n+the service is not available, they wait until the nLockTime expires.\n+\n+The problem is there exist numerous occasions the user will not have a valid\n+signature for some or all of their transaction outputs. With\n+CHECKLOCKTIMEVERIFY rather than creating refund signatures on demand\n+scriptPubKeys of the following form are used instead:\n+\n+    IF\n+        <service pubkey> CHECKSIGVERIFY\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+    ENDIF\n+    <user pubkey> CHECKSIG\n+\n+Now the user is always able to spend their funds without the co-operation of\n+the service by waiting for the expiry time to be reached.\n+\n+\n+====Micropayment Channels====\n+\n+Jeremy Spilman style micropayment channels first setup a deposit controlled by\n+2-of-2 multisig, tx1, and then adjust a second transaction, tx2, that spends\n+the output of tx1 to payor and payee. Prior to publishing tx1 a refund\n+transaction is created, tx3, to ensure that should the payee vanish the payor\n+can get their deposit back. The process by which the refund transaction is\n+created is currently vulnerable to transaction mutability attacks, and\n+additionally, requires the payor to store the refund. Using the same\n+scriptPubKey from as in the Two-factor wallets example solves both these issues.\n+\n+\n+===Trustless Payments for Publishing Data===\n+\n+The PayPub protocol makes it possible to pay for information in a trustless way\n+by first proving that an encrypted file contains the desired data, and secondly\n+crafting scriptPubKeys used for payment such that spending them reveals the\n+encryption keys to the data. However the existing implementation has a\n+significant flaw: the publisher can delay the release of the keys indefinitely.\n+\n+This problem can be solved interactively with the refund transaction technique;\n+with CHECKLOCKTIMEVERIFY the problem can be non-interactively solved using\n+scriptPubKeys of the following form:\n+\n+    IF\n+        HASH160 <Hash160(encryption key)> EQUALVERIFY\n+        <publisher pubkey> CHECKSIG\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+        <buyer pubkey> CHECKSIG\n+    ENDIF\n+\n+The buyer of the data is now making a secure offer with an expiry time. If the\n+publisher fails to accept the offer before the expiry time is reached the buyer\n+can cancel the offer by spending the output.\n+\n+\n+===Proving sacrifice to miners' fees===\n+\n+Proving the sacrifice of some limited resource is a common technique in a\n+variety of cryptographic protocols. Proving sacrifices of coins to mining fees\n+has been proposed as a ''universal public good'' to which the sacrifice could\n+be directed, rather than simply destroying the coins. However doing so is\n+non-trivial, and even the best existing technqiue - announce-commit sacrifices\n+- could encourage mining centralization. CHECKLOCKTIMEVERIFY can be used to\n+create outputs that are provably spendable by anyone (thus to mining fees\n+assuming miners behave optimally and rationally) but only at a time\n+sufficiently far into the future that large miners profitably can't sell the\n+sacrifices at a discount.",
      "path": "bip-0065.mediawiki",
      "position": 172,
      "original_position": 172,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "in_reply_to_id": null,
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For proof-of-sacrifice you want the txout to be locked for months if not years to get past miner business cycles. I'm not worried about a transaction being censored when the timeframes are that long.\n\nAnyway, a future BIP can define a CHECK-BLOCKHEIGHT-VERIFY opcode that leaves a block height on the stack, which could be used in conjunction with ADD to do what you want. But that's a heck of a lot of complexity right now for a very niche use-case.\n",
      "created_at": "2014-11-10T15:12:40Z",
      "updated_at": "2014-11-10T15:12:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20086791",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20086791"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 172,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20086868",
      "pull_request_review_id": null,
      "id": 20086868,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDg2ODY4",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.",
      "path": "bip-0065.mediawiki",
      "position": 23,
      "original_position": 23,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "in_reply_to_id": null,
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, and that reference implementation is included in the BIP, both in the form of a few lines of code, as well as a reference by git commit hash to a implementation including all dependencies.\n",
      "created_at": "2014-11-10T15:13:51Z",
      "updated_at": "2014-11-10T15:13:51Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20086868",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20086868"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 23,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20087002",
      "pull_request_review_id": null,
      "id": 20087002,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDg3MDAy",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.\n+\n+The nLockTime field in a transaction prevents the transaction from being mined\n+until either a certain block height, or block time, has been reached. By\n+comparing the argument to CHECKLOCKTIMEVERIFY against the nLockTime field, we\n+indirectly verify that the desired block height or block time has been reached;\n+until that block height or block time has been reached the transaction output\n+remains unspendable.\n+\n+\n+==Motivation==\n+\n+The nLockTime field in transactions makes it possible to prove that a\n+transaction output can be spent in the future: a valid signature for a\n+transaction with the desired nLockTime can be constructed, proving that it is\n+possible to spend the output with that signature when the nLockTime is reached.\n+An example where this technique is used is in micro-payment channels, where the\n+nLockTime field proves that should the receiver vanish the sender is guaranteed\n+to get all their escrowed funds back when the nLockTime is reached.\n+\n+However the nLockTime field is insufficient if you wish to prove that\n+transaction output ''can-not'' be spent until some time in the future, as there\n+is no way to prove that the secret keys corresponding to the pubkeys controling\n+the funds have not been used to create a valid signature.\n+\n+\n+===Escrow===\n+\n+If Alice and Bob jointly operate a business they may want to\n+ensure that all funds are kept in 2-of-2 multisig transaction outputs that\n+require the co-operation of both parties to spend. However, they recognise that\n+in exceptional circumstances such as either party getting \"hit by a bus\" they\n+need a backup plan to retrieve the funds. So they appoint their lawyer, Lenny,\n+to act as a third-party.\n+\n+With a standard 2-of-3 CHECKMULTISIG at any time Lenny could conspire with\n+either Alice or Bob to steal the funds illegitimately. Equally Lenny may prefer\n+not to have immediate access to the funds to discourage bad actors from\n+attempting to get the secret keys from him by force.\n+\n+However with CHECKLOCKTIMEVERIFY the funds can be stored in scriptPubKeys of\n+the form:\n+\n+    IF\n+        <now + 3 months> CHECKLOCKTIMEVERIFY DROP\n+        <Lenny's pubkey> CHECKSIGVERIFY\n+        1\n+    ELSE\n+        2\n+    ENDIF\n+    <Alice's pubkey> <Bob's pubkey> 2 CHECKMULTISIG\n+\n+At any time the funds can be spent with the following scriptSig:\n+\n+    <Alice's signature> <Bob's signature> 0\n+\n+After 3 months have passed Lenny and one of either Alice or Bob can spend the\n+funds with the following scriptSig:\n+\n+    <Alice/Bob's signature> <Lenny's signature> 1\n+\n+\n+===Non-interactive time-locked refunds===\n+\n+There exist a number of protocols where a transaction output is created that\n+requires the co-operation of both parties to spend the output. To ensure the\n+failure of one party does not result in the funds becoming lost refund\n+transactions are setup in advance using nLockTime. These refund transactions\n+need to be created interactively, and additionaly, are currently vulnerable to\n+transaction mutability. CHECKLOCKTIMEVERIFY can be used in these protocols,\n+replacing the interactive setup with a non-interactive setup, and additionally,\n+making transaction mutability a non-issue.\n+\n+\n+====Two-factor wallets====\n+\n+Services like GreenAddress store Bitcoins with 2-of-2 multisig scriptPubKey's\n+such that one keypair is controlled by the user, and the other keypair is\n+controlled by the service. To spend funds the user uses locally installed\n+wallet software that generates one of the required signatures, and then uses a\n+2nd-factor authentication method to authorize the service to create the second\n+SIGHASH_NONE signature that is locked until some time in the future and sends\n+the user that signature for storage. If the user needs to spend their funds and\n+the service is not available, they wait until the nLockTime expires.\n+\n+The problem is there exist numerous occasions the user will not have a valid\n+signature for some or all of their transaction outputs. With\n+CHECKLOCKTIMEVERIFY rather than creating refund signatures on demand\n+scriptPubKeys of the following form are used instead:\n+\n+    IF\n+        <service pubkey> CHECKSIGVERIFY\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+    ENDIF\n+    <user pubkey> CHECKSIG\n+\n+Now the user is always able to spend their funds without the co-operation of\n+the service by waiting for the expiry time to be reached.\n+\n+\n+====Micropayment Channels====\n+\n+Jeremy Spilman style micropayment channels first setup a deposit controlled by\n+2-of-2 multisig, tx1, and then adjust a second transaction, tx2, that spends\n+the output of tx1 to payor and payee. Prior to publishing tx1 a refund\n+transaction is created, tx3, to ensure that should the payee vanish the payor\n+can get their deposit back. The process by which the refund transaction is\n+created is currently vulnerable to transaction mutability attacks, and\n+additionally, requires the payor to store the refund. Using the same\n+scriptPubKey from as in the Two-factor wallets example solves both these issues.\n+\n+\n+===Trustless Payments for Publishing Data===\n+\n+The PayPub protocol makes it possible to pay for information in a trustless way\n+by first proving that an encrypted file contains the desired data, and secondly\n+crafting scriptPubKeys used for payment such that spending them reveals the\n+encryption keys to the data. However the existing implementation has a\n+significant flaw: the publisher can delay the release of the keys indefinitely.\n+\n+This problem can be solved interactively with the refund transaction technique;\n+with CHECKLOCKTIMEVERIFY the problem can be non-interactively solved using\n+scriptPubKeys of the following form:\n+\n+    IF\n+        HASH160 <Hash160(encryption key)> EQUALVERIFY\n+        <publisher pubkey> CHECKSIG\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+        <buyer pubkey> CHECKSIG\n+    ENDIF\n+\n+The buyer of the data is now making a secure offer with an expiry time. If the\n+publisher fails to accept the offer before the expiry time is reached the buyer\n+can cancel the offer by spending the output.\n+\n+\n+===Proving sacrifice to miners' fees===\n+\n+Proving the sacrifice of some limited resource is a common technique in a\n+variety of cryptographic protocols. Proving sacrifices of coins to mining fees\n+has been proposed as a ''universal public good'' to which the sacrifice could\n+be directed, rather than simply destroying the coins. However doing so is\n+non-trivial, and even the best existing technqiue - announce-commit sacrifices\n+- could encourage mining centralization. CHECKLOCKTIMEVERIFY can be used to\n+create outputs that are provably spendable by anyone (thus to mining fees\n+assuming miners behave optimally and rationally) but only at a time\n+sufficiently far into the future that large miners profitably can't sell the\n+sacrifices at a discount.",
      "path": "bip-0065.mediawiki",
      "position": 172,
      "original_position": 172,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "in_reply_to_id": null,
      "user": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Censorship isn't likely to be the problem. More likely the miner just won't see value in mining the initial transaction until they can at the same time redeem the sacrificed funds.\n\nSince this has a section of its own, it is obviously a primary use case and should be addressed. No need to mess with the stack for it, either...\n",
      "created_at": "2014-11-10T15:15:41Z",
      "updated_at": "2014-11-10T15:15:41Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20087002",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20087002"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 172,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20087524",
      "pull_request_review_id": null,
      "id": 20087524,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDg3NTI0",
      "diff_hunk": "@@ -0,0 +1,284 @@\n+<pre>\n+  BIP: 65\n+  Title: OP_CHECKLOCKTIMEVERIFY\n+  Author: Peter Todd <pete@petertodd.org>\n+  Status: Draft\n+  Type: Standards Track\n+  Created: 2014-10-01\n+</pre>\n+\n+==Abstract==\n+\n+This BIP describes a new opcode (OP_CHECKLOCKTIMEVERIFY) for the Bitcoin\n+scripting system that allows a transaction output to be made unspendable until\n+some point in the future.\n+\n+\n+==Summary==\n+\n+CHECKLOCKTIMEVERIFY re-defines the existing NOP2 opcode. When executed it\n+compares the top item on the stack to the nLockTime field of the transaction\n+containing the scriptSig. If that top stack item is greater than the transation\n+nLockTime the script fails immediately, otherwise script evaluation continues\n+as though a NOP was executed.\n+\n+The nLockTime field in a transaction prevents the transaction from being mined\n+until either a certain block height, or block time, has been reached. By\n+comparing the argument to CHECKLOCKTIMEVERIFY against the nLockTime field, we\n+indirectly verify that the desired block height or block time has been reached;\n+until that block height or block time has been reached the transaction output\n+remains unspendable.\n+\n+\n+==Motivation==\n+\n+The nLockTime field in transactions makes it possible to prove that a\n+transaction output can be spent in the future: a valid signature for a\n+transaction with the desired nLockTime can be constructed, proving that it is\n+possible to spend the output with that signature when the nLockTime is reached.\n+An example where this technique is used is in micro-payment channels, where the\n+nLockTime field proves that should the receiver vanish the sender is guaranteed\n+to get all their escrowed funds back when the nLockTime is reached.\n+\n+However the nLockTime field is insufficient if you wish to prove that\n+transaction output ''can-not'' be spent until some time in the future, as there\n+is no way to prove that the secret keys corresponding to the pubkeys controling\n+the funds have not been used to create a valid signature.\n+\n+\n+===Escrow===\n+\n+If Alice and Bob jointly operate a business they may want to\n+ensure that all funds are kept in 2-of-2 multisig transaction outputs that\n+require the co-operation of both parties to spend. However, they recognise that\n+in exceptional circumstances such as either party getting \"hit by a bus\" they\n+need a backup plan to retrieve the funds. So they appoint their lawyer, Lenny,\n+to act as a third-party.\n+\n+With a standard 2-of-3 CHECKMULTISIG at any time Lenny could conspire with\n+either Alice or Bob to steal the funds illegitimately. Equally Lenny may prefer\n+not to have immediate access to the funds to discourage bad actors from\n+attempting to get the secret keys from him by force.\n+\n+However with CHECKLOCKTIMEVERIFY the funds can be stored in scriptPubKeys of\n+the form:\n+\n+    IF\n+        <now + 3 months> CHECKLOCKTIMEVERIFY DROP\n+        <Lenny's pubkey> CHECKSIGVERIFY\n+        1\n+    ELSE\n+        2\n+    ENDIF\n+    <Alice's pubkey> <Bob's pubkey> 2 CHECKMULTISIG\n+\n+At any time the funds can be spent with the following scriptSig:\n+\n+    <Alice's signature> <Bob's signature> 0\n+\n+After 3 months have passed Lenny and one of either Alice or Bob can spend the\n+funds with the following scriptSig:\n+\n+    <Alice/Bob's signature> <Lenny's signature> 1\n+\n+\n+===Non-interactive time-locked refunds===\n+\n+There exist a number of protocols where a transaction output is created that\n+requires the co-operation of both parties to spend the output. To ensure the\n+failure of one party does not result in the funds becoming lost refund\n+transactions are setup in advance using nLockTime. These refund transactions\n+need to be created interactively, and additionaly, are currently vulnerable to\n+transaction mutability. CHECKLOCKTIMEVERIFY can be used in these protocols,\n+replacing the interactive setup with a non-interactive setup, and additionally,\n+making transaction mutability a non-issue.\n+\n+\n+====Two-factor wallets====\n+\n+Services like GreenAddress store Bitcoins with 2-of-2 multisig scriptPubKey's\n+such that one keypair is controlled by the user, and the other keypair is\n+controlled by the service. To spend funds the user uses locally installed\n+wallet software that generates one of the required signatures, and then uses a\n+2nd-factor authentication method to authorize the service to create the second\n+SIGHASH_NONE signature that is locked until some time in the future and sends\n+the user that signature for storage. If the user needs to spend their funds and\n+the service is not available, they wait until the nLockTime expires.\n+\n+The problem is there exist numerous occasions the user will not have a valid\n+signature for some or all of their transaction outputs. With\n+CHECKLOCKTIMEVERIFY rather than creating refund signatures on demand\n+scriptPubKeys of the following form are used instead:\n+\n+    IF\n+        <service pubkey> CHECKSIGVERIFY\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+    ENDIF\n+    <user pubkey> CHECKSIG\n+\n+Now the user is always able to spend their funds without the co-operation of\n+the service by waiting for the expiry time to be reached.\n+\n+\n+====Micropayment Channels====\n+\n+Jeremy Spilman style micropayment channels first setup a deposit controlled by\n+2-of-2 multisig, tx1, and then adjust a second transaction, tx2, that spends\n+the output of tx1 to payor and payee. Prior to publishing tx1 a refund\n+transaction is created, tx3, to ensure that should the payee vanish the payor\n+can get their deposit back. The process by which the refund transaction is\n+created is currently vulnerable to transaction mutability attacks, and\n+additionally, requires the payor to store the refund. Using the same\n+scriptPubKey from as in the Two-factor wallets example solves both these issues.\n+\n+\n+===Trustless Payments for Publishing Data===\n+\n+The PayPub protocol makes it possible to pay for information in a trustless way\n+by first proving that an encrypted file contains the desired data, and secondly\n+crafting scriptPubKeys used for payment such that spending them reveals the\n+encryption keys to the data. However the existing implementation has a\n+significant flaw: the publisher can delay the release of the keys indefinitely.\n+\n+This problem can be solved interactively with the refund transaction technique;\n+with CHECKLOCKTIMEVERIFY the problem can be non-interactively solved using\n+scriptPubKeys of the following form:\n+\n+    IF\n+        HASH160 <Hash160(encryption key)> EQUALVERIFY\n+        <publisher pubkey> CHECKSIG\n+    ELSE\n+        <expiry time> CHECKLOCKTIMEVERIFY DROP\n+        <buyer pubkey> CHECKSIG\n+    ENDIF\n+\n+The buyer of the data is now making a secure offer with an expiry time. If the\n+publisher fails to accept the offer before the expiry time is reached the buyer\n+can cancel the offer by spending the output.\n+\n+\n+===Proving sacrifice to miners' fees===\n+\n+Proving the sacrifice of some limited resource is a common technique in a\n+variety of cryptographic protocols. Proving sacrifices of coins to mining fees\n+has been proposed as a ''universal public good'' to which the sacrifice could\n+be directed, rather than simply destroying the coins. However doing so is\n+non-trivial, and even the best existing technqiue - announce-commit sacrifices\n+- could encourage mining centralization. CHECKLOCKTIMEVERIFY can be used to\n+create outputs that are provably spendable by anyone (thus to mining fees\n+assuming miners behave optimally and rationally) but only at a time\n+sufficiently far into the future that large miners profitably can't sell the\n+sacrifices at a discount.",
      "path": "bip-0065.mediawiki",
      "position": 172,
      "original_position": 172,
      "commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "original_commit_id": "b05bc1ef5348a4d50bc3012865534b73dbc2164d",
      "in_reply_to_id": null,
      "user": {
        "login": "petertodd",
        "id": 7042,
        "node_id": "MDQ6VXNlcjcwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/petertodd",
        "html_url": "https://github.com/petertodd",
        "followers_url": "https://api.github.com/users/petertodd/followers",
        "following_url": "https://api.github.com/users/petertodd/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/petertodd/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/petertodd/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/petertodd/subscriptions",
        "organizations_url": "https://api.github.com/users/petertodd/orgs",
        "repos_url": "https://api.github.com/users/petertodd/repos",
        "events_url": "https://api.github.com/users/petertodd/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/petertodd/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Doing what you want would be about another order of magnitude more actual code changes; not worth it. If other people have strong feelings about this use-case I'd rather just remove it from the BIP.\n\nQuite seriously, every additional line of consensus-critical code changed represents at minimum hours if not tens of hours of work.\n",
      "created_at": "2014-11-10T15:23:25Z",
      "updated_at": "2014-11-10T15:23:25Z",
      "html_url": "https://github.com/bitcoin/bips/pull/118#discussion_r20087524",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/20087524"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/118"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 172,
      "original_line": null,
      "side": "RIGHT"
    }
  ]
}