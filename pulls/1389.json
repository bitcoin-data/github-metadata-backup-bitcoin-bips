{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bips/pulls/1389",
    "id": 1124681288,
    "node_id": "PR_kwDOAN28mc5DCUZI",
    "html_url": "https://github.com/bitcoin/bips/pull/1389",
    "diff_url": "https://github.com/bitcoin/bips/pull/1389.diff",
    "patch_url": "https://github.com/bitcoin/bips/pull/1389.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389",
    "commits_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bips/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bips/issues/1389/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/9adbeccca277e804b3321821e42c1ed0c1ef74ee",
    "number": 1389,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "[New BIP] Wallet Policies",
    "user": {
      "login": "bigspider",
      "id": 6681844,
      "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bigspider",
      "html_url": "https://github.com/bigspider",
      "followers_url": "https://api.github.com/users/bigspider/followers",
      "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
      "organizations_url": "https://api.github.com/users/bigspider/orgs",
      "repos_url": "https://api.github.com/users/bigspider/repos",
      "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/bigspider/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Initial version posted to [bitcoin-dev in May](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html).\r\n\r\nWallet policies are implemented in the [Ledger bitcoin app](https://github.com/LedgerHQ/app-bitcoin-new) (since version 2.1.0).\r\n\r\nThe following PR experimenting with an HWI integration might provide more context and an end-to-end demo:\r\n  - https://github.com/bitcoin-core/HWI/pull/647",
    "labels": [
      {
        "id": 275845989,
        "node_id": "MDU6TGFiZWwyNzU4NDU5ODk=",
        "url": "https://api.github.com/repos/bitcoin/bips/labels/New%20BIP",
        "name": "New BIP",
        "color": "5319e7",
        "default": false
      }
    ],
    "created_at": "2022-11-16T15:34:23Z",
    "updated_at": "2023-09-07T15:29:48Z",
    "mergeable": true,
    "mergeable_state": "clean",
    "merge_commit_sha": "59d5c5d6b9de326c06310ca5394205ba0c36f968",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "bigspider:bip-wallet-policies",
      "ref": "bip-wallet-policies",
      "sha": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 416262417,
        "node_id": "R_kgDOGM-pEQ",
        "name": "bips",
        "full_name": "bigspider/bips",
        "owner": {
          "login": "bigspider",
          "id": 6681844,
          "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
          "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bigspider",
          "html_url": "https://github.com/bigspider",
          "followers_url": "https://api.github.com/users/bigspider/followers",
          "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
          "organizations_url": "https://api.github.com/users/bigspider/orgs",
          "repos_url": "https://api.github.com/users/bigspider/repos",
          "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bigspider/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bigspider/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": true,
        "url": "https://api.github.com/repos/bigspider/bips",
        "archive_url": "https://api.github.com/repos/bigspider/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bigspider/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bigspider/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bigspider/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bigspider/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bigspider/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bigspider/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bigspider/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bigspider/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bigspider/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bigspider/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bigspider/bips/downloads",
        "events_url": "https://api.github.com/repos/bigspider/bips/events",
        "forks_url": "https://api.github.com/repos/bigspider/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bigspider/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bigspider/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bigspider/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bigspider/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bigspider/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bigspider/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bigspider/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bigspider/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bigspider/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bigspider/bips/languages",
        "merges_url": "https://api.github.com/repos/bigspider/bips/merges",
        "milestones_url": "https://api.github.com/repos/bigspider/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bigspider/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bigspider/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bigspider/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bigspider/bips.git",
        "stargazers_url": "https://api.github.com/repos/bigspider/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bigspider/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bigspider/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bigspider/bips/subscription",
        "tags_url": "https://api.github.com/repos/bigspider/bips/tags",
        "teams_url": "https://api.github.com/repos/bigspider/bips/teams",
        "trees_url": "https://api.github.com/repos/bigspider/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bigspider/bips.git",
        "hooks_url": "https://api.github.com/repos/bigspider/bips/hooks",
        "svn_url": "https://github.com/bigspider/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 13500,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-09-06T13:29:47Z",
        "created_at": "2021-10-12T09:08:05Z",
        "updated_at": "2022-09-01T08:36:44Z"
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "de6b3ffeb807e3cb6868dee6a6ec18dd6b565858",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 14531737,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDUzMTczNw==",
        "name": "bips",
        "full_name": "bitcoin/bips",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bips",
        "description": "Bitcoin Improvement Proposals",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bips",
        "archive_url": "https://api.github.com/repos/bitcoin/bips/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bips/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bips/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bips/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bips/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bips/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bips/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bips/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bips/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bips/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bips/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bips/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bips/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bips/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bips/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bips/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bips/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bips.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bips/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bips/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bips/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bips/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bips/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bips/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bips/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bips/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bips/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bips/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bips/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bips.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bips/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bips/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bips/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bips/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bips/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bips/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bips/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bips.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bips/hooks",
        "svn_url": "https://github.com/bitcoin/bips",
        "homepage": "",
        "language": "Wikitext",
        "forks_count": 5561,
        "stargazers_count": 8301,
        "watchers_count": 8301,
        "size": 13660,
        "default_branch": "master",
        "open_issues_count": 117,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": false,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": true,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-09-07T13:58:06Z",
        "created_at": "2013-11-19T17:18:41Z",
        "updated_at": "2023-09-07T14:49:35Z"
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 522,
    "deletions": 0,
    "changed_files": 2,
    "commits": 11,
    "review_comments": 41,
    "comments": 3
  },
  "events": [
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGZkM2I4NGRhODNmNWIyMjk1M2FiOGM4Y2M3YzJmMTIzOTAyNjY5MmE",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "tree": {
        "sha": "304552a4fa892912874f56c6dcac5abf19526bdf",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/304552a4fa892912874f56c6dcac5abf19526bdf"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 304552a4fa892912874f56c6dcac5abf19526bdf\nparent 52f68fecd8ec9604672e26392468e7e7edf25a5e\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1662039054 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1668612271 +0100\n\nSpecify bip-wallet-policies\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmN1AK8ACgkQdAYP+Bsz\n5PgSAgv/SjivsQs+ze8iswW2PYQYUKBJdRacqh5Pkra/GMXLJLdWArC0DVT13Tj8\nK2og8l5s6k4rfTjYbwbdZxAV4/dIzovPvPfDlAFzf0BWGDtW20KvicLh1I6tCbcu\nTT8l03+S5e6CBFsfvAO7bovszY0xp1Dip6pIHq6jveXzomcjUiaJC3YgHdmP1U4i\noT3Ma4XcgulMZNXeeYQWK7YYcQHExUSfBIeFI07AtF5xXtFj53Kyre47qBPNbwD2\nyjegPdtJo94V9emR+OfKVgDqkLoDjZI/u2iVC1r3vAb65Nr3mtRnfRQNUFKxZhkU\naaDS2vRVZ4PG5qa8zXXM+K54gJUZG9vpYyNAv6RwAp0xfFkP8gkUOahzOAn7e/bV\nK5hjmwRj9vMFYMbl3BGkGXBWLt9txkNb4BzqXcmYgoL8Xt5Y/jCSPBadEeZeC3O9\nhG6LELb4oTE8MPQlzPndtNA30f/bvd20LSDSJ22IhEuf5wtGCEcR8DbYOCgLbbl0\nx2iTyYB5\n=Gpb1\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/52f68fecd8ec9604672e26392468e7e7edf25a5e",
          "sha": "52f68fecd8ec9604672e26392468e7e7edf25a5e",
          "html_url": "https://github.com/bitcoin/bips/commit/52f68fecd8ec9604672e26392468e7e7edf25a5e"
        }
      ],
      "message": "Specify bip-wallet-policies",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2022-11-16T15:24:31Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2022-09-01T13:30:54Z"
      },
      "sha": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-16T15:39:19Z",
      "updated_at": "2022-11-16T15:39:19Z",
      "source": {
        "issue": {
          "id": 1451598094,
          "node_id": "PR_kwDOBfbkJs5DBkIX",
          "url": "https://api.github.com/repos/bitcoin-core/HWI/issues/647",
          "repository_url": "https://api.github.com/repos/bitcoin-core/HWI",
          "labels_url": "https://api.github.com/repos/bitcoin-core/HWI/issues/647/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/bitcoin-core/HWI/issues/647/comments",
          "events_url": "https://api.github.com/repos/bitcoin-core/HWI/issues/647/events",
          "html_url": "https://github.com/bitcoin-core/HWI/pull/647",
          "number": 647,
          "state": "open",
          "state_reason": null,
          "title": "[PoC] Wallet policies (and miniscript support)",
          "body": "Hello,\r\n\r\nthis in an exploratory PR as a proof of concept of how wallet policies could look like in HWI.\r\n\r\nWallet policies [were presented](https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-May/020423.html) to the bitcoin-dev mailing list back in May.\r\nA BIP proposal is in preparation [here](https://github.com/bitcoin/bips/pull/1389).\r\n\r\nThe goals of this PR are to:\r\n- show that adding wallet policies to hwi is relatively straightforward and can be done with non-breaking changes\r\n- argue that wallet policies naturally and conveniently represent the \"accounts\" of a typical single-signature, multisignature or miniscript-based wallet accounts;\r\n- demo how a typical wallet-policy workflow could look like with hwi;\r\n- showcase specifically the implementation and UX in the Ledger bitcoin application.\r\n\r\nWallet policies are designed to be vendor-agnostic.\r\nIn fact, they are ready for miniscript wallets, and they might in my opinion be a convenient, opinionated way of adding miniscript support to HWI.\r\n\r\nThey are implemented in the Ledger bitcoin app since version 2.1.0, which uses them to support miniscript (on segwit only, at this time).\r\n\r\n# Implementation details\r\n\r\nNot production-ready!\r\n\r\nIn this PR, I attempted to add wallet policies as a first-class object, while not breaking compatibility with existing code. \r\n\r\nThe three commit add:\r\n- The wallet-policy-related methods in `HardwareWalletClient`: `can_register_wallet_policies`, `register_wallet_policy`, `display_wallet_policy_address`, `sign_tx_with_wallet_policy`.\r\n- Support in CLI within `displayaddress` and `signtx`; added `registerpolicy`.\r\n- The specific implementation of wallet policies for the Ledger client in `ledger.py`.\r\n\r\nFor subclasses not implementing wallet policies, a compatibility layer guarantees that if the policy falls back into the supported cases (single-signature, or standard multisignature), calls to functions using wallet policies are automatically converted to the corresponding single-sig or multi-sig function to show addresses or sign transactions.\r\n\r\nWith this approach, software wallets adopting wallet policies, therefore, could use them directly without using any other `HardwareWalletClient` function without wallet policies.\r\n\r\n# Demo\r\n\r\nIn the following, I'd like to walk you through an end-to-end demo of wallet policies that can be tested from this PR's branch using the [Ledger bitcoin testnet app ](https://github.com/LedgerHQ/app-bitcoin-new) version 2.1.0 in the speculos emulator; the app will be released in production within a few weeks.\r\n\r\nIn all the examples with multiple keys, internal keys are the ones with fingerprint `f5acc2fd`, which is the fingerprint for the default seed used by the speculos emulator.\r\n\r\nThe command should be run from the root folder of the HWI repository, or after installing the module from this PR (e.g. with `pip install .`).\r\n\r\nScreenshots are based on the UX for a Ledger NanoS+ device.\r\n\r\n## Single-signature\r\n\r\nIn this example, we use a wallet policy for a standard BIP-86 taproot address. Ledger devices require no registration for standard single-signature policies, so this can be used directly.\r\n\r\n```\r\n# display address for a taproot BIP-86 address\r\npython -m hwi --chain test --device-type ledger displayaddress\\\r\n       --policy \"tr(@0/**)\"\\\r\n       --keys \"[\\\"[f5acc2fd/86'/1'/0']tpubDDKYE6BREvDsSWMazgHoyQWiJwYaDDYPbCFjYxN3HFXJP5fokeiK4hwK5tTLBNEDBwrDXn8cQ4v9b2xdW62Xr5yxoQdMu1v6c7UDXYVH27U\\\"]\"\r\n```\r\nDevice screen:\r\n\r\n![out](https://user-images.githubusercontent.com/6681844/202187739-819e2652-969a-4b08-abed-825ec43da057.gif)\r\n\r\nOutput:\r\n```\r\n\r\n{\"address\": \"tb1pws8wvnj99ca6acf8kq7pjk7vyxknah0d9mexckh5s0vu2ccy68js9am6u7\"}\r\n```\r\n\r\n## Multisignature\r\n\r\n## Register policy\r\n\r\n```\r\n# register a legacy multisig policy on the device\r\npython -m hwi --chain test --device-type ledger registerpolicy\\\r\n       --policy \"sh(sortedmulti(2,@0/**,@1/**))\"\\\r\n       --name \"Cold storage\"\\\r\n       --keys \"[\\\"[5c9e228d/48'/1'/0'/0']tpubDEGquuorgFNb8bjh5kNZQMPtABJzoWwNm78FUmeoPkfRtoPF7JLrtoZeT3J3ybq1HmC3Rn1Q8wFQ8J5usanzups5rj7PJoQLNyvq8QbJruW\\\",\\\"[f5acc2fd/48'/1'/0'/0']tpubDFAqEGNyad35WQAZMmPD4vgBXnjH16RGciLdWekPe4f4d5JzoHVu1PS86Sy4Tm63vDf8rfV3UjifhrRuSUDfiZj5KPffTPyZ4ZXBKvjD8jm\\\"]\"\r\n```\r\n\r\nDevice screen:\r\n![01-register](https://user-images.githubusercontent.com/6681844/202187921-80bfb18f-40c5-4756-9e50-79a02fac9ebf.gif)\r\n\r\n\r\nOutput:\r\n```\r\n{\"proof_of_registration\": \"fa73e36119324fbe4cc1ca94aa842c6261526d44112a22164bc57c3335102b04\"}\r\n```\r\n\r\n## Display address\r\n\r\n```\r\n# display an address for a registered multisig policy\r\npython -m hwi --chain test --device-type ledger displayaddress\\\r\n       --policy \"sh(sortedmulti(2,@0/**,@1/**))\"\\\r\n       --name \"Cold storage\"\\\r\n       --keys \"[\\\"[5c9e228d/48'/1'/0'/0']tpubDEGquuorgFNb8bjh5kNZQMPtABJzoWwNm78FUmeoPkfRtoPF7JLrtoZeT3J3ybq1HmC3Rn1Q8wFQ8J5usanzups5rj7PJoQLNyvq8QbJruW\\\",\\\"[f5acc2fd/48'/1'/0'/0']tpubDFAqEGNyad35WQAZMmPD4vgBXnjH16RGciLdWekPe4f4d5JzoHVu1PS86Sy4Tm63vDf8rfV3UjifhrRuSUDfiZj5KPffTPyZ4ZXBKvjD8jm\\\"]\"\\\r\n       --extra \"{\\\"proof_of_registration\\\": \\\"fa73e36119324fbe4cc1ca94aa842c6261526d44112a22164bc57c3335102b04\\\"}\"\r\n```\r\n\r\nDevice screen:\r\n![02-receive](https://user-images.githubusercontent.com/6681844/202188026-a73330d2-0b44-476b-bbdf-da9559656d7f.gif)\r\n\r\n\r\nOutput:\r\n```\r\n{\"address\": \"2Mx69MjHC4ViZAH1koVXPvVgaazbBCdr89j\"}\r\n```\r\n\r\n## Sign a psbt with policy\r\n\r\nIt is relevant to point out that when using wallet policies, it makes sense to use a more specific action rather than \"sign a transaction\": in fact, the wallet policy specifies exactly what kind of scripts/inputs should be signed, and similarly, what outputs can match a change address.\r\nThis allows hardware wallets to correctly identify internal inputs and outputs.\r\n\r\nThe necessary information about what exact wallet policy should be used for signing is in fact typically available to the software wallet.\r\nTherefore, the action is \"sign a transaction with a certain wallet policy\".\r\n\r\n```\r\n# sign a psbt using a registered multisig policy\r\npython -m hwi --chain test --device-type ledger signtx\\\r\n       cHNidP8BAH0CAAAAATu7ic6eCZKS8ISJpxQmv/DpLPyQgxBDTD7ECvecufnvAQAAAAD9////AjkwAAAAAAAAFgAUMxjgT65sEq/LAJxpzVflslBK5rTmQQEAAAAAACIAIKgAjP1KDkIBgF3Cmo+Jj+uu9mUmnEuPjoFZDYcT5J9YAAAAAAABAJQCAAAAAdnPFpiaZHjHIp9948kMd6KSqdFfHTv74HHnrMapIZneAAAAABcWABSPMOw+gW7W+tfmjgw1zGwPbdtlvv7///8CoQ7VAAAAAAAWABRv0DCr8w8BHXhZ+5ysOZpTo3v91KCGAQAAAAAAIgAg2TvCCm8+G8E0Ds5MifVQC5rxzbKlEwHbKRkVgPCLrgMjhh4AAQEroIYBAAAAAAAiACDZO8IKbz4bwTQOzkyJ9VALmvHNsqUTAdspGRWA8IuuAwEFR1IhAlAXEIvs6o3txTALsiOGs6swNnrCYvnOXlgybrg+OiL1IQNrFujB+Xn6TMDwW2owCv//lBRZtvIN533lWwFg745MrFKuIgYCUBcQi+zqje3FMAuyI4azqzA2esJi+c5eWDJuuD46IvUcdiI6bjAAAIABAACAAAAAgAIAAIAAAAAAAAAAACIGA2sW6MH5efpMwPBbajAK//+UFFm28g3nfeVbAWDvjkysHPWswv0wAACAAQAAgAAAAIACAACAAAAAAAAAAAAAAAEBR1IhAleBu0CgoDHY9QkXQyIkVOKYC765sDDZaHeMfWd9xszJIQLdg+T/0aVgy1q/LtEqLdTb6+V2KvUPwDCqjBF5gd9eO1KuIgICV4G7QKCgMdj1CRdDIiRU4pgLvrmwMNlod4x9Z33GzMkcdiI6bjAAAIABAACAAAAAgAIAAIABAAAAAAAAACICAt2D5P/RpWDLWr8u0Sot1Nvr5XYq9Q/AMKqMEXmB3147HPWswv0wAACAAQAAgAAAAIACAACAAQAAAAAAAAAA\\\r\n       --policy \"wsh(sortedmulti(2,@0/**,@1/**))\"\\\r\n       --name \"Cold storage\"\\\r\n       --keys \"[\\\"[76223a6e/48'/1'/0'/2']tpubDE7NQymr4AFtewpAsWtnreyq9ghkzQBXpCZjWLFVRAvnbf7vya2eMTvT2fPapNqL8SuVvLQdbUbMfWLVDCZKnsEBqp6UK93QEzL8Ck23AwF\\\",\\\"[f5acc2fd/48'/1'/0'/2']tpubDFAqEGNyad35aBCKUAXbQGDjdVhNueno5ZZVEn3sQbW5ci457gLR7HyTmHBg93oourBssgUxuWz1jX5uhc1qaqFo9VsybY1J5FuedLfm4dK\\\"]\"\\\r\n       --extra \"{\\\"proof_of_registration\\\": \\\"d7c7a60b4ab4a14c1bf8901ba627d72140b2fb907f2b4e35d2e693bce9fbb371\\\"}\"\r\n```\r\n\r\nDevice screen:\r\n![03-spend](https://user-images.githubusercontent.com/6681844/202188092-54b0322d-8245-4936-bf88-136142683757.gif)\r\n\r\nOutput:\r\n```\r\n{\"psbt\": \"cHNidP8BAH0CAAAAATu7ic6eCZKS8ISJpxQmv/DpLPyQgxBDTD7ECvecufnvAQAAAAD9////AjkwAAAAAAAAFgAUMxjgT65sEq/LAJxpzVflslBK5rTmQQEAAAAAACIAIKgAjP1KDkIBgF3Cmo+Jj+uu9mUmnEuPjoFZDYcT5J9YAAAAAAABAJQCAAAAAdnPFpiaZHjHIp9948kMd6KSqdFfHTv74HHnrMapIZneAAAAABcWABSPMOw+gW7W+tfmjgw1zGwPbdtlvv7///8CoQ7VAAAAAAAWABRv0DCr8w8BHXhZ+5ysOZpTo3v91KCGAQAAAAAAIgAg2TvCCm8+G8E0Ds5MifVQC5rxzbKlEwHbKRkVgPCLrgMjhh4AAQEroIYBAAAAAAAiACDZO8IKbz4bwTQOzkyJ9VALmvHNsqUTAdspGRWA8IuuAyICA2sW6MH5efpMwPBbajAK//+UFFm28g3nfeVbAWDvjkysRzBEAiBqspfIOrZuVzcjiSBh2CfFrAFQ4gRP7X7TR0L+28+ybgIgMZzfTq3f9j/DCM31PiJeoDQCTvlt4D/Qk5tt7uoei9MBAQVHUiECUBcQi+zqje3FMAuyI4azqzA2esJi+c5eWDJuuD46IvUhA2sW6MH5efpMwPBbajAK//+UFFm28g3nfeVbAWDvjkysUq4iBgJQFxCL7OqN7cUwC7IjhrOrMDZ6wmL5zl5YMm64Pjoi9Rx2IjpuMAAAgAEAAIAAAACAAgAAgAAAAAAAAAAAIgYDaxbowfl5+kzA8FtqMAr//5QUWbbyDed95VsBYO+OTKwc9azC/TAAAIABAACAAAAAgAIAAIAAAAAAAAAAAAAAAQFHUiECV4G7QKCgMdj1CRdDIiRU4pgLvrmwMNlod4x9Z33GzMkhAt2D5P/RpWDLWr8u0Sot1Nvr5XYq9Q/AMKqMEXmB3147Uq4iAgJXgbtAoKAx2PUJF0MiJFTimAu+ubAw2Wh3jH1nfcbMyRx2IjpuMAAAgAEAAIAAAACAAgAAgAEAAAAAAAAAIgIC3YPk/9GlYMtavy7RKi3U2+vldir1D8AwqowReYHfXjsc9azC/TAAAIABAACAAAAAgAIAAIABAAAAAAAAAAA=\", \"signed\": true}\r\n```\r\n\r\n# Miniscript\r\n\r\nMiniscript policy: a 3-of-3 that becomes a 2-of-3 after 90 days: `thresh(3,pk(key_1),pk(key_2),pk(key_3),older(12960))`.\r\n\r\n## Register policy\r\n```\r\n# register the wallet policy\r\npython -m hwi --chain test --device-type ledger registerpolicy\\\r\n       --policy \"wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\"\\\r\n       --name \"Decaying 3of3\"\\\r\n       --keys \"[\\\"[f5acc2fd/48'/1'/0'/2']tpubDFAqEGNyad35aBCKUAXbQGDjdVhNueno5ZZVEn3sQbW5ci457gLR7HyTmHBg93oourBssgUxuWz1jX5uhc1qaqFo9VsybY1J5FuedLfm4dK\\\",\\\"tpubDCsD8geGfXgcBhxuvqqEGSmCR5P56f2rwxvcg51h9PL39zYXS4k4Ryn5eNdxN9H9umPbezhKZjpzS6Bjv6WbRQZqtvoHtQ29pkn1VZ3GA7k\\\",\\\"tpubDD1dWr4oGX2148MJ3WBGTCfC8i2H5juMExoSzE5nHdzRNJeVcxY1qT1WFBASTubBQpbW6Tt2KBbmy8rZNiC4oXZhEnc9BW6x33yPYizRjpc\\\"]\"\r\n```\r\n\r\nDevice screen:\r\n![01-register](https://user-images.githubusercontent.com/6681844/202188269-ecd545fe-e427-4754-bd76-dbeaeedf559f.gif)\r\n\r\nOutput:\r\n```\r\n{\"proof_of_registration\": \"bac398f60b85214815051bc89bd7f6d94097f0b53ae61a18acad6c7bc3e9f80b\"}\r\n```\r\n\r\n## Display address\r\n\r\n```\r\n# display a specific address\r\npython -m hwi --chain test --device-type ledger displayaddress\\\r\n       --policy \"wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\"\\\r\n       --name \"Decaying 3of3\"\\\r\n       --keys \"[\\\"[f5acc2fd/48'/1'/0'/2']tpubDFAqEGNyad35aBCKUAXbQGDjdVhNueno5ZZVEn3sQbW5ci457gLR7HyTmHBg93oourBssgUxuWz1jX5uhc1qaqFo9VsybY1J5FuedLfm4dK\\\",\\\"tpubDCsD8geGfXgcBhxuvqqEGSmCR5P56f2rwxvcg51h9PL39zYXS4k4Ryn5eNdxN9H9umPbezhKZjpzS6Bjv6WbRQZqtvoHtQ29pkn1VZ3GA7k\\\",\\\"tpubDD1dWr4oGX2148MJ3WBGTCfC8i2H5juMExoSzE5nHdzRNJeVcxY1qT1WFBASTubBQpbW6Tt2KBbmy8rZNiC4oXZhEnc9BW6x33yPYizRjpc\\\"]\"\\\r\n       --extra \"{\\\"proof_of_registration\\\": \\\"bac398f60b85214815051bc89bd7f6d94097f0b53ae61a18acad6c7bc3e9f80b\\\"}\"\\\r\n       --change 1\\\r\n       --index 3\r\n```\r\n\r\nDevice screen:\r\n![02-receive](https://user-images.githubusercontent.com/6681844/202188362-7a9a61ed-f99e-459c-9a7f-236b0012866b.gif)\r\n\r\nOutput:\r\n```\r\n{\"address\": \"tb1qca0tjjln3fhp3rsyg7tvmyf2x5fmvgk6lcp0zfzmmwr2y8vapllstc36ug\"}\r\n```\r\n\r\n## Sign a psbt with the policy\r\n\r\n```\r\n# sign a tx\r\npython -m hwi --chain test --device-type ledger signtx\\\r\n       cHNidP8BAH0CAAAAAUN7Z9JlC6y6LtlwbTIVzEtWHw6AiBgWuDRIkxoZCKMpAQAAAAD9////AkBCDwAAAAAAFgAUYE60U6z6Rpo5RK6oC+g6RUkxu7usTIkAAAAAACIAIESrl1+a21z6n3pLozjP4AHIQOofzJHNgz3NwDxBwASBAAAAAAABAIkCAAAAAa15z+lMT/YZ0sRDAkaL5A5tBBPIAmil+V/5AePextPvAAAAAAD+////AttabSkBAAAAIlEg0VQ1MNBHwNuDbYWtzEaEV1yANsJurWNqvZxlikhKbbKAlpgAAAAAACIAIESyacRc1GKFR/8RdvMWQ0hcAleGITHMJP6A4Kn5YBy7aQAAAAEBK4CWmAAAAAAAIgAgRLJpxFzUYoVH/xF28xZDSFwCV4YhMcwk/oDgqflgHLsBBXohAp5kb7ngRSRglE5J+IafmrnakIINpdU4Qa+eEnGjvPnOrHwhAoz4Y6xeDg72tAuWuExobc18NXLIzXVx22mvkaLEE3NIrJN8IQIOXt2k+7FDkz0OYPBWmB18LIpxqwY4t8C/kRn7SyouvqyTfGMAZwKgMrKSaJNThyIGAg5e3aT7sUOTPQ5g8FaYHXwsinGrBji3wL+RGftLKi6+DGYCRCIAAAAAAwAAACIGAoz4Y6xeDg72tAuWuExobc18NXLIzXVx22mvkaLEE3NIDKjFojkAAAAAAwAAACIGAp5kb7ngRSRglE5J+IafmrnakIINpdU4Qa+eEnGjvPnOHPWswv0wAACAAQAAgAAAAIACAACAAAAAAAMAAAAAAAEBeiEDRKw0XW+7Q+lxieEI8mjMwAlG8J//ABlTcQlFY93EOwSsfCECmEf2+BbuDI1lxfRMhvkJ2Ij5Qhy0tcpBkQ6MSrYJsCOsk3whA1hZjepNSbXWWXSb7LP7oaJkkN6gA7v/nJxbSAslYPsxrJN8YwBnAqAyspJok1OHIgICmEf2+BbuDI1lxfRMhvkJ2Ij5Qhy0tcpBkQ6MSrYJsCMMqMWiOQEAAAABAAAAIgIDRKw0XW+7Q+lxieEI8mjMwAlG8J//ABlTcQlFY93EOwQc9azC/TAAAIABAACAAAAAgAIAAIABAAAAAQAAACICA1hZjepNSbXWWXSb7LP7oaJkkN6gA7v/nJxbSAslYPsxDGYCRCIBAAAAAQAAAAA=\\\r\n       --policy \"wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\"\\\r\n       --name \"Decaying 3of3\"\\\r\n       --keys \"[\\\"[f5acc2fd/48'/1'/0'/2']tpubDFAqEGNyad35aBCKUAXbQGDjdVhNueno5ZZVEn3sQbW5ci457gLR7HyTmHBg93oourBssgUxuWz1jX5uhc1qaqFo9VsybY1J5FuedLfm4dK\\\",\\\"tpubDCsD8geGfXgcBhxuvqqEGSmCR5P56f2rwxvcg51h9PL39zYXS4k4Ryn5eNdxN9H9umPbezhKZjpzS6Bjv6WbRQZqtvoHtQ29pkn1VZ3GA7k\\\",\\\"tpubDD1dWr4oGX2148MJ3WBGTCfC8i2H5juMExoSzE5nHdzRNJeVcxY1qT1WFBASTubBQpbW6Tt2KBbmy8rZNiC4oXZhEnc9BW6x33yPYizRjpc\\\"]\"\\\r\n       --extra \"{\\\"proof_of_registration\\\": \\\"bac398f60b85214815051bc89bd7f6d94097f0b53ae61a18acad6c7bc3e9f80b\\\"}\"\r\n```\r\n\r\nDevice screen:\r\n![03-spend](https://user-images.githubusercontent.com/6681844/202188424-261cce85-5cf9-4ea5-a139-15661aa89429.gif)\r\n\r\nOutput:\r\n```\r\n{\"psbt\": \"cHNidP8BAH0CAAAAAUN7Z9JlC6y6LtlwbTIVzEtWHw6AiBgWuDRIkxoZCKMpAQAAAAD9////AkBCDwAAAAAAFgAUYE60U6z6Rpo5RK6oC+g6RUkxu7usTIkAAAAAACIAIESrl1+a21z6n3pLozjP4AHIQOofzJHNgz3NwDxBwASBAAAAAAABAIkCAAAAAa15z+lMT/YZ0sRDAkaL5A5tBBPIAmil+V/5AePextPvAAAAAAD+////AttabSkBAAAAIlEg0VQ1MNBHwNuDbYWtzEaEV1yANsJurWNqvZxlikhKbbKAlpgAAAAAACIAIESyacRc1GKFR/8RdvMWQ0hcAleGITHMJP6A4Kn5YBy7aQAAAAEBK4CWmAAAAAAAIgAgRLJpxFzUYoVH/xF28xZDSFwCV4YhMcwk/oDgqflgHLsiAgKeZG+54EUkYJROSfiGn5q52pCCDaXVOEGvnhJxo7z5zkcwRAIgTbB7mkwLeNWNMZ8KGkhAfQPlAEpDNMsMjvsgsmxX/h0CIE7q1xBjQufpIozPXcUBhR4twriYwziY5fpHvOF0SF4YAQEFeiECnmRvueBFJGCUTkn4hp+audqQgg2l1ThBr54ScaO8+c6sfCECjPhjrF4ODva0C5a4TGhtzXw1csjNdXHbaa+RosQTc0isk3whAg5e3aT7sUOTPQ5g8FaYHXwsinGrBji3wL+RGftLKi6+rJN8YwBnAqAyspJok1OHIgYCDl7dpPuxQ5M9DmDwVpgdfCyKcasGOLfAv5EZ+0sqLr4MZgJEIgAAAAADAAAAIgYCjPhjrF4ODva0C5a4TGhtzXw1csjNdXHbaa+RosQTc0gMqMWiOQAAAAADAAAAIgYCnmRvueBFJGCUTkn4hp+audqQgg2l1ThBr54ScaO8+c4c9azC/TAAAIABAACAAAAAgAIAAIAAAAAAAwAAAAAAAQF6IQNErDRdb7tD6XGJ4QjyaMzACUbwn/8AGVNxCUVj3cQ7BKx8IQKYR/b4Fu4MjWXF9EyG+QnYiPlCHLS1ykGRDoxKtgmwI6yTfCEDWFmN6k1JtdZZdJvss/uhomSQ3qADu/+cnFtICyVg+zGsk3xjAGcCoDKykmiTU4ciAgKYR/b4Fu4MjWXF9EyG+QnYiPlCHLS1ykGRDoxKtgmwIwyoxaI5AQAAAAEAAAAiAgNErDRdb7tD6XGJ4QjyaMzACUbwn/8AGVNxCUVj3cQ7BBz1rML9MAAAgAEAAIAAAACAAgAAgAEAAAABAAAAIgIDWFmN6k1JtdZZdJvss/uhomSQ3qADu/+cnFtICyVg+zEMZgJEIgEAAAABAAAAAA==\", \"signed\": true}\r\n```\r\n\r\n# Conclusions\r\n\r\nI hope this is interesting and I look forward to hearing your comments about whether (and how) wallet policies could be added to hwi.",
          "user": {
            "login": "bigspider",
            "id": 6681844,
            "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
            "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/bigspider",
            "html_url": "https://github.com/bigspider",
            "followers_url": "https://api.github.com/users/bigspider/followers",
            "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
            "organizations_url": "https://api.github.com/users/bigspider/orgs",
            "repos_url": "https://api.github.com/users/bigspider/repos",
            "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/bigspider/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 5,
          "pull_request": {
            "url": "https://api.github.com/repos/bitcoin-core/HWI/pulls/647",
            "html_url": "https://github.com/bitcoin-core/HWI/pull/647",
            "diff_url": "https://github.com/bitcoin-core/HWI/pull/647.diff",
            "patch_url": "https://github.com/bitcoin-core/HWI/pull/647.patch"
          },
          "created_at": "2022-11-16T13:22:46Z",
          "updated_at": "2023-09-05T19:17:02Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1199012337,
      "node_id": "PRR_kwDOAN28mc5Hd3nx",
      "url": null,
      "actor": null,
      "commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Good to see progress on this! Just a small comment about only mentioning Bitcoin Core: i know of several projects using descriptors, and even more of them using descriptors without Miniscript.",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1199012337",
      "submitted_at": "2022-11-30T10:01:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "labeled",
      "id": 8147220601,
      "node_id": "LE_lADOAN28mc5WiQDdzwAAAAHlnLh5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8147220601",
      "actor": {
        "login": "kallewoof",
        "id": 250224,
        "node_id": "MDQ6VXNlcjI1MDIyNA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/kallewoof",
        "html_url": "https://github.com/kallewoof",
        "followers_url": "https://api.github.com/users/kallewoof/followers",
        "following_url": "https://api.github.com/users/kallewoof/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/kallewoof/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/kallewoof/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
        "organizations_url": "https://api.github.com/users/kallewoof/orgs",
        "repos_url": "https://api.github.com/users/kallewoof/repos",
        "events_url": "https://api.github.com/users/kallewoof/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/kallewoof/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T01:34:43Z",
      "label": {
        "name": "New BIP",
        "color": "5319e7"
      }
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGRmYTI2NDUzZmIxOTc1YzBjOGI3OTA5ZTgyMzdhNWFjNTVmNGRkOGM",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/dfa26453fb1975c0c8b7909e8237a5ac55f4dd8c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/dfa26453fb1975c0c8b7909e8237a5ac55f4dd8c",
      "tree": {
        "sha": "1619e8a0f8af407e7b16f1d76878a57ca2b23062",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/1619e8a0f8af407e7b16f1d76878a57ca2b23062"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 1619e8a0f8af407e7b16f1d76878a57ca2b23062\nparent fd3b84da83f5b22953ab8c8cc7c2f1239026692a\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1674551664 +0100\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1674551664 +0100\n\nAllow unhardened derivation steps for key origin\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmPPoXAACgkQdAYP+Bsz\n5PjY+gwAspV5Sudc/CuJ7bt0v8xOnJJIhrP9Q1Nug68JdKF65QVuz74B+O9J/GMX\nYvXge6vyp3wLJgIsvBCQTV1EvvGWbz/ddPXPueccrbF5fzhpEiLTwpOt1xm+u4GY\nB1DakgdRQpWY3SpJMxjPott/BEhpedi0/LNbh2VtFtPfPINz2iDYGo3onB/maSMd\nR0kaulwFLydCLNqH5dwAjM15l4qp0B9oUVRQh1n35rsl4MoZtXvAYsBtQGzA9Kuh\nve3rNAV/e/bd290GfTjKeqILXhY+8NKwVI7ih1InCY8T1dM5PIfUyaFJ0Wc6bVNl\nYJGmew2BVr4PgTUPn4DrSJpnRToI1JNEWCxznx0jd3CN3LDiPVrTcb4eFdiQDZRD\nJiV0l3CtU2NmJALO+80JZo15dttc5B/Zdij9/UhfNvzqPiT0Rx82c+ACgqQWGpxy\nPsf9XOQg9HpArVb/TJoNxXxP1K7JUHSfRxNudJcWkaubiZh+qypUPHtA8/D5kN1g\nsdDIQO5e\n=OiYN\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
          "sha": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
          "html_url": "https://github.com/bitcoin/bips/commit/fd3b84da83f5b22953ab8c8cc7c2f1239026692a"
        }
      ],
      "message": "Allow unhardened derivation steps for key origin",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-01-24T09:14:24Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-01-24T09:14:24Z"
      },
      "sha": "dfa26453fb1975c0c8b7909e8237a5ac55f4dd8c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDE2MmM2NzU0MTVlZjcxN2E1OTljYzg5OWZjNGEwYjc2MTc3MTBhM2U",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/162c675415ef717a599cc899fc4a0b7617710a3e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/162c675415ef717a599cc899fc4a0b7617710a3e",
      "tree": {
        "sha": "85986061c53f1816c41966bdc77c883f35905bad",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/85986061c53f1816c41966bdc77c883f35905bad"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 85986061c53f1816c41966bdc77c883f35905bad\nparent dfa26453fb1975c0c8b7909e8237a5ac55f4dd8c\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1674551860 +0100\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1674551980 +0100\n\nNit from review\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmPPoqwACgkQdAYP+Bsz\n5Phycwv+IDlSET8XwVfbi9lgMVGSr8RepSdscca169D4+RxB9Lt+vsdoYTXi3yM2\nnePbAs0ZUVPr6kyzw7Pm3bomyqENRJCOqflNrna57JD1TQl1u3eSxjPvJmLrbJvh\nZKhM5YacQcHfaplXvc03PKQVISNafg06W68py0A4IiG4R6OCPA2PCaIGHJC35cpc\ndPrhaRGg5J+VHughryVtotAbcRbX6llapqMurL8yfvrV96zZh9IUkkCAPc4cVc6s\nXtr7lWgoowfHeL5GoisepDUZS4AZ4Ss7GBLxftcVUR0qaz8YC8qQxC+7yNrT8eLF\nb3A7n0Y/DagRVmtzxQky9x1JCkp4MM1CjM3nbTrvh0NnFvofa3Vo2jr9Z0ObKCJH\nZU8EGE7KD0A/h9aGTDNYGUuukCNigT5oIyZQoKHKqSSXh37G1sHXDANvRgmortXo\n5ADN5DI7I+9kWesY2V6DLJ3XPrjtBdrHDJxAcQlgkWfOWZQZiK9PpvRszHufp/PJ\nDxWO8z57\n=u9KR\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/dfa26453fb1975c0c8b7909e8237a5ac55f4dd8c",
          "sha": "dfa26453fb1975c0c8b7909e8237a5ac55f4dd8c",
          "html_url": "https://github.com/bitcoin/bips/commit/dfa26453fb1975c0c8b7909e8237a5ac55f4dd8c"
        }
      ],
      "message": "Nit from review",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-01-24T09:19:40Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-01-24T09:17:40Z"
      },
      "sha": "162c675415ef717a599cc899fc4a0b7617710a3e"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8342131034,
      "node_id": "HRFPE_lADOAN28mc5WiQDdzwAAAAHxOtFa",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8342131034",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-24T09:19:45Z"
    },
    {
      "event": "commented",
      "id": 1401619046,
      "node_id": "IC_kwDOAN28mc5TiwJm",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1401619046",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-24T09:25:35Z",
      "updated_at": "2023-01-24T09:25:35Z",
      "author_association": "CONTRIBUTOR",
      "body": "In dfa26453fb1975c0c8b7909e8237a5ac55f4dd8c, I added the possibility of using unhardened derivation steps in the key origin information (while keeping the restriction for `change`/`address_index` in the key placeholders).\r\nWhile most wallets use hardened derivations for all but the last two steps, there are deployed use cases with unhardened derivations, and this only adds negligible implementation complexity to wallet policies.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1401619046",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "referenced",
      "id": 8502859196,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAH6z1W8",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8502859196",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "873942a31c00ab2cf6a0f679b763bf053c18db2c",
      "commit_url": "https://api.github.com/repos/ElementsProject/libwally-core/commits/873942a31c00ab2cf6a0f679b763bf053c18db2c",
      "created_at": "2023-02-13T10:41:30Z"
    },
    {
      "event": "referenced",
      "id": 8502902787,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAH60AAD",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8502902787",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "9883c6ca10fd4fdd5653cdf2281f366a9adfd1db",
      "commit_url": "https://api.github.com/repos/ElementsProject/libwally-core/commits/9883c6ca10fd4fdd5653cdf2281f366a9adfd1db",
      "created_at": "2023-02-13T10:46:03Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-13T11:15:32Z",
      "updated_at": "2023-02-13T11:15:32Z",
      "source": {
        "issue": {
          "id": 1582155399,
          "node_id": "PR_kwDOBawtqs5J1vJJ",
          "url": "https://api.github.com/repos/ElementsProject/libwally-core/issues/369",
          "repository_url": "https://api.github.com/repos/ElementsProject/libwally-core",
          "labels_url": "https://api.github.com/repos/ElementsProject/libwally-core/issues/369/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/ElementsProject/libwally-core/issues/369/comments",
          "events_url": "https://api.github.com/repos/ElementsProject/libwally-core/issues/369/events",
          "html_url": "https://github.com/ElementsProject/libwally-core/pull/369",
          "number": 369,
          "state": "open",
          "state_reason": null,
          "title": "WIP: descriptor: Implement wallet-policies BIP",
          "body": "See https://github.com/bitcoin/bips/pull/1389 for details of wallet policies.\r\n\r\nNote wally implements the `/*` extension to support non-BIP44 wallets such as Blockstream Green. Additionally, we do not limit allowable policies to the whitelist in the linked BIP. We allow all valid descriptors where the solved cardinality is either 1 or 2.",
          "user": {
            "login": "jgriffiths",
            "id": 406223,
            "node_id": "MDQ6VXNlcjQwNjIyMw==",
            "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/jgriffiths",
            "html_url": "https://github.com/jgriffiths",
            "followers_url": "https://api.github.com/users/jgriffiths/followers",
            "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
            "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
            "repos_url": "https://api.github.com/users/jgriffiths/repos",
            "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "locked": false,
          "comments": 0,
          "pull_request": {
            "url": "https://api.github.com/repos/ElementsProject/libwally-core/pulls/369",
            "html_url": "https://github.com/ElementsProject/libwally-core/pull/369",
            "diff_url": "https://github.com/ElementsProject/libwally-core/pull/369.diff",
            "patch_url": "https://github.com/ElementsProject/libwally-core/pull/369.patch"
          },
          "created_at": "2023-02-13T11:15:32Z",
          "updated_at": "2023-09-07T12:21:49Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1295456080,
      "node_id": "PRR_kwDOAN28mc5NNxdQ",
      "url": null,
      "actor": null,
      "commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "",
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1295456080",
      "submitted_at": "2023-02-13T11:52:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "reviewed",
      "id": 1300535952,
      "node_id": "PRR_kwDOAN28mc5NhJqQ",
      "url": null,
      "actor": null,
      "commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "bucko13",
        "id": 4344978,
        "node_id": "MDQ6VXNlcjQzNDQ5Nzg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4344978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bucko13",
        "html_url": "https://github.com/bucko13",
        "followers_url": "https://api.github.com/users/bucko13/followers",
        "following_url": "https://api.github.com/users/bucko13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bucko13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bucko13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bucko13/subscriptions",
        "organizations_url": "https://api.github.com/users/bucko13/orgs",
        "repos_url": "https://api.github.com/users/bucko13/repos",
        "events_url": "https://api.github.com/users/bucko13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bucko13/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1300535952",
      "submitted_at": "2023-02-15T23:41:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGRhM2UxMTdkMDc1ZjQ0MjhmMTRkNDEyMDEyNGQ4NDA2ODJlNTU4N2Q",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/da3e117d075f4428f14d4120124d840682e5587d",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/da3e117d075f4428f14d4120124d840682e5587d",
      "tree": {
        "sha": "c5f671d2d8adb2d4fa3bddb8fe138ea5fbc272f5",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/c5f671d2d8adb2d4fa3bddb8fe138ea5fbc272f5"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree c5f671d2d8adb2d4fa3bddb8fe138ea5fbc272f5\nparent 162c675415ef717a599cc899fc4a0b7617710a3e\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1676967888 +0100\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1676968203 +0100\n\nAddress review comments\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmP0gQsACgkQdAYP+Bsz\n5PiGDAv/QTHw4z/XIYqupeNE5M/lLYV7Mk8bpZKZMGrDgxjMpVcHJX3neS08sFJu\nj5m1FsFGUF2Flx/WD3WpNGqIkSdTDKUSrysqFwsHmkTD5HO4dX02Kgxgt/Jf1/BV\npCr7jxIafAcUacebKdueZ9tTCvohgLOF2JmVlE9wu75IoQmZbrRZ4XAnfK2AHymO\nmIkX9R/PgBhcYDOwYRYl1hIpuifTU5WMkCWd5TixXGIMnacsdOTG98/e/57z1whk\n+KheKweyO5Nihq5+IUH+fumCS6VDYkkw8DOJ9SVE5+oYS/VZ3upt9gIow1h68fSh\nYuZtq4lb5s/x0qXAo24d9ZQ3YNiD+jnpZL1Zt59dkkku0YtlGgYEhRxZrtKeuUG5\nWSndE5wjGP8o260gm3XzpSZ5bTA1Ea0i6eotSWGWXeHPS1K6MioKv+mEZgYqfeji\n5ZFQelE6P9Pn9MYUjQo/UtCcDEXEvS1Y8n/y6mejRIzHrzVMbK9wOMB52AYKWb5v\nfy0ozTcJ\n=gJGz\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/162c675415ef717a599cc899fc4a0b7617710a3e",
          "sha": "162c675415ef717a599cc899fc4a0b7617710a3e",
          "html_url": "https://github.com/bitcoin/bips/commit/162c675415ef717a599cc899fc4a0b7617710a3e"
        }
      ],
      "message": "Address review comments",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-02-21T08:30:03Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-02-21T08:24:48Z"
      },
      "sha": "da3e117d075f4428f14d4120124d840682e5587d"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKGJiOThmODAxN2E4ODMyNjJlMDMxMjdhYjcxODUxNGFiZjRhNWU1Zjk",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/bb98f8017a883262e03127ab718514abf4a5e5f9",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/bb98f8017a883262e03127ab718514abf4a5e5f9",
      "tree": {
        "sha": "8dba47d01870227b905cbdd821d0e0085f883f2c",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/8dba47d01870227b905cbdd821d0e0085f883f2c"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 8dba47d01870227b905cbdd821d0e0085f883f2c\nparent da3e117d075f4428f14d4120124d840682e5587d\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1676968058 +0100\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1676968204 +0100\n\nRemoved examples with HTLCs: not very meaningful as wallet policies\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmP0gQwACgkQdAYP+Bsz\n5PjUZwwAoJm3x7nUP0S7qV2u9o3TLWLE8s0/58wICT1aeUVVu1tmsCGyry5E+nAZ\nyscjUedfg135J8zsRcObCFD2SmBe0btWw9J5aaWOLpryxeJFUpyQNRys1O85+8MQ\neZL/vkCwxGROaRJYYx2Yhse76K1sxOXFWZFE0MyneCZymMtE/KxgjTSZxrVgLUKs\nH+NTNC1gEPPPQrliMVFNaQFRKpTiN9zcJpiPDwrDlldEAkr8Y1/IQdyja39LVaTv\nSqVAJ1uqtXQ8AK2mN8RBbRz2AWMAM6Gbxvk8j29IPvIdtmuDnbMEm4XqStJx+ULg\n0JoY2TuoVqWHQv07+X7X5xEZy1G27CweBJv4DIPYk2qEQ64csCeD2KiyBAMkzCqa\nrIBo21nGVcSIl/YIA1sGpMdiYE/IXbxv2P1rDh3NcAeBQS9Whah4CPqeepMMrG1I\nDNYOId8HojP5sY+9tgNsvRBCvHU+oDg4CSwwFSufcuWle5PnjLANUXk3h5IFUK5Q\nLHDqpWvh\n=5NLq\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/da3e117d075f4428f14d4120124d840682e5587d",
          "sha": "da3e117d075f4428f14d4120124d840682e5587d",
          "html_url": "https://github.com/bitcoin/bips/commit/da3e117d075f4428f14d4120124d840682e5587d"
        }
      ],
      "message": "Removed examples with HTLCs: not very meaningful as wallet policies",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-02-21T08:30:04Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-02-21T08:27:38Z"
      },
      "sha": "bb98f8017a883262e03127ab718514abf4a5e5f9"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8568161101,
      "node_id": "HRFPE_lADOAN28mc5WiQDdzwAAAAH-s8NN",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8568161101",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:30:09Z"
    },
    {
      "event": "commented",
      "id": 1438086314,
      "node_id": "IC_kwDOAN28mc5Vt3Sq",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1438086314",
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:55:05Z",
      "updated_at": "2023-02-21T08:55:05Z",
      "author_association": "CONTRIBUTOR",
      "body": "Thanks @jgriffiths and @bucko13 for the reviews!\r\nI addressed most of the comments in da3e117d075f4428f14d4120124d840682e5587d.\r\n\r\nIn bb98f8017a883262e03127ab718514abf4a5e5f9 I deleted the examples coming from HTLC miniscripts; they don't quite make sense as wallet policies.",
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1438086314",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 8568390758,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAH-t0Rm",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8568390758",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:55:06Z"
    },
    {
      "event": "subscribed",
      "id": 8568390779,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAH-t0R7",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8568390779",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:55:06Z"
    },
    {
      "event": "mentioned",
      "id": 8568390809,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAH-t0SZ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8568390809",
      "actor": {
        "login": "bucko13",
        "id": 4344978,
        "node_id": "MDQ6VXNlcjQzNDQ5Nzg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4344978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bucko13",
        "html_url": "https://github.com/bucko13",
        "followers_url": "https://api.github.com/users/bucko13/followers",
        "following_url": "https://api.github.com/users/bucko13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bucko13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bucko13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bucko13/subscriptions",
        "organizations_url": "https://api.github.com/users/bucko13/orgs",
        "repos_url": "https://api.github.com/users/bucko13/repos",
        "events_url": "https://api.github.com/users/bucko13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bucko13/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:55:06Z"
    },
    {
      "event": "subscribed",
      "id": 8568390849,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAH-t0TB",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/8568390849",
      "actor": {
        "login": "bucko13",
        "id": 4344978,
        "node_id": "MDQ6VXNlcjQzNDQ5Nzg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4344978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bucko13",
        "html_url": "https://github.com/bucko13",
        "followers_url": "https://api.github.com/users/bucko13/followers",
        "following_url": "https://api.github.com/users/bucko13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bucko13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bucko13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bucko13/subscriptions",
        "organizations_url": "https://api.github.com/users/bucko13/orgs",
        "repos_url": "https://api.github.com/users/bucko13/repos",
        "events_url": "https://api.github.com/users/bucko13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bucko13/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:55:06Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-15T03:13:22Z",
      "updated_at": "2023-04-15T03:13:22Z",
      "source": {
        "issue": {
          "id": 1616152538,
          "node_id": "PR_kwDOB0Kp2s5Lnhw-",
          "url": "https://api.github.com/repos/lightningdevkit/rust-lightning/issues/2089",
          "repository_url": "https://api.github.com/repos/lightningdevkit/rust-lightning",
          "labels_url": "https://api.github.com/repos/lightningdevkit/rust-lightning/issues/2089/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/lightningdevkit/rust-lightning/issues/2089/comments",
          "events_url": "https://api.github.com/repos/lightningdevkit/rust-lightning/issues/2089/events",
          "html_url": "https://github.com/lightningdevkit/rust-lightning/pull/2089",
          "number": 2089,
          "state": "closed",
          "state_reason": null,
          "title": "Add BumpTransaction event handler",
          "body": "This allows users to bump their commitments and HTLC transactions without having to worry about all the little details to do so. Instead, we'll just require them to implement a small shim over their wallet/UTXO source, that grants the event handler permission to spend confirmed UTXOs for the transactions it'll produce.\r\n\r\nWhile the event handler should in most cases produce valid transactions, assuming the provided confirmed UTXOs are valid, it may not produce relayable transactions due to not satisfying certain Replace-By-Fee (RBF) mempool policy requirements. Some of these require that the replacement transactions have a higher feerate and absolute fee than the conflicting transactions it aims to replace. To make sure we adhere to these requirements, we'd have to persist some state for all transactions the event handler has produced, greatly increasing its complexity. While we may consider implementing so in the future, we choose to go with a simple initial version that relies on the `OnchainTxHandler`'s bumping frequency. For each new bumping attempt, the `OnchainTxHandler` proposes a 25% feerate increase to ensure transactions can propagate under constrained mempool circumstances.",
          "user": {
            "login": "wpaulino",
            "id": 9447167,
            "node_id": "MDQ6VXNlcjk0NDcxNjc=",
            "avatar_url": "https://avatars.githubusercontent.com/u/9447167?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/wpaulino",
            "html_url": "https://github.com/wpaulino",
            "followers_url": "https://api.github.com/users/wpaulino/followers",
            "following_url": "https://api.github.com/users/wpaulino/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/wpaulino/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/wpaulino/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/wpaulino/subscriptions",
            "organizations_url": "https://api.github.com/users/wpaulino/orgs",
            "repos_url": "https://api.github.com/users/wpaulino/repos",
            "events_url": "https://api.github.com/users/wpaulino/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/wpaulino/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [
            {
              "id": 4885474239,
              "node_id": "LA_kwDOB0Kp2s8AAAABIzJrvw",
              "url": "https://api.github.com/repos/lightningdevkit/rust-lightning/labels/Anchor%20Support",
              "name": "Anchor Support",
              "description": "",
              "color": "FA9362",
              "default": false
            }
          ],
          "assignees": [],
          "author_association": "CONTRIBUTOR",
          "milestone": {
            "url": "https://api.github.com/repos/lightningdevkit/rust-lightning/milestones/33",
            "html_url": "https://github.com/lightningdevkit/rust-lightning/milestone/33",
            "labels_url": "https://api.github.com/repos/lightningdevkit/rust-lightning/milestones/33/labels",
            "id": 9193181,
            "node_id": "MI_kwDOB0Kp2s4AjEbd",
            "number": 33,
            "state": "closed",
            "title": "0.0.116",
            "description": "Anchoring the Roadmap",
            "creator": {
              "login": "TheBlueMatt",
              "id": 649246,
              "node_id": "MDQ6VXNlcjY0OTI0Ng==",
              "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/TheBlueMatt",
              "html_url": "https://github.com/TheBlueMatt",
              "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
              "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
              "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
              "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
              "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
              "type": "User",
              "site_admin": false
            },
            "open_issues": 0,
            "closed_issues": 71,
            "created_at": "2023-03-22T18:26:54Z",
            "updated_at": "2023-07-22T03:03:33Z",
            "closed_at": "2023-07-22T03:03:14Z"
          },
          "locked": false,
          "comments": 7,
          "pull_request": {
            "url": "https://api.github.com/repos/lightningdevkit/rust-lightning/pulls/2089",
            "html_url": "https://github.com/lightningdevkit/rust-lightning/pull/2089",
            "diff_url": "https://github.com/lightningdevkit/rust-lightning/pull/2089.diff",
            "patch_url": "https://github.com/lightningdevkit/rust-lightning/pull/2089.patch"
          },
          "closed_at": "2023-06-19T22:45:56Z",
          "created_at": "2023-03-08T23:41:05Z",
          "updated_at": "2023-06-20T19:20:36Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-02T13:02:46Z",
      "updated_at": "2023-05-02T13:02:46Z",
      "source": {
        "issue": {
          "id": 1683144023,
          "node_id": "I_kwDOF72rbM5kUr1X",
          "url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/153",
          "repository_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new",
          "labels_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/153/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/153/comments",
          "events_url": "https://api.github.com/repos/LedgerHQ/app-bitcoin-new/issues/153/events",
          "html_url": "https://github.com/LedgerHQ/app-bitcoin-new/issues/153",
          "number": 153,
          "state": "open",
          "state_reason": null,
          "title": "2-of-2 multisig spends without co-signer key constraint",
          "body": "I am investigating the possibility of signing transactions of the following type using a ledger device:\r\n\r\n`multi(2, @0, <any>)` -> external destination\r\n\r\nThe user would only verify the external destination on the screen. `@0` is the ledger device key. The co-signer key `<any>` is any key, no restrictions. Because there are no outputs to a multisig address, it seems the usual security concerns do not apply here.\r\n\r\nI tend to think that this shouldn't require a registered wallet policy, but is that possible with the current version of `app-bitcoin-new`?",
          "user": {
            "login": "joostjager",
            "id": 4638168,
            "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
            "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/joostjager",
            "html_url": "https://github.com/joostjager",
            "followers_url": "https://api.github.com/users/joostjager/followers",
            "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
            "organizations_url": "https://api.github.com/users/joostjager/orgs",
            "repos_url": "https://api.github.com/users/joostjager/repos",
            "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/joostjager/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignees": [],
          "author_association": "NONE",
          "locked": false,
          "comments": 20,
          "created_at": "2023-04-25T13:07:54Z",
          "updated_at": "2023-05-15T08:31:06Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "reviewed",
      "id": 1409290224,
      "node_id": "PRR_kwDOAN28mc5UAA_w",
      "url": null,
      "actor": null,
      "commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1409290224",
      "submitted_at": "2023-05-02T14:54:22Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "reviewed",
      "id": 1409307273,
      "node_id": "PRR_kwDOAN28mc5UAFKJ",
      "url": null,
      "actor": null,
      "commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1409307273",
      "submitted_at": "2023-05-02T15:02:34Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "reviewed",
      "id": 1476612443,
      "node_id": "PRR_kwDOAN28mc5YA1Fb",
      "url": null,
      "actor": null,
      "commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#pullrequestreview-1476612443",
      "submitted_at": "2023-06-13T08:49:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
    },
    {
      "event": "referenced",
      "id": 9574418529,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI6rghh",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9574418529",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "08845763542f78f068031e66f36b5167d87b6782",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/08845763542f78f068031e66f36b5167d87b6782",
      "created_at": "2023-06-20T03:18:04Z"
    },
    {
      "event": "referenced",
      "id": 9574418538,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI6rghq",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9574418538",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "996cb79f357a7304c6ce3477c78e9726592ffc12",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/996cb79f357a7304c6ce3477c78e9726592ffc12",
      "created_at": "2023-06-20T03:18:04Z"
    },
    {
      "event": "referenced",
      "id": 9574425845,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI6riT1",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9574425845",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "59b047a96f92203a89e22b9cd1adc1fe648cfd43",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/59b047a96f92203a89e22b9cd1adc1fe648cfd43",
      "created_at": "2023-06-20T03:20:17Z"
    },
    {
      "event": "referenced",
      "id": 9574443465,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI6rmnJ",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9574443465",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "78671aec91f39690a463835670320784815eae4c",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/78671aec91f39690a463835670320784815eae4c",
      "created_at": "2023-06-20T03:25:29Z"
    },
    {
      "event": "referenced",
      "id": 9574449109,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI6rn_V",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9574449109",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "0468931b933eb39676ca48f1e5b0a655e6054982",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/0468931b933eb39676ca48f1e5b0a655e6054982",
      "created_at": "2023-06-20T03:27:09Z"
    },
    {
      "event": "referenced",
      "id": 9583233465,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI7NIm5",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9583233465",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "0a88519fe2ad1e109278e34d20cbf8acd7a4c5ab",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/0a88519fe2ad1e109278e34d20cbf8acd7a4c5ab",
      "created_at": "2023-06-20T18:57:39Z"
    },
    {
      "event": "referenced",
      "id": 9583233496,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI7NInY",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9583233496",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "4069cb5c352c4f6007b8766972194536cbd005ea",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/4069cb5c352c4f6007b8766972194536cbd005ea",
      "created_at": "2023-06-20T18:57:40Z"
    },
    {
      "event": "referenced",
      "id": 9583687445,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAI7O3cV",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9583687445",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "808dc7c3ffb925176751129d8f3c8aa452d24f81",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/808dc7c3ffb925176751129d8f3c8aa452d24f81",
      "created_at": "2023-06-20T19:50:51Z"
    },
    {
      "event": "referenced",
      "id": 9671202515,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAJActbT",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9671202515",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "5196443f10052be0ac4317d23f9ad3c422263368",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/5196443f10052be0ac4317d23f9ad3c422263368",
      "created_at": "2023-06-29T00:14:49Z"
    },
    {
      "event": "referenced",
      "id": 9671202524,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAJActbc",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/9671202524",
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "5625aec043480ea48c9cf6e1a8d6d7ac032008d3",
      "commit_url": "https://api.github.com/repos/benma/bitbox02-firmware/commits/5625aec043480ea48c9cf6e1a8d6d7ac032008d3",
      "created_at": "2023-06-29T00:14:49Z"
    },
    {
      "event": "cross-referenced",
      "id": null,
      "node_id": null,
      "url": null,
      "actor": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-07-11T13:06:23Z",
      "updated_at": "2023-07-11T13:06:23Z",
      "source": {
        "issue": {
          "id": 1227630855,
          "node_id": "I_kwDOC1uO3M5JLCkH",
          "url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware/issues/911",
          "repository_url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware",
          "labels_url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware/issues/911/labels%7B/name%7D",
          "comments_url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware/issues/911/comments",
          "events_url": "https://api.github.com/repos/digitalbitbox/bitbox02-firmware/issues/911/events",
          "html_url": "https://github.com/digitalbitbox/bitbox02-firmware/issues/911",
          "number": 911,
          "state": "open",
          "state_reason": null,
          "title": "Output Script Descriptor (with Miniscript) support",
          "body": "[Output Script Descriptor](https://github.com/bitcoin/bips/blob/master/bip-0380.mediawiki#motivation) are a sane standard for wallet backups. They express all the information necessary to locate owned (or partially owned) outputs in an engineer-readable format, avoiding the pitfalls of previously used implicit hacks to recover only from a mnemonic.\r\n\r\n[Miniscript](https://bitcoin.sipa.be/miniscript/) is an extension to Output Script Descriptors, which defines a language to reason about a subset of Script. Miniscript allows to:\r\n1. Safely write more complicated contracts than the basic well-known templates\r\n2. Produce a valid witness for any Script that is a valid Miniscript, given the necessary material (signature, etc)\r\n3. Statically analyse the properties of any Script that is a valid Miniscript: determine the semantics of the contract, whether it is non-malleable, whether some spending paths may exceed standardness or consensus limits --in short, whether it's safe to participate in such a Script.\r\n\r\nMiniscript also guarantees consensus soundness (unless the conditions of the Miniscript are met, no witness can be created for the Script) and standardness completeness (for any Miniscript that was analysed as sane, a witness can be constructed in the bounds of the consensus and standardness rules).\r\n\r\nOutput Script Descriptors along with Miniscript are particularly appealing to signing devices, as it permits the user of this device to safely take part in more complex contracts. It also gives a framework to add support for new Scripts, instead of relying on hard-coded Script templates and footgun-y backup solutions.\r\n\r\nOutput descriptors have been in Bitcoin Core for a while now, and [Miniscript was merged into Bitcoin Core](https://github.com/bitcoin/bitcoin/pull/24147) mainline this year. The [Specter](https://github.com/cryptoadvance/specter-diy) signing device added support for Output descriptors and Miniscript more than a year ago. [Ledger added support](https://blog.ledger.com/bitcoin-2/) for (a subset of) output descriptors last year and is [currently working toward Miniscript](https://blog.ledger.com/miniscript-is-coming/) support.\r\nIs there any plan to implement to implement Output Script Descriptors (with Miniscript) for the Bitbox2?",
          "user": {
            "login": "darosior",
            "id": 22457751,
            "node_id": "MDQ6VXNlcjIyNDU3NzUx",
            "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/darosior",
            "html_url": "https://github.com/darosior",
            "followers_url": "https://api.github.com/users/darosior/followers",
            "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
            "organizations_url": "https://api.github.com/users/darosior/orgs",
            "repos_url": "https://api.github.com/users/darosior/repos",
            "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/darosior/received_events",
            "type": "User",
            "site_admin": false
          },
          "labels": [],
          "assignee": {
            "login": "benma",
            "id": 1225267,
            "node_id": "MDQ6VXNlcjEyMjUyNjc=",
            "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
            "gravatar_id": "",
            "url": "https://api.github.com/users/benma",
            "html_url": "https://github.com/benma",
            "followers_url": "https://api.github.com/users/benma/followers",
            "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
            "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
            "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
            "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
            "organizations_url": "https://api.github.com/users/benma/orgs",
            "repos_url": "https://api.github.com/users/benma/repos",
            "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
            "received_events_url": "https://api.github.com/users/benma/received_events",
            "type": "User",
            "site_admin": false
          },
          "assignees": [
            {
              "login": "benma",
              "id": 1225267,
              "node_id": "MDQ6VXNlcjEyMjUyNjc=",
              "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
              "gravatar_id": "",
              "url": "https://api.github.com/users/benma",
              "html_url": "https://github.com/benma",
              "followers_url": "https://api.github.com/users/benma/followers",
              "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
              "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
              "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
              "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
              "organizations_url": "https://api.github.com/users/benma/orgs",
              "repos_url": "https://api.github.com/users/benma/repos",
              "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
              "received_events_url": "https://api.github.com/users/benma/received_events",
              "type": "User",
              "site_admin": false
            }
          ],
          "author_association": "NONE",
          "locked": false,
          "comments": 3,
          "created_at": "2022-05-06T09:30:42Z",
          "updated_at": "2023-07-11T13:06:28Z"
        },
        "type": "issue"
      }
    },
    {
      "event": "commented",
      "id": 1671755616,
      "node_id": "IC_kwDOAN28mc5jpPdg",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/comments/1671755616",
      "actor": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T16:27:39Z",
      "updated_at": "2023-08-09T16:27:39Z",
      "author_association": "MEMBER",
      "body": "@luke-jr can this be assigned a BIP number?",
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bips/pull/1389#issuecomment-1671755616",
      "issue_url": "https://api.github.com/repos/bitcoin/bips/issues/1389"
    },
    {
      "event": "mentioned",
      "id": 10049842647,
      "node_id": "MEE_lADOAN28mc5WiQDdzwAAAAJXBG3X",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10049842647",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T16:27:40Z"
    },
    {
      "event": "subscribed",
      "id": 10049842660,
      "node_id": "SE_lADOAN28mc5WiQDdzwAAAAJXBG3k",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10049842660",
      "actor": {
        "login": "luke-jr",
        "id": 1095675,
        "node_id": "MDQ6VXNlcjEwOTU2NzU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1095675?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/luke-jr",
        "html_url": "https://github.com/luke-jr",
        "followers_url": "https://api.github.com/users/luke-jr/followers",
        "following_url": "https://api.github.com/users/luke-jr/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/luke-jr/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/luke-jr/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/luke-jr/subscriptions",
        "organizations_url": "https://api.github.com/users/luke-jr/orgs",
        "repos_url": "https://api.github.com/users/luke-jr/repos",
        "events_url": "https://api.github.com/users/luke-jr/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/luke-jr/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-08-09T16:27:40Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDljMjY2OTk5ZTFlNzkzYzZiNGU2YmUyMTFiMzlmNTBlZTljN2E5YWI",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/9c266999e1e793c6b4e6be211b39f50ee9c7a9ab",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/9c266999e1e793c6b4e6be211b39f50ee9c7a9ab",
      "tree": {
        "sha": "ff27569eca6f509348155e43543974e787ee41c4",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/ff27569eca6f509348155e43543974e787ee41c4"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree ff27569eca6f509348155e43543974e787ee41c4\nparent bb98f8017a883262e03127ab718514abf4a5e5f9\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1693929586 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1693929586 +0200\n\nFix test vectors with missing /** in placeholders\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmT3UHIACgkQdAYP+Bsz\n5PjO1QwAs7levLvz8P3avcojTXK2rTSa4y/ZbEYnqGUxlbE6EYPPiAtpJRKwGIKw\n7Rcksdr5vv73Ji4ipjR853FRdguRUO+0mGt3YL6VC0jsJ69u5lBE5GePFfvQ9wAD\nJffygUyXMOiQhtCsohaTTEu/zN3wysFJX+19dEIdaQUAGVAjIYzjGqWtBWzhrGoz\nhzoiwfb2rBHnG7coFva6dVYwhdeSirtZIxWXc7nJBuMpPxAqU0yDGRvCej6Gx8vB\nMRUatZIgINpwKrIh8uEfwhZ9SUF5AVWw53s4aS4487gNTENSOyfFdoqICJqgenVX\nhCbsHUe/88bYnS+DtMFvu3tshWwv9PoeHCSD+pM3+rwdi1GjRnP6R/DUyiaHvnTl\nOnfNtp5rDM8y30I5Of1CIY7u9hEYTMu2iOckHUQk10pui2bsJEiy0c6t2Cl4dOSI\nx3eRp9kXoftREuKXUbKC3kIdr53DAI78Sgo7T9eqaIjo/wA+D0qKj54z8tplOIQP\nBVb+ta8o\n=gn5I\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/bb98f8017a883262e03127ab718514abf4a5e5f9",
          "sha": "bb98f8017a883262e03127ab718514abf4a5e5f9",
          "html_url": "https://github.com/bitcoin/bips/commit/bb98f8017a883262e03127ab718514abf4a5e5f9"
        }
      ],
      "message": "Fix test vectors with missing /** in placeholders",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-09-05T15:59:46Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-09-05T15:59:46Z"
      },
      "sha": "9c266999e1e793c6b4e6be211b39f50ee9c7a9ab"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDk1NTdiMWQwMWNjMzkyZTg5NTZiNDE4NGIyZmZhMTZhMjljZWRhYjM",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/9557b1d01cc392e8956b4184b2ffa16a29cedab3",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/9557b1d01cc392e8956b4184b2ffa16a29cedab3",
      "tree": {
        "sha": "d79bc403f70fa84e36c9768dee36a19c5c6b988d",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/d79bc403f70fa84e36c9768dee36a19c5c6b988d"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree d79bc403f70fa84e36c9768dee36a19c5c6b988d\nparent 9c266999e1e793c6b4e6be211b39f50ee9c7a9ab\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1693929777 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1693929777 +0200\n\nMention BitBox firmware release among implementations\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmT3UTEACgkQdAYP+Bsz\n5Phtqgv/aOCbz9OiMMKvDg1ssIZtYYUbDhHORcCQZtBEjukxyfXFy7gn3Q8krPVd\n9sjfEqLIBMrvB/OraOCHVNCqcDOmhTo7jKzXs9DowTOSIZ+w+FX6W5QFydVgbo5O\nDT0CSfE2N5tCKbEmhbozeEV6XRAGZOa2uWo/oF7DRoBRcbScMgIQfBnx7nK4HuEl\n3wx+JrMdbP4I2oMZqk+qDzAOKIaSWY04ejZrgiZHiErVAe/NwWwetcyp1YyVoteD\nYT/8oJcCZo3x6psiSaEJw2TGozLWCteNDOFUpbw+bA16rkKVW9lMdMJxGhjJw4ID\nVlnA14Gl6qX3umkEhlxp6PFCegGM9tluX4euyQvh6YTMbrqVNmwbwGPfXIMgmRyo\nQR8kR7S37ZUUEZ03pgq5EskPendW4tWlwcGUstdQtW+ielQTPXuDw2zn1j8qyQcj\n+GaEB7e8RJNOKarP6Ubal51gUIJHuKPkhjrPDAPTiS/ilBtNrzICGAggR6WmDzSS\nrgn+POuP\n=GVWN\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/9c266999e1e793c6b4e6be211b39f50ee9c7a9ab",
          "sha": "9c266999e1e793c6b4e6be211b39f50ee9c7a9ab",
          "html_url": "https://github.com/bitcoin/bips/commit/9c266999e1e793c6b4e6be211b39f50ee9c7a9ab"
        }
      ],
      "message": "Mention BitBox firmware release among implementations",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-09-05T16:02:57Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-09-05T16:02:57Z"
      },
      "sha": "9557b1d01cc392e8956b4184b2ffa16a29cedab3"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDAzM2U5NGQ5MWMxOTE3ODY4YTYyN2FlYjc0MDAzZmZjZWE2Nzg4NTY",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/033e94d91c1917868a627aeb74003ffcea678856",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/033e94d91c1917868a627aeb74003ffcea678856",
      "tree": {
        "sha": "16d69a53dd6d2c3b3a8c1564525310b951fccf77",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/16d69a53dd6d2c3b3a8c1564525310b951fccf77"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 16d69a53dd6d2c3b3a8c1564525310b951fccf77\nparent 9557b1d01cc392e8956b4184b2ffa16a29cedab3\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1693992142 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1693992142 +0200\n\nRemove redundant additional rule (impossible as per specs)\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmT4RM4ACgkQdAYP+Bsz\n5PjlhQv8CxPo7bXJNc685SgjrVjt6KxEPir85APu8KIoX0VFiiE/NjJ95aMWu6Fr\njnzJac0p6oKoakPormtO7Zr1k0tBOiEIcqa01eYDFiXEvSL5l/aIGmdVTgmtwtht\n8gT0oTYfwcnWY5Ncf3kCeyM684wLaI0SkJbUoBtj9l0+tkwYie28FdnKA+3DdJtu\nZ/aBZJnkKLg6KKJU5xo5R9RWIpeGQtAAqozq4GAtOB81Ac8ZDonJMIyqW/R4uKEv\nUyLx0Eui02IbRmCr+hZpt1vgxhva+pErhi87tHJNUAb7Opy/yisJtZwikdc7ngAu\nULmL6TUXbzujKWS0kf/gpCy+q3NSProwZVogTABiQOKtMmzNwsvqzEk4jCotjheO\nsbvGyVcu1gGuRsdzPlJ7Jx/l22VFkshL4kVKS0NcXN1gmtPFR4aho9+zhKwr8Jks\nItxzYqEm7LmPsA/SYi/vFAccYHvvJZxnc+yvfbIxtWHhfG4YvyOC8yXCWGdJdcAy\n+/ZCfSTT\n=N1HG\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/9557b1d01cc392e8956b4184b2ffa16a29cedab3",
          "sha": "9557b1d01cc392e8956b4184b2ffa16a29cedab3",
          "html_url": "https://github.com/bitcoin/bips/commit/9557b1d01cc392e8956b4184b2ffa16a29cedab3"
        }
      ],
      "message": "Remove redundant additional rule (impossible as per specs)",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-09-06T09:22:22Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-09-06T09:22:22Z"
      },
      "sha": "033e94d91c1917868a627aeb74003ffcea678856"
    },
    {
      "event": "referenced",
      "id": 10294491363,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAJlmXjj",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10294491363",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "2dff714959917b44043e033469f9d876951bb81a",
      "commit_url": "https://api.github.com/repos/ElementsProject/libwally-core/commits/2dff714959917b44043e033469f9d876951bb81a",
      "created_at": "2023-09-06T11:08:33Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDNhZGU0MWZjNmJjMTI0NjEzODhmMzRkNWFlYmU5YmE2MGEwMDg3MDQ",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/3ade41fc6bc12461388f34d5aebe9ba60a008704",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/3ade41fc6bc12461388f34d5aebe9ba60a008704",
      "tree": {
        "sha": "24f15fef94a2329e088b602d3c3015170c9f4e47",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/24f15fef94a2329e088b602d3c3015170c9f4e47"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 24f15fef94a2329e088b602d3c3015170c9f4e47\nparent 033e94d91c1917868a627aeb74003ffcea678856\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1693993602 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1694006973 +0200\n\nClarify rules to avoid key reuse\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmT4fr0ACgkQdAYP+Bsz\n5PiKEgv9HHtlgQxyYE68z3sDK/zQfWu6GVNswcFPiWEulF4zRB2wpwfxGSetIIvK\n7VNppfat4bdSCytk4z7c1+l+91zPIgyzhbZen9Lp78qQQ9cCX45Kh6sXFdyi8pGo\nmA0Uk4HELK800MqwlK7Yqu9wrhoW99Q2wSpbytEtiYz4jMT/+nmRqtPLHrpmAuJ9\nb339/iBWEoktw8kVWMNYPvZ0d91lHoKSx7PD9M2dD8SNUddc3Cp2pvNBkxjC7S7U\n2ATchh7WAPLTocVH4dDYEfTu09zk5bv8i1lxlBVU/QxYlGGG84VewZLtRIAuwXWP\nDipBIHVqlS9CwnykI7jS7Xb9oziELWixZPFIMiAce+McghTjRzxcHpTx1KDXOA25\nyrCB7TfNMP+9pEG6HCLGIqb8tR20z1Ul8Q3sF5rfaOSuNOnFt1D0pHrW7io5qGcF\nsvezI0OL2yKVw8Mg5k9llhA8pDqHaGFuwr7uc+buzk/ahzUCRzuHMqJVfUf7ltFt\n+Osh2Rj+\n=OFPB\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/033e94d91c1917868a627aeb74003ffcea678856",
          "sha": "033e94d91c1917868a627aeb74003ffcea678856",
          "html_url": "https://github.com/bitcoin/bips/commit/033e94d91c1917868a627aeb74003ffcea678856"
        }
      ],
      "message": "Clarify rules to avoid key reuse",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-09-06T13:29:33Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-09-06T09:46:42Z"
      },
      "sha": "3ade41fc6bc12461388f34d5aebe9ba60a008704"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDBkNmUwNzc4MWUxN2E0ZWU4YjIwOGIzYWVhNTk4NWZlZDdhYzJjYmM",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/0d6e07781e17a4ee8b208b3aea5985fed7ac2cbc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/0d6e07781e17a4ee8b208b3aea5985fed7ac2cbc",
      "tree": {
        "sha": "4c297771e39ca0243d6d0408f9567b1e9e3c46f1",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/4c297771e39ca0243d6d0408f9567b1e9e3c46f1"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 4c297771e39ca0243d6d0408f9567b1e9e3c46f1\nparent 3ade41fc6bc12461388f34d5aebe9ba60a008704\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1694005897 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1694006973 +0200\n\nAdd section for optional additional derivations\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmT4fr0ACgkQdAYP+Bsz\n5PhwsQwAjyHzhj/OKGXOGyQriwJaYJ3pNKzIN6BOx9XDPHzm3RXsCvkAkXbLkOf3\n9L6zcRUj9fseLN4/b3AEwl8lB6A7Is4cibDDSMckEjjUQEJrm6xQezJt/9tcxBBn\n8bgNchdZ0OhQZBKrAo95uhF9YwP/Qei3OErKwPEPo7cZTHPTOL+2UxqmSFy9Fu/b\nWCoFMcsYxLfzDJ/wjfEylKtmbk2nA26E1hGYLeumMg9AhD4aiFmm+u2TCAU0TtDs\nUwZPZnomhJTxBZK0TOrenMep/v8yjHNh9M0pqqwEtZVZ4WcUj5o7dfE4xilFWQNP\n4h2UHF0VvtSfnzeLtynN5mGWCZWmlkOjqTWMBllWbEU96toM/kfoU1qbGOtGUJyA\nbG4HgtB48iZQRmr45OAMRfcGsFpVxupyVC7AEuIK8dC0xn3YO70GbtPBYmCFEdPZ\nozqb9/1M8UBzv+/GNIkiODIMb4ugNVNxnpHswamgFRJ8AYJqeSsNmauxBRIZRvsH\nXXgG78ci\n=oDc4\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/3ade41fc6bc12461388f34d5aebe9ba60a008704",
          "sha": "3ade41fc6bc12461388f34d5aebe9ba60a008704",
          "html_url": "https://github.com/bitcoin/bips/commit/3ade41fc6bc12461388f34d5aebe9ba60a008704"
        }
      ],
      "message": "Add section for optional additional derivations",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-09-06T13:29:33Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-09-06T13:11:37Z"
      },
      "sha": "0d6e07781e17a4ee8b208b3aea5985fed7ac2cbc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOAN28mdoAKDlhZGJlY2NjYTI3N2U4MDRiMzMyMTgyMWU0MmMxZWQwYzFlZjc0ZWU",
      "url": "https://api.github.com/repos/bitcoin/bips/git/commits/9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bips/commit/9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "tree": {
        "sha": "a6c8679977dd8e6dc032cb009231555c0377e0dc",
        "url": "https://api.github.com/repos/bitcoin/bips/git/trees/a6c8679977dd8e6dc032cb009231555c0377e0dc"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree a6c8679977dd8e6dc032cb009231555c0377e0dc\nparent 0d6e07781e17a4ee8b208b3aea5985fed7ac2cbc\nauthor Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1694006955 +0200\ncommitter Salvatore Ingala <6681844+bigspider@users.noreply.github.com> 1694006974 +0200\n\nAdd link to BIP-389; fix typo\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEEn0ARRHpjklTOSGV2dAYP+Bsz5PgFAmT4fr4ACgkQdAYP+Bsz\n5PgORgv/ZAQ3HP8lxB8FQiOzYO8ynUOCzVKHJArtljU1t5lOmV0+A5dhOBPxfxy4\nPjH2pPwaZ16JA8QUS1r+A5aGhNPnpsDZM2Z37boebF5MKXqeNkErB5DiRIQY9SqG\nEdY2o5NxmUZyV1+qsEsT0+W81tFxgy+F0du8NKNKYSwG+4xczSxlnQbEaormqxN+\nX6U8SyilO1r5rATjnFjhCK7OWrQarkcfcAKEMFYpcxII77rRjxzAwsw9dz6wxK2I\n8/6Es4sbpm80I/s56IwXVbkeNqkXChczs+DO6C4z9dMaB6VAPEUpqQf4lkfd9AqC\n6Bk6d2fQJnePZo0tuVgBfEO6kqrpxRubzrwpqYmZ5MeIVb17Tu03xwbFO2Ethsht\n/JO8NriVhqSYP4O/ubI9T6pM5HdgWAJUIJLbIOHHSK87tRFpgSh427gsZNDJTYed\nrJXk5Oezkfbb6juYs+2J8vfWuwW66hJX11hTNZZgy9nt7T79qtglT5lDV9oQQY4N\n+vqsfrR6\n=vT50\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bips/git/commits/0d6e07781e17a4ee8b208b3aea5985fed7ac2cbc",
          "sha": "0d6e07781e17a4ee8b208b3aea5985fed7ac2cbc",
          "html_url": "https://github.com/bitcoin/bips/commit/0d6e07781e17a4ee8b208b3aea5985fed7ac2cbc"
        }
      ],
      "message": "Add link to BIP-389; fix typo",
      "committer": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-09-06T13:29:34Z"
      },
      "author": {
        "name": "Salvatore Ingala",
        "email": "6681844+bigspider@users.noreply.github.com",
        "date": "2023-09-06T13:29:15Z"
      },
      "sha": "9adbeccca277e804b3321821e42c1ed0c1ef74ee"
    },
    {
      "event": "referenced",
      "id": 10306742071,
      "node_id": "REFE_lADOAN28mc5WiQDdzwAAAAJmVGc3",
      "url": "https://api.github.com/repos/bitcoin/bips/issues/events/10306742071",
      "actor": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "8e4fc85ab53883505ed7d65aee4eec25478d98bc",
      "commit_url": "https://api.github.com/repos/ElementsProject/libwally-core/commits/8e4fc85ab53883505ed7d65aee4eec25478d98bc",
      "created_at": "2023-09-07T12:21:48Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1035755474",
      "pull_request_review_id": 1199012337,
      "id": 1035755474,
      "node_id": "PRRC_kwDOAN28mc49vF_S",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 30,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": null,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not only in Bitcoin Core?",
      "created_at": "2022-11-30T09:53:14Z",
      "updated_at": "2022-11-30T10:01:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1035755474",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1035755474"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 30,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1035758113",
      "pull_request_review_id": 1199012337,
      "id": 1035758113,
      "node_id": "PRRC_kwDOAN28mc49vGoh",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 42,
      "original_position": 42,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": null,
      "user": {
        "login": "darosior",
        "id": 22457751,
        "node_id": "MDQ6VXNlcjIyNDU3NzUx",
        "avatar_url": "https://avatars.githubusercontent.com/u/22457751?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/darosior",
        "html_url": "https://github.com/darosior",
        "followers_url": "https://api.github.com/users/darosior/followers",
        "following_url": "https://api.github.com/users/darosior/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/darosior/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/darosior/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/darosior/subscriptions",
        "organizations_url": "https://api.github.com/users/darosior/orgs",
        "repos_url": "https://api.github.com/users/darosior/repos",
        "events_url": "https://api.github.com/users/darosior/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/darosior/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ":)",
      "created_at": "2022-11-30T09:55:19Z",
      "updated_at": "2022-11-30T10:01:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1035758113",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1035758113"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 42,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1084997183",
      "pull_request_review_id": 1267102523,
      "id": 1084997183,
      "node_id": "PRRC_kwDOAN28mc5Aq74_",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 42,
      "original_position": 42,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": 1035758113,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Still open to suggestions for a less-ambiguous name!",
      "created_at": "2023-01-24T09:17:59Z",
      "updated_at": "2023-01-24T09:18:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1084997183",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1084997183"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 42,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1085000432",
      "pull_request_review_id": 1267106948,
      "id": 1085000432,
      "node_id": "PRRC_kwDOAN28mc5Aq8rw",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 30,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": 1035755474,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good point, changed in 162c675415ef717a599cc899fc4a0b7617710a3e to \"any descriptor-based software wallet\".",
      "created_at": "2023-01-24T09:20:52Z",
      "updated_at": "2023-01-24T09:20:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1085000432",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1085000432"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 30,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104341047",
      "pull_request_review_id": 1295456080,
      "id": 1104341047,
      "node_id": "PRRC_kwDOAN28mc5B0ug3",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 232,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: `for a complete list.` ?\r\n",
      "created_at": "2023-02-13T11:26:40Z",
      "updated_at": "2023-02-13T11:52:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1104341047",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104341047"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104341904",
      "pull_request_review_id": 1295456080,
      "id": 1104341904,
      "node_id": "PRRC_kwDOAN28mc5B0uuQ",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(key_user),or_d(pk(key_service),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 245,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think you need to change:\r\n`key_user` -> `@0`\r\n`key_service` -> `@1`\r\n",
      "created_at": "2023-02-13T11:27:30Z",
      "updated_at": "2023-02-13T11:52:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1104341904",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104341904"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104344236",
      "pull_request_review_id": 1295456080,
      "id": 1104344236,
      "node_id": "PRRC_kwDOAN28mc5B0vSs",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(key_user),or_d(pk(key_service),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(t:or_c(pk(@0/**),and_v(v:pk(@1/**),or_c(pk(@2/**),v:hash160(00112233445566778899aabbccddeeff00112233)))))</tt> - BOLT #3 offered HTLC policy.\n+* <tt>wsh(andor(pk(@0/**),or_i(and_v(v:pkh(@1/**),hash160(00112233445566778899aabbccddeeff00112233)),older(1008)),pk(@2/**)))</tt> - BOLT #3 received HTLC policy.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)\n+ Keys info: [\"[6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb\"]\n+ Descriptor:pkh([6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb)\n+<br>\n+[[bip-0049.mediawiki|BIP-49]], second account\n+ Descriptor template: sh(wpkh(@0))\n+ Keys info: [\"[6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9\"]\n+ Descriptor:sh(wpkh([6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9))\n+<br>\n+[[bip-0084.mediawiki|BIP-84]], third account\n+ Descriptor template: wpkh(@0)\n+ Keys info: [\"[6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt\"]\n+ Descriptor:wpkh([6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt)\n+<br>\n+[[bip-0086.mediawiki|BIP-86]], first account\n+ Descriptor template: tr(@0))\n+ Keys info: [\"[6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL\"]\n+ Descriptor:tr([6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL))\n+<br>\n+[[bip-0048.mediawiki|BIP-48]] P2WSH multisig\n+ Descriptor template: wsh(sortedmulti(2,@0,@1))\n+ Keys info: [\"[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw\", \"[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7\"]\n+ Descriptor:wsh(sortedmulti(2,[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw,[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7))\n+<br>\n+Miniscript: BOLT #3 offered HTLC policy\n+ Descriptor template: wsh(t:or_c(pk(@0/**),and_v(v:pk(@1/**),or_c(pk(@2/**),v:hash160(395e368b267d64945f30e4b71de1054f364c9473)))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(t:or_c(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),and_v(v:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),or_c(pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),v:hash160(395e368b267d64945f30e4b71de1054f364c9473)))))\n+<br>\n+Miniscript: A 3-of-3 that becomes a 2-of-3 after 90 days\n+ Descriptor template: wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(thresh(3,pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),s:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),s:pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),sln:older(12960)))\n+<br>\n+Miniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig\n+ Descriptor template: wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\", \"[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ\"]\n+ Descriptor:wsh(or_d(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa),and_v(v:multi(2,[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js,[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2,[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ),older(65535))))\n+<br>\n+\n+TBD: add examples with taproot scripts and miniscript.\n+\n+== Backwards Compatibility ==\n+\n+The <tt>@</tt> character used for key placeholders is not part of the syntax of output script descriptors, therefore any valid descriptor template is not a valid descriptor template. Vice versa, any descriptor template with at least one key placeholder is not a valid output script descriptor.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 298,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> therefore any valid descriptor template is not a valid descriptor template\r\n\r\nI think you mean `therefore any valid descriptor is not a valid descriptor template`. Is this because a descriptor template must contain at least one key placeholder? You might want to put that into 'Additional rules' if so.",
      "created_at": "2023-02-13T11:29:48Z",
      "updated_at": "2023-02-13T11:52:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1104344236",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104344236"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104355353",
      "pull_request_review_id": 1295456080,
      "id": 1104355353,
      "node_id": "PRRC_kwDOAN28mc5B0yAZ",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 180,
      "original_position": 182,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "While `/**` is shorter, it also looks to be easy to mistype/confuse with `/*`. Compare with something like `/+` or `/++` for example.",
      "created_at": "2023-02-13T11:40:47Z",
      "updated_at": "2023-02-13T12:14:35Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1104355353",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104355353"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 180,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104362160",
      "pull_request_review_id": 1295456080,
      "id": 1104362160,
      "node_id": "PRRC_kwDOAN28mc5B0zqw",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 225,
      "original_position": 222,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Would it not be better to avoid listing the miniscript/descriptor elements that are supported, and just define this bip in terms of :\r\n\r\n1. A change to bip32 `KEY` expressions against miniscript/descriptors; they must be replaced with `@` placeholders\r\n2. Non-bip32 keys (e.g. raw and private keys) are not allowed (not sure if this is specified here)\r\n3. `/**` (or `/+` or whatever is decided on) is used for `<0;1>/*`, and presumably multi-path is disallowed elsewhere.\r\n\r\nGiven that implementations may only support a subset of elements, you might as well open it up to future elements and avoid needing to update this bip.",
      "created_at": "2023-02-13T11:47:25Z",
      "updated_at": "2023-02-13T11:52:49Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1104362160",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1104362160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 225,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1107853609",
      "pull_request_review_id": 1300535952,
      "id": 1107853609,
      "node_id": "PRRC_kwDOAN28mc5CCIEp",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 242,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": null,
      "user": {
        "login": "bucko13",
        "id": 4344978,
        "node_id": "MDQ6VXNlcjQzNDQ5Nzg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4344978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bucko13",
        "html_url": "https://github.com/bucko13",
        "followers_url": "https://api.github.com/users/bucko13/followers",
        "following_url": "https://api.github.com/users/bucko13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bucko13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bucko13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bucko13/subscriptions",
        "organizations_url": "https://api.github.com/users/bucko13/orgs",
        "repos_url": "https://api.github.com/users/bucko13/repos",
        "events_url": "https://api.github.com/users/bucko13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bucko13/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Possible typo that the last key is `@3` instead of `@2`? ",
      "created_at": "2023-02-15T23:41:04Z",
      "updated_at": "2023-02-15T23:41:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1107853609",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1107853609"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1107853773",
      "pull_request_review_id": 1300536148,
      "id": 1107853773,
      "node_id": "PRRC_kwDOAN28mc5CCIHN",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 242,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1107853609,
      "user": {
        "login": "bucko13",
        "id": 4344978,
        "node_id": "MDQ6VXNlcjQzNDQ5Nzg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4344978?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bucko13",
        "html_url": "https://github.com/bucko13",
        "followers_url": "https://api.github.com/users/bucko13/followers",
        "following_url": "https://api.github.com/users/bucko13/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bucko13/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bucko13/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bucko13/subscriptions",
        "organizations_url": "https://api.github.com/users/bucko13/orgs",
        "repos_url": "https://api.github.com/users/bucko13/repos",
        "events_url": "https://api.github.com/users/bucko13/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bucko13/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\r\n```",
      "created_at": "2023-02-15T23:41:20Z",
      "updated_at": "2023-02-15T23:41:20Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1107853773",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1107853773"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112720880",
      "pull_request_review_id": 1306924111,
      "id": 1112720880,
      "node_id": "PRRC_kwDOAN28mc5CUsXw",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 232,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104341047,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in da3e117d075f4428f14d4120124d840682e5587d with `for complete examples.`",
      "created_at": "2023-02-21T08:32:31Z",
      "updated_at": "2023-02-21T08:32:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112720880",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112720880"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 232,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112721484",
      "pull_request_review_id": 1306924894,
      "id": 1112721484,
      "node_id": "PRRC_kwDOAN28mc5CUshM",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(key_user),or_d(pk(key_service),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 245,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104341904,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in da3e117d075f4428f14d4120124d840682e5587d.",
      "created_at": "2023-02-21T08:33:04Z",
      "updated_at": "2023-02-21T08:33:05Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112721484",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112721484"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 245,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112722764",
      "pull_request_review_id": 1306926573,
      "id": 1112722764,
      "node_id": "PRRC_kwDOAN28mc5CUs1M",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(key_user),or_d(pk(key_service),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(t:or_c(pk(@0/**),and_v(v:pk(@1/**),or_c(pk(@2/**),v:hash160(00112233445566778899aabbccddeeff00112233)))))</tt> - BOLT #3 offered HTLC policy.\n+* <tt>wsh(andor(pk(@0/**),or_i(and_v(v:pkh(@1/**),hash160(00112233445566778899aabbccddeeff00112233)),older(1008)),pk(@2/**)))</tt> - BOLT #3 received HTLC policy.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)\n+ Keys info: [\"[6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb\"]\n+ Descriptor:pkh([6738736c/44'/0'/0']xpub6Br37sWxruYfT8ASpCjVHKGwgdnYFEn98DwiN76i2oyY6fgH1LAPmmDcF46xjxJr22gw4jmVjTE2E3URMnRPEPYyo1zoPSUba563ESMXCeb)\n+<br>\n+[[bip-0049.mediawiki|BIP-49]], second account\n+ Descriptor template: sh(wpkh(@0))\n+ Keys info: [\"[6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9\"]\n+ Descriptor:sh(wpkh([6738736c/49'/0'/1']xpub6Bex1CHWGXNNwGVKHLqNC7kcV348FxkCxpZXyCWp1k27kin8sRPayjZUKDjyQeZzGUdyeAj2emoW5zStFFUAHRgd5w8iVVbLgZ7PmjAKAm9))\n+<br>\n+[[bip-0084.mediawiki|BIP-84]], third account\n+ Descriptor template: wpkh(@0)\n+ Keys info: [\"[6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt\"]\n+ Descriptor:wpkh([6738736c/84'/0'/2']xpub6CRQzb8u9dmMcq5XAwwRn9gcoYCjndJkhKgD11WKzbVGd932UmrExWFxCAvRnDN3ez6ZujLmMvmLBaSWdfWVn75L83Qxu1qSX4fJNrJg2Gt)\n+<br>\n+[[bip-0086.mediawiki|BIP-86]], first account\n+ Descriptor template: tr(@0))\n+ Keys info: [\"[6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL\"]\n+ Descriptor:tr([6738736c/86'/0'/0']xpub6CryUDWPS28eR2cDyojB8G354izmx294BdjeSvH469Ty3o2E6Tq5VjBJCn8rWBgesvTJnyXNAJ3QpLFGuNwqFXNt3gn612raffLWfdHNkYL))\n+<br>\n+[[bip-0048.mediawiki|BIP-48]] P2WSH multisig\n+ Descriptor template: wsh(sortedmulti(2,@0,@1))\n+ Keys info: [\"[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw\", \"[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7\"]\n+ Descriptor:wsh(sortedmulti(2,[6738736c/48'/0'/0'/2']xpub6FC1fXFP1GXLX5TKtcjHGT4q89SDRehkQLtbKJ2PzWcvbBHtyDsJPLtpLtkGqYNYZdVVAjRQ5kug9CsapegmmeRutpP7PW4u4wVF9JfkDhw,[b2b1f0cf/48'/0'/0'/2']xpub6EWhjpPa6FqrcaPBuGBZRJVjzGJ1ZsMygRF26RwN932Vfkn1gyCiTbECVitBjRCkexEvetLdiqzTcYimmzYxyR1BZ79KNevgt61PDcukmC7))\n+<br>\n+Miniscript: BOLT #3 offered HTLC policy\n+ Descriptor template: wsh(t:or_c(pk(@0/**),and_v(v:pk(@1/**),or_c(pk(@2/**),v:hash160(395e368b267d64945f30e4b71de1054f364c9473)))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(t:or_c(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),and_v(v:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),or_c(pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),v:hash160(395e368b267d64945f30e4b71de1054f364c9473)))))\n+<br>\n+Miniscript: A 3-of-3 that becomes a 2-of-3 after 90 days\n+ Descriptor template: wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\"]\n+ Descriptor:wsh(thresh(3,pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa/<0,1>/*),s:pk([b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js/<0,1>/*),s:pk([a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2/<0,1>/*),sln:older(12960)))\n+<br>\n+Miniscript: A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig\n+ Descriptor template: wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))\n+ Keys info: [\"[6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa\", \"[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js\", \"[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2\", \"[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ\"]\n+ Descriptor:wsh(or_d(pk([6738736c/48'/0'/0'/100']xpub6FC1fXFP1GXQpyRFfSE1vzzySqs3Vg63bzimYLeqtNUYbzA87kMNTcuy9ubr7MmavGRjW2FRYHP4WGKjwutbf1ghgkUW9H7e3ceaPLRcVwa),and_v(v:multi(2,[b2b1f0cf/44'/0'/0'/100']xpub6EYajCJHe2CK53RLVXrN14uWoEttZgrRSaRztujsXg7yRhGtHmLBt9ot9Pd5ugfwWEu6eWyJYKSshyvZFKDXiNbBcoK42KRZbxwjRQpm5Js,[a666a867/44'/0'/0'/100']xpub6Dgsze3ujLi1EiHoCtHFMS9VLS1UheVqxrHGfP7sBJ2DBfChEUHV4MDwmxAXR2ayeytpwm3zJEU3H3pjCR6q6U5sP2p2qzAD71x9z5QShK2,[bb641298/44'/0'/0'/100']xpub6Dz8PHFmXkYkykQ83ySkruky567XtJb9N69uXScJZqweYiQn6FyieajdiyjCvWzRZ2GoLHMRE1cwDfuJZ6461YvNRGVBJNnLA35cZrQKSRJ),older(65535))))\n+<br>\n+\n+TBD: add examples with taproot scripts and miniscript.\n+\n+== Backwards Compatibility ==\n+\n+The <tt>@</tt> character used for key placeholders is not part of the syntax of output script descriptors, therefore any valid descriptor template is not a valid descriptor template. Vice versa, any descriptor template with at least one key placeholder is not a valid output script descriptor.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 298,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104344236,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed the sentence and added the additional rule in da3e117d075f4428f14d4120124d840682e5587d.",
      "created_at": "2023-02-21T08:34:10Z",
      "updated_at": "2023-02-21T08:34:11Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112722764",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112722764"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 298,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112737026",
      "pull_request_review_id": 1306946219,
      "id": 1112737026,
      "node_id": "PRRC_kwDOAN28mc5CUwUC",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 180,
      "original_position": 182,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104355353,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I prefer `/**` as it has a similar meaning in other languages (and was used in [BIP-0129](https://github.com/bitcoin/bips/blob/master/bip-0129.mediawiki#user-content-Descriptor_Template) for almost the same meaning).\r\n\r\nAs the `/*` alone is invalid for wallet policies, I don't see the risk of confusing it as very dangerous.\r\n\r\nIt's been pointed out in the past that `/**` is redundant since the `/<M;N>/*` expression is already more general, but in practice my expectation is that the vast majority of the use cases will just be happy with using `/**` for all the key expressions (which makes it a lot easier to inspect).\r\nComplex taproot scripts with many leaves might find the `/<M;N>/*` notation more interesting, perhaps.",
      "created_at": "2023-02-21T08:44:18Z",
      "updated_at": "2023-02-21T08:44:18Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112737026",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112737026"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 180,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112747316",
      "pull_request_review_id": 1306960514,
      "id": 1112747316,
      "node_id": "PRRC_kwDOAN28mc5CUy00",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 225,
      "original_position": 222,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104362160,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's an option, indeed.\r\n\r\nI opted for a bottom-up definition (explicitly whitelisting the parts of the descriptor language that we adopt) because there are some inherent incompatibilities, plus it is hard to predict if more will come in the future. For example:\r\n- The `combo` descriptor seems inherently not fitting for wallet policies\r\n- Likewise, extensions like [this](https://github.com/bitcoin/bitcoin/pull/26626) would have to be \"blacklisted\" explicitly\r\n\r\nOn the other hand, the bottom-up approach leaves the exact spec for miniscript descriptors templates in the air, until there is no corresponding BIP...",
      "created_at": "2023-02-21T08:53:08Z",
      "updated_at": "2023-02-21T08:53:08Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112747316",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112747316"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 225,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112747783",
      "pull_request_review_id": 1306961112,
      "id": 1112747783,
      "node_id": "PRRC_kwDOAN28mc5CUy8H",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for a complete\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@3))</tt> - Legacy 2-of-3 multisignature, sorted keys.",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 242,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1107853609,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed in da3e117d075f4428f14d4120124d840682e5587d, thanks!",
      "created_at": "2023-02-21T08:53:31Z",
      "updated_at": "2023-02-21T08:53:31Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1112747783",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1112747783"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 242,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113854499",
      "pull_request_review_id": 1308551027,
      "id": 1113854499,
      "node_id": "PRRC_kwDOAN28mc5CZBIj",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 225,
      "original_position": 222,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104362160,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, we have to hope that at some point we stop shoe-horning in descriptor extensions for obsolete cases. Doing so makes a complete implementation prohibitively difficult, makes universal descriptor support less likely, and disincentivizes the eventual/priority movement of coins to modern UTXO/key derivation schemes.\r\n\r\n`combo`, and the linked extension both have in common that they change the cardinality of the solved descriptor. I think you could get the benefit of forward compatibility for this BIP by just stating that final wildcards and multi-path are the only supported key expressions that change cardinality, and all others are forbidden. Then any future extensions to the path syntax, and any expression fragments that return multiple variants would automatically be excluded.",
      "created_at": "2023-02-22T05:30:44Z",
      "updated_at": "2023-02-22T05:30:44Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1113854499",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113854499"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 225,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113860887",
      "pull_request_review_id": 1308559709,
      "id": 1113860887,
      "node_id": "PRRC_kwDOAN28mc5CZCsX",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 180,
      "original_position": 182,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104355353,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah, that's fair enough, I wasn't aware of BIP-0129. I'm OK with `/**` in that case. Given that:\r\n\r\n>It's been pointed out in the past that /** is redundant since the /<M;N>/* expression is already more general\r\n\r\nI think you should disallow `<0;1>/*` within wallet policies and require they be expressed as `/**`. Can't recall if that's already the case.\r\n\r\nIn fact I think you should go further and mandate the hardened indicator be only `'` (or `'h`, but only one or the other) in wallet policies. At the moment, the primary source of descriptor malleability (two textually different descriptors that describe the same thing, but have different checksums) is the key paths (plus no lexicographical sorting in the source `sortedmulti` key expression order). Given that you are replacing the keys with `@n` and enforcing monotonic numbering from left to right, doing the above will make it much simpler to identify standard policies/templates by not requiring all possible variants to be stored and compared. What do you think?\r\n\r\nedit: Forgot about multi-path. You need additionally to state that multi-path extensions of length 3 and greater must be sorted in numerical order.\r\n",
      "created_at": "2023-02-22T05:42:59Z",
      "updated_at": "2023-02-22T05:58:32Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1113860887",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113860887"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 180,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113866551",
      "pull_request_review_id": 1308567444,
      "id": 1113866551,
      "node_id": "PRRC_kwDOAN28mc5CZEE3",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 42,
      "original_position": 42,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": 1035758113,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If the suggestions below to reduce/remove malleability are taken, I'd suggest `wallet patterns` as these strings describe the pattern of derivation without including the keys.",
      "created_at": "2023-02-22T05:52:52Z",
      "updated_at": "2023-02-22T05:52:52Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1113866551",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1113866551"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 42,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114137256",
      "pull_request_review_id": 1308960513,
      "id": 1114137256,
      "node_id": "PRRC_kwDOAN28mc5CaGKo",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 180,
      "original_position": 182,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104355353,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Mandating `'` instead of `h` sounds good to me, but completely fixing malleability is probably a lost battle.\r\nFor example, impossible to make sure are not reused if descriptors are different because of `multi`/`sortedmulti`, as you pointed out. More crucially, you might or might not know the key origin info of some external xpub (although this is only within the key info vector, not in the _descriptor template_).\r\n\r\nI'm not sure about disallowing the `/<M;N>/*` notation; for one thing, it's already adopted for descriptors and used in many multisig wallets. Moreover, I suspect using `<M;N>` other than `0;1` will have use cases: you might have the same root xpub in different spending conditions, but using different values for `M;N`. One use case might be _delegation_: `or(and(Alice1,Bob),and(Alice2,Carl))`: Alice might want to allow Bob to sign, but not Carl, so she only signs with `Alice1`. If only the `/**` notations is present, then the only option for Alice is to use two different xpubs; instead, one could have `or(and(Alice/<0;1>/*,Bob),and(Alice/<2;3>/*, Carl))` and have a single xpub for Alice.",
      "created_at": "2023-02-22T10:32:14Z",
      "updated_at": "2023-02-22T10:32:14Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1114137256",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114137256"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 180,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114139394",
      "pull_request_review_id": 1308963519,
      "id": 1114139394,
      "node_id": "PRRC_kwDOAN28mc5CaGsC",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 225,
      "original_position": 222,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104362160,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "My understanding is that the plan is for extending descriptors liberally, but then implementations can choose which subset to implement. So the bottom-up approach is imho more likely to stay well-defined (but it's certainly more work and will need updates in the future).",
      "created_at": "2023-02-22T10:34:02Z",
      "updated_at": "2023-02-22T10:34:03Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1114139394",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114139394"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 225,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114182992",
      "pull_request_review_id": 1309028734,
      "id": 1114182992,
      "node_id": "PRRC_kwDOAN28mc5CaRVQ",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 180,
      "original_position": 182,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104355353,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> but completely fixing malleability is probably a lost battle.\r\n\r\nAgreed, it wasn't baked in at the start and can't be reliably added now. My goal is just to make sure that the common cases are all represented with the same pattern as much as possible.\r\n\r\n> I'm not sure about disallowing the /<M;N>/* notation\r\n\r\nTo be clear, I'm only suggesting this when M=0 and N=1, not in the general case! its just a simple text substitution much as the hardening indicator would be, that would go a long way to making common patterns trivially identifiable. Agreed that there are use cases for other values here.",
      "created_at": "2023-02-22T11:13:33Z",
      "updated_at": "2023-02-22T11:13:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1114182992",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114182992"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 180,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114186793",
      "pull_request_review_id": 1309033989,
      "id": 1114186793,
      "node_id": "PRRC_kwDOAN28mc5CaSQp",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 225,
      "original_position": 222,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "162c675415ef717a599cc899fc4a0b7617710a3e",
      "in_reply_to_id": 1104362160,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'll leave the approach here to your judgement, since there are arguments for both sides. My view is that descriptors become less useful the more incompatible implementations there are. In wally I'm likely just going to accept anything that looks like a correct pattern as long as it parses and doesn't change the cardinality when solved (assuming this BIP is accepted).",
      "created_at": "2023-02-22T11:17:18Z",
      "updated_at": "2023-02-22T11:17:19Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1114186793",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1114186793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 225,
      "original_line": 222,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182647115",
      "pull_request_review_id": 1409257811,
      "id": 1182647115,
      "node_id": "PRRC_kwDOAN28mc5GfcNL",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with bitcoin-core's descriptor-based wallets).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 42,
      "original_position": 42,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "fd3b84da83f5b22953ab8c8cc7c2f1239026692a",
      "in_reply_to_id": 1035758113,
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I am wondering if `signing policy/pattern` as a name can be useful too. Thinking of constraining outputs to spend to a predefined wallet, which isn't necessarily the wallet that is being spend _from_.\r\n\r\nFor example a policy that only allows spending to cold storage addresses derived from a pre-registered xpub.",
      "created_at": "2023-05-02T14:38:45Z",
      "updated_at": "2023-05-02T15:05:00Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1182647115",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182647115"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 42,
      "original_line": 42,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182668361",
      "pull_request_review_id": 1409290224,
      "id": 1182668361,
      "node_id": "PRRC_kwDOAN28mc5GfhZJ",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 215,
      "original_position": 214,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": null,
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could an alternative to using the `/**` suffix be to separate define the wallet policies for the inputs and outputs? The input policy can then specify `/0/*` and the output policy `/1/*`. Both would still reference the same entry in the key info vector. The added flexibility may also be useful to constrain outputs to a known-but-different wallet.",
      "created_at": "2023-05-02T14:54:22Z",
      "updated_at": "2023-05-02T14:54:56Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1182668361",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182668361"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 215,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182679318",
      "pull_request_review_id": 1409307273,
      "id": 1182679318,
      "node_id": "PRRC_kwDOAN28mc5GfkEW",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).",
      "path": "bip-wallet-policies.mediawiki",
      "position": 197,
      "original_position": 198,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": null,
      "user": {
        "login": "joostjager",
        "id": 4638168,
        "node_id": "MDQ6VXNlcjQ2MzgxNjg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4638168?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/joostjager",
        "html_url": "https://github.com/joostjager",
        "followers_url": "https://api.github.com/users/joostjager/followers",
        "following_url": "https://api.github.com/users/joostjager/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/joostjager/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/joostjager/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/joostjager/subscriptions",
        "organizations_url": "https://api.github.com/users/joostjager/orgs",
        "repos_url": "https://api.github.com/users/joostjager/repos",
        "events_url": "https://api.github.com/users/joostjager/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/joostjager/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Echoing the discussion in https://github.com/LedgerHQ/app-bitcoin-new/issues/153:\r\n\r\nIt would be great if a wallet policy can support 2-of-2 multisig transactions where one of the keys is ephemeral (completely random). This is useful when using presigned transactions to simulate covenants, for example to implement time-locked vaults.",
      "created_at": "2023-05-02T15:02:34Z",
      "updated_at": "2023-05-02T15:02:34Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1182679318",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1182679318"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 197,
      "original_line": 198,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1227756655",
      "pull_request_review_id": 1476595838,
      "id": 1227756655,
      "node_id": "PRRC_kwDOAN28mc5JLhRv",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.",
      "path": "bip-wallet-policies.mediawiki",
      "position": 215,
      "original_position": 214,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1182668361,
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe I am misunderstanding you, but: inputs can be /0/* or /1/* (changes can be spent too)",
      "created_at": "2023-06-13T08:40:36Z",
      "updated_at": "2023-06-13T08:40:36Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1227756655",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1227756655"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 215,
      "original_line": 214,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1227768530",
      "pull_request_review_id": 1476612443,
      "id": 1227768530,
      "node_id": "PRRC_kwDOAN28mc5JLkLS",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": null,
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The spec above says that the `@N` must always be followed by `/**` or `/<NUM:NUM>/*`, but some examples and test vectors don't have that suffix. \r\n\r\n```\r\n followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\r\n* ''always'' followed by either:\r\n** the string  <tt>/**</tt>, or\r\n...\r\n```\r\n\r\nIs `@0` the same as `@0/**`? Would be good to fix either the specification or the examples/test vectors. ",
      "created_at": "2023-06-13T08:49:08Z",
      "updated_at": "2023-06-13T08:49:09Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1227768530",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1227768530"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1312907268",
      "pull_request_review_id": 1606764397,
      "id": 1312907268,
      "node_id": "PRRC_kwDOAN28mc5OQWAE",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We have to also allow `/*` following `@n` (i.e. a single asterisk instead of two), since not all wallets use 0/1 paths to differentiate change addresses.\r\n\r\nI'm OK with `@n` alone expanding to `@0/**` but this does add even more malleability to expressions. Regardless, the `always` section should be updated to allow single asterisks.",
      "created_at": "2023-09-01T11:23:35Z",
      "updated_at": "2023-09-01T11:23:57Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1312907268",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1312907268"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316058847",
      "pull_request_review_id": 1611317016,
      "id": 1316058847,
      "node_id": "PRRC_kwDOAN28mc5OcXbf",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The naked `@N` was an oversight, I don't think it should be allowed as it would be confusing (Ledger's implementation doesn't permit it). I will fix it.\r\n\r\n--\r\n\r\nIf we generalize the suffix to expressions other than `<0;1>/*`, then we have to make sure that no pubkey is repeated.\r\nIn practice, for `/*`, that would mean that _all_ the placeholders must be followed by the exact suffix `/*`.\r\n\r\nOut of curiosity, what software wallets use that scheme?",
      "created_at": "2023-09-05T15:22:10Z",
      "updated_at": "2023-09-05T15:22:10Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1316058847",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316058847"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316487474",
      "pull_request_review_id": 1612042278,
      "id": 1316487474,
      "node_id": "PRRC_kwDOAN28mc5OeAEy",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> If we generalize the suffix to expressions other than <0;1>/*\r\n\r\nI'm not sure I follow. I'm not suggesting generalizing the suffix, at least in the sense of allowing general path expressions to be used as suffixes. I'm saying the only key expression suffixes that should be allowed are `/**`, `/<m;n>/*` and `/*`.\r\n\r\n> If we generalize the suffix to expressions other than <0;1>/*, then we have to make sure that no pubkey is repeated.\r\n\r\nI assume you mean here that a key expression could be given as `[/a/b/c]foo/**` and then elsewhere as `[/a/b/c/0]bar/*` and/or `[/a/b/c/1]bar/*` giving rise to the same derived keys with different key identifiers.\r\n\r\n> In practice, for /*, that would mean that all the placeholders must be followed by the exact suffix /*\r\n\r\nFor a given key expression, yes. I'm fine with supporting `/*` being optional, and if present the implementation must ensure this.\r\n\r\nNote also that at present this BIP does not state that implementations must ensure that `KP` expressions refer to distinct keys when substituting them into a policy, although that appears to be a requirement. I think it would also be clearer to state that all key expressions in a policy must be replaced by `KP` expressions (i.e. that no non-`KP` keys are allowed).\r\n\r\nAlso missing are that `<m;n>` expressions should be numerically sorted, and that explicit `<0;1>` should be disallowed.\r\n\r\nI'm happy to make individual commits with suggested changes for the above for you to review/cherry-pick. Should I create a PR against your repo for this?.\r\n\r\n> Out of curiosity, what software wallets use that scheme?\r\n\r\nBlockstream Green multisig wallets do not use bip44 style paths (the wallet predates the BIP). Also descriptors themselves do not enforce bip44 derivation.",
      "created_at": "2023-09-05T22:36:40Z",
      "updated_at": "2023-09-05T22:36:40Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1316487474",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316487474"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316995686",
      "pull_request_review_id": 1612884030,
      "id": 1316995686,
      "node_id": "PRRC_kwDOAN28mc5Of8Jm",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> I'm not sure I follow. I'm not suggesting generalizing the suffix, at least in the sense of allowing general path expressions to be used as suffixes. I'm saying the only key expression suffixes that should be allowed are `/**`, `/<m;n>/*` and `/*`.\r\n\r\nWhat I mean is that if we allow mixing things like  `@0/*` with `@1/<m;n>/*`, then we for the xpub of `@1` we would need to derive `@1/m` and `@1/n` and compare with the pubkey of the xpub in `@0`, which is quite expensive on a hardware wallet.\r\n\r\nWith no mixing, for any two placeholders like `@0/<m;n>/*` and `@0/<p;q>/*`, I can just check that the sets `{m, n}` and `{p, q}` are disjoint.\r\n\r\n> For a given key expression, yes. I'm fine with supporting `/*` being optional, and if present the implementation must ensure this.\r\n\r\nNot just _for a given key expression_, I mean it across the entire wallet policy. That is, either the KPs all end with `/*`, or they all end with some `/<NUM;NUM>/*`.\r\n\r\n> Note also that at present this BIP does not state that implementations must ensure that `KP` expressions refer to distinct keys when substituting them into a policy, although that appears to be a requirement.\r\n\r\nGood point, worth adding explicitly the \"Additional rules\", with the motivation that it's required in miniscript (and it's simpler to add this restriction globally, rather than on the individual miniscript parts of the policy).\r\n\r\nSo basically:\r\n- all the public keys (deserialized from the corresponding xpubs in the keys information vector) must be distinct\r\n- all the derivations in each KP expression referring to the same index in the keys information vector must be distinct\r\n\r\nIn order to allow optional extensions like `/*`, perhaps I could mention that possibility in a separate section?\r\n\r\n> I think it would also be clearer to state that all key expressions in a policy must be replaced by `KP` expressions (i.e. that no non-`KP` keys are allowed).\r\n\r\nA wallet policy is the pair `(descriptor_template, keys_information_vector)`, so not sure what you mean here. The grammar seems to specify exactly what are the allowed KP and KEY expressions, as far as I can tell.\r\n\r\n> Also missing are that `<m;n>` expressions should be numerically sorted, and that explicit `<0;1>` should be disallowed.\r\n\r\nI like suggesting to sort `<m;n>` numerically, but not sure about disallowing `<0;1>`. I expect people to prefer not mixing `@0/**` with `@0/<2;3>/*`, as it's more explicit in that case to just write `@0/<0;1>/*`.\r\n\r\n> I'm happy to make individual commits with suggested changes for the above for you to review/cherry-pick. Should I create a PR against your repo for this?.\r\n\r\nSure, feel free to propose changes, but I'll try to incorporate the comments now. I'm also hoping to find the time for a general pass over the whole document to improve the Motivation section, as that was written before the BtcPrague meeting and it can surely be improved in hindsight.",
      "created_at": "2023-09-06T09:17:22Z",
      "updated_at": "2023-09-06T09:17:23Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1316995686",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1316995686"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317001469",
      "pull_request_review_id": 1612892796,
      "id": 1317001469,
      "node_id": "PRRC_kwDOAN28mc5Of9j9",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> I like suggesting to sort <m;n> numerically, but not sure about disallowing <0;1>. I expect people to prefer not mixing @0/** with @0/<2;3>/*, as it's more explicit in that case to just write @0/<0;1>/*.\r\n\r\nWhat's the reason for sorting? It's not mentioned in [BIP-389](https://github.com/bitcoin/bips/blob/master/bip-0389.mediawiki).\r\n\r\n+1 to keep allowing `<0;1>/*` for readability for the reason you stated.",
      "created_at": "2023-09-06T09:21:57Z",
      "updated_at": "2023-09-06T09:21:58Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317001469",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317001469"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317058627",
      "pull_request_review_id": 1612981459,
      "id": 1317058627,
      "node_id": "PRRC_kwDOAN28mc5OgLhD",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Not just for a given key expression, I mean it across the entire wallet policy.\r\n\r\nOK, I understand where you are coming from now. Enforcing this across the entire policy is sensible (no-one should be mixing key expressions with different cardinalities), and its pretty easy to implement.\r\n\r\n> So basically:\r\n\r\nYes these 2 two points are whats missing IMO.\r\n\r\n> perhaps I could mention that possibility in a separate section?\r\n\r\nSure, that works, let me know if you'd like me to draft it or if you are happy to.\r\n\r\n> The grammar seems to specify exactly what are the allowed KP and KEY expressions, as far as I can tell.\r\n\r\nThis is true, I just prefer being more explicit. Feel free to ignore this if you disagree.\r\n\r\n> I expect people to prefer not mixing\r\n> +1 to keep allowing <0;1>/* for readability\r\n\r\nNo doubt its slightly better for human readability in the rare case where alternate multipath derivations are given. But its bad for comparing two such policies (or checking against a whitelist of supported policies) because it's another source of malleability. It also complicates logic to convert a descriptor to a human friendly policy automatically, because substitution of `/<0;1>/*` for `/**` as recommended in this BIP will not result in the human friendly format in this case. Complicated policies are far more likely to be automatically generated than human written, and so in practice I suspect the large majority will end up mixing `/**` and `/<M;N>/*` anyway. However its your decision.\r\n\r\n> What's the reason for sorting?\r\n\r\nMalleability and ease of comparing multipaths. Unfortunately 389 states that the meaning of all n=2 multipaths is fixed (receive addresses and change), and so sorting is probably not possible to enforce given some hypothetical wallet out there could use descending numbers for this purpose.\r\n\r\n>  It's not mentioned in BIP-389\r\n\r\nTrue, but we limit multipaths to length 2 in policies which is also not part of 389.",
      "created_at": "2023-09-06T10:10:37Z",
      "updated_at": "2023-09-06T10:12:15Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317058627",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317058627"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317077214",
      "pull_request_review_id": 1613010541,
      "id": 1317077214,
      "node_id": "PRRC_kwDOAN28mc5OgQDe",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "benma",
        "id": 1225267,
        "node_id": "MDQ6VXNlcjEyMjUyNjc=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1225267?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/benma",
        "html_url": "https://github.com/benma",
        "followers_url": "https://api.github.com/users/benma/followers",
        "following_url": "https://api.github.com/users/benma/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/benma/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/benma/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/benma/subscriptions",
        "organizations_url": "https://api.github.com/users/benma/orgs",
        "repos_url": "https://api.github.com/users/benma/repos",
        "events_url": "https://api.github.com/users/benma/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/benma/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Unfortunately 389 states that the meaning of all n=2 multipaths is fixed (receive addresses and change), and so sorting is probably not possible \r\n\r\nI was actually thinking primarily about this case and wondered why one would restrict people from using receive and change indices to be ordered.\r\n\r\n> Malleability and ease of comparing multipaths.\r\n\r\n`/<1;2;3>*` is not the same as `<3;2;1>/*`, so why should they be compared or treated to be the same? Applications may assign meaning to the position (similar to receive and change with two elements).\r\n\r\nIn practice it probably does not matter much, but I wouldn't impose this restriction here.\r\n\r\n> Blockstream Green multisig wallets do not use bip44 style paths (the wallet predates the BIP). \r\n\r\nOut of curiosity, how does Green identify which UTXOs are change?",
      "created_at": "2023-09-06T10:28:23Z",
      "updated_at": "2023-09-06T10:28:23Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317077214",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317077214"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317295697",
      "pull_request_review_id": 1613358030,
      "id": 1317295697,
      "node_id": "PRRC_kwDOAN28mc5OhFZR",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "As per this discussion:\r\n- 3ade41fc6bc12461388f34d5aebe9ba60a008704 makes the rules on distinct pubkeys explicit;\r\n- 0d6e07781e17a4ee8b208b3aea5985fed7ac2cbc adds a section for the optional additional derivations, pointing out the potential footguns I could think of.\r\n\r\nI didn't add any requirement/suggestion to sort `<m;n>` expressions. Thanks for the comments, and feel free to suggest further changes, of course!",
      "created_at": "2023-09-06T13:34:33Z",
      "updated_at": "2023-09-06T13:34:33Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317295697",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317295697"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317822961",
      "pull_request_review_id": 1614200216,
      "id": 1317822961,
      "node_id": "PRRC_kwDOAN28mc5OjGHx",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@bigspider Thanks!\r\n\r\nComments on the current state:\r\n1. under `** a string of the form` there should be a new bullet point stating that any path expression as listed in the `Optional derivation paths` is optionally allowed.\r\n2. There still appear to be some bare `@n` references in the test vectors (e.g. multisig).\r\n3. The `Why must public keys be distinct?` reference doesn't appear to point anywhere. Do you have a reference to any docs/discussion on pubkey reuse in miniscript this can link to?\r\n4. Some invalid test vectors would be helpful for implementors to check against (see below).\r\n\r\nI'm fully implementing the BIP in wally now, and may have some further comments once that work is complete.\r\n\r\nSuggested invalid test vectors:\r\n1. `pkh(@0)` Key with no following path\r\n2. `pkh(@0/0/*)` Key with an explicit path present\r\n3. `sh(multi(1,@1/**,@0/**))` Keys used out of order\r\n5. `sh(multi(1,@0/**,@0/**))` Repeated keys w/same path expression\r\n6. `sh(multi(1,@0/<0;1>/*,@1/<1;2>/*))` Non-disjoint multipath expressions\r\n7. `sh(multi(1,@0/**,xpub6AHA9hZDN11k2ijHMeS5QqHx2KP9aMBRhTDqANMnwVtdyw2TDYRmF8PjpvwUFcL1Et8Hj59S3gTSMcUQ5gAqTz3Wd8EsMTmF3DChhqPQBnU/<0;1>/*))` Expression with a non `KP` key present\r\n8. `pkh(@0/<0;1;2>/*)` Solved cardinality > 2",
      "created_at": "2023-09-06T20:54:07Z",
      "updated_at": "2023-09-06T20:54:07Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317822961",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317822961"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317854062",
      "pull_request_review_id": 1614248571,
      "id": 1317854062,
      "node_id": "PRRC_kwDOAN28mc5OjNtu",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "jgriffiths",
        "id": 406223,
        "node_id": "MDQ6VXNlcjQwNjIyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/406223?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jgriffiths",
        "html_url": "https://github.com/jgriffiths",
        "followers_url": "https://api.github.com/users/jgriffiths/followers",
        "following_url": "https://api.github.com/users/jgriffiths/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jgriffiths/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jgriffiths/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jgriffiths/subscriptions",
        "organizations_url": "https://api.github.com/users/jgriffiths/orgs",
        "repos_url": "https://api.github.com/users/jgriffiths/repos",
        "events_url": "https://api.github.com/users/jgriffiths/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jgriffiths/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "@benma \r\n\r\nnote slightly O/T to this BIP.\r\n\r\n> why one would restrict people from using receive and change indices to be ordered.\r\n> /<1;2;3>* is not the same as <3;2;1>/*, so why should they be compared or treated to be the same? Applications may assign meaning to the position (similar to receive and change with two elements).\r\n\r\nThey are the same assuming no other paths appear in the same expression; they both result in the same set of solutions, just in a different order. Of course this is not true with multiple keys: `<1;2;3>` and `<4;5;6>` have different solutions to `<3;2;1>` and `<4;5;6>` due to the stepwise resolution through path elements when generating the solutions. But in the single case its a cause of expression malleability.\r\n\r\nNote that ordering of expressions is not explicitly specified anywhere other than this stepwise derivation, and no meaning can be inferred except in the n=2 case (where all n=2 cases must be considered as receive/change even if this is not the intention). Consider expressions like `combo` or new extensions like explicit key lists. In what order is `combo(<key>/<1;2;3>/*)` solved, paths iterated first or the combo variants for each path?\r\n\r\nAs per my comments on the BIP the addition of extensions that change cardinality and the non-specification of ordering for N>3 means that we have the worst of all worlds: proscribed meaning for one case that prevents general use of N=2, and no ability to state anything about all the meaning of solutions when other expressions that change cardinality are present. Enforcing ordering and describing the expansion order of expressions would not have been onerous but would have allowed implementations to process them consistently instead of needing whitelists/understanding specific patterns.\r\n\r\n> In practice it probably does not matter much, but I wouldn't impose this restriction here.\r\n\r\nAgreed, this ship along with other malleability concerns has unfortunately sailed. Although it would be nice to enforce `'` rather than `h` for hardening in policies at least, @bigspider?\r\n\r\n> Out of curiosity, how does Green identify which UTXOs are change?\r\n\r\nFor singlesig wallets we use bip44 like everyone else, although you can't rely on the internal/external paths only for change detection, since its possible to create txs using either. For multisig we don't explicitly track change, the backend computes limits etc based on the net effect on the wallet, and displaying change is based on a simple check of the txs outputs (one output only to the wallet = redeposit, non-wallet output plus wallet output = payment and change etc).",
      "created_at": "2023-09-06T21:29:15Z",
      "updated_at": "2023-09-06T21:29:16Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1317854062",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1317854062"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1318784475",
      "pull_request_review_id": 1615717273,
      "id": 1318784475,
      "node_id": "PRRC_kwDOAN28mc5Omw3b",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+<pre>\n+  BIP: wallet-policies\n+  Layer: Applications\n+  Title: Wallet Policies for Descriptor Wallets\n+  Author: Salvatore Ingala <salvatoshi@protonmail.com>\n+  Comments-Summary: No comments yet.\n+  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-wallet-policies\n+  Status: Draft\n+  Type: Informational\n+  Created: 2022-11-16\n+  License: BSD-2-Clause\n+</pre>\n+\n+== Abstract ==\n+\n+Wallet policies build on top of output descriptors to represent in a compact, easier to inspect way the types of descriptors that are typically used to represent \"accounts\" in a software wallet, or a hardware signing device. A wallet policy always represents exactly two descriptors, which produce the receive and change addresses that are logically part of the same account.\n+\n+Reducing the generality of descriptors to just the essential features, and separating the extended pubkeys and other key information from the descriptor, allows to simplify the language in a way that suits devices with limited memory, where even keeping the entire descriptor in memory could be a major hurdle.\n+\n+Moreover, together with the gain in compactness, this simplifies user's inspection of the policy.\n+\n+Finally, by keeping the language extremely close to that of output script descriptors, the compilation of wallet policies to the corresponding descriptor is extremely easy, and even the reverse process is not too difficult for supported descriptors.\n+\n+== Copyright ==\n+\n+This BIP is licensed under the BSD 2-clause license.\n+\n+== Motivation ==\n+\n+''[[bip-0380.mediawiki|Output Script Descriptors]]'' were introduced in bitcoin-core as a way to represent collections of output scripts. It is a very general and flexible language, designed to catch all the possible use-cases of bitcoin wallets (that is, if you know the script and you have the necessary keys, it will be possible to sign transactions with any descriptor-based software wallet).\n+\n+Unfortunately, descriptors are not a perfect match for the typical usage of hardware signing devices (often also called ''hardware wallets''). Most of them have some of the following limitations when compared to a general-purpose machine running bitcoin-core:\n+\n+* they are embedded devices with limited RAM, and computational power;\n+* they cannot import additional private keys (that is, they can only sign with keys derived from a single seed via [[bip-0032.mediawiki|BIP-32]]);\n+* they have limited storage, or they might not have persistent storage at all (''stateless design'').\n+\n+Moreover, other limitations like the limited size of the screen might affect what design choices are available in practice. Therefore, minimizing the size of the information shown on-screen is important for a good user experience; that is crucial since the ability for the user to completely validate on-screen the kind of script used (and each of the involved keys) is a prerequisite for secure usage, as the machine that is interacting with the hardware signer (and running the software wallet) is considered untrusted.\n+\n+A more native, compact representation of the wallet receive/change might also benefit the UX of software wallets using descriptors to represent software wallets using descriptors (possibly with miniscript) for complex locking conditions.\n+\n+We remark that wallet policies are not related to the ''policy'' language, a higher level language that can be compiled to miniscript.\n+\n+=== Security and UX concerns for hardware signing devices ===\n+\n+For a hardware signing device, allowing the usage of complex scripts presents challenges in terms of both security and user experience.\n+\n+==== Security issues ====\n+\n+One of the security properties that hardware signing devices strive to guarantee is the following: as long as the user correctly verifies the information that is shown on the device's screen before approving, no action can be performed without the user's consent.\n+\n+This must hold even in scenarios where the attacker has full control of the machine that is connected to the signing device, and can execute arbitrary requests, or tamper with the legitimate user's requests.\n+\n+Therefore, it is not at all trivial to allow complex scripts, especially if they contain keys that belong to third parties.\n+The hardware signing device must guarantee that the user knows precisely what \"policy\" is being used to spend the funds, and that any \"unspent\" funds (if any) that is sent to a change address will be protected by the same policy.\n+\n+This makes it impossible for an attacker to surreptitiously modify the policy, therefore stealing or burning the user's funds.\n+\n+==== UX issues ====\n+\n+With miniscript (and taproot trees) allowing substantially more complex spending policies to be used, it becomes more challenging to make sure that the user is practically able to verify the information on the screen.\n+\n+Therefore, there are two fundamental design goals to strive for:\n+* Minimize the amount of information that is shown on screen - so that the user can actually validate it.\n+* Minimize the number of times the user has to validate such information.\n+\n+Designing a secure protocol for the coordination of a descriptor wallet among distant parties is also a challenging problem that is out of scope in this document. See [[bip-00129.mediawiki|BIP-129 (Bitcoin Secure Multisig Setup)]] for an approach designed for multisignature wallets. Regardless the approach, the ability for the user to carefully verify all the details of the spending policies using the hardware signer's screen is a prerequisite for security in adversarial environments.\n+\n+=== Policy registration as a solution ===\n+\n+A solution to address the security concerns, and part of the UX concerns, is to have a registration flow for the wallet policy in the hardware signing device. The ''wallet policy'' must contain enough information to generate all the relevant addresses/scripts, and for the hardware signing device to identify the keys that it controls and that are needed to spend the funds sent to those addresses.\n+\n+Before a new policy is used for the first time, the user will register a wallet policy into the hardware device. While the details of the process are out of scope in this document, the flow should be something similar to the following:\n+\n+# The software wallet initiates a ''wallet policy registration'' on the hardware signing device; the information should include the wallet policy, but also a unique ''name'' that identifies the policy.\n+# The device shows the wallet policy to the user using the secure screen.\n+# After inspecting the policy and comparing it with a trusted source (for example a printed backup), the user approves the policy.\n+# If stateful, the hardware signing device persists the policy in its permanent memory; if stateless, it returns a \"proof of registration\".\n+\n+The proof of registration will allow the hardware signer to verify that a certain policy was indeed previously approved by the user, and is therefore safe to use without repeating the expensive user verification procedure. The details of how to create a proof of registration are out of scope for this document; using a Message Authentication Code on a hash committing to the wallet policy, its name and any additional metadata is an effective solution if correctly executed.\n+\n+Once a policy is registered, the hardware signing device can perform the typical operations securely:\n+* generating receive and change addresses;\n+* showing addresses on the secure screen;\n+* sign transactions spending from a wallet, while correctly identifying change addresses and computing the transaction fees.\n+\n+Before any of the actions mentioned above, the hardware signing device will retrieve the policy from its permanent storage if stateful; if stateless it will validate the _proof of registration_ before using the wallet policy provided by the client.\n+\n+Once the previously registered policy is correctly identified and approved by the user (for example by showing its name), and as long as the policy registration was executed securely, hardware signing devices can provide a user experience similar to the usual one for single-signature transactions.\n+\n+=== Avoiding blowup in descriptor size ===\n+\n+While reusing a pubkey in different branches of a miniscript is explicitly forbidden by miniscript (as it has certain negative security implications), it is still reasonable to reuse the same xpub in multiple places, albeit with different final steps of derivation (so that the actual pubkeys that are used in the script are indeed different).\n+\n+For example, using Taproot, a 3-of-5 multisignature wallet could use:\n+* a key path with a 5-of-5 MuSig2 aggregated key\n+* a script tree with 11 leaves:\n+** 10 different script using a 3-of-3 MuSig2 aggregated key, plus\n+** a final leaf with a fallback 3-of-5 multisignature using <tt>OP_CHECKSIGADD</tt> (in case interactive signing is not available).\n+\n+This could look similar to:\n+\n+<pre>\n+tr(musig(xpubA,xpubB,xpubC,xpubD,xpubE)/<0;1>/*), {\n+  {\n+    {\n+      pk(musig(xpubA,xpubB,xpubC)/<2;3>/*),\n+      {\n+        pk(musig(xpubA,xpubB,xpubD)/<4;5>/*)\n+        pk(musig(xpubA,xpubB,xpubE)/<6;7>/*),\n+      }\n+    },\n+    {\n+      pk(musig(xpubA,xpubC,xpubD)/<8;9>/*),\n+      {\n+        pk(musig(xpubA,xpubC,xpubE)/<10;11>/*),\n+        pk(musig(xpubA,xpubD,xpubE)/<12;13>/*)\n+      }\n+    }\n+  },\n+  {\n+    {\n+      pk(musig(xpubB,xpubC,xpubD)/<14;15>/*),\n+      pk(musig(xpubB,xpubC,xpubE)/<16;17>/*)\n+    },\n+    {\n+      pk(musig(xpubB,xpubD,xpubE)/<18;19>/*),\n+      {\n+        pk(musig(xpubC,xpubD,xpubE)/<20;21>/*),\n+        sortedmulti_a(3,\n+          xpubA/<22;23>/*,\n+          xpubB/<22;23>/*,\n+          xpubC/<22;23>/*,\n+          xpubD/<22;23>/*,\n+          xpubE/<22;23>/*)\n+      }\n+    }\n+  }\n+})\n+</pre>\n+\n+Notice how each root xpub appears 8 times. With xpubs being up to 118 bytes long, the length of the full descriptor can get extremely long (the problem rapidly gets worse with larger multisignature schemes).\n+\n+Replacing the common part of the key with a short key placeholder and moving the key expression separately helps to keep the size of the wallet policy small, which is crucial to allow human inspection during the registration flow.\n+\n+== Specification ==\n+\n+This section formally defines wallet policies, and how they relate to output script descriptors.\n+\n+=== Formal definition ===\n+\n+A ''wallet policy'' is composed by a ''wallet descriptor template'', together with a vector of ''key information items''.\n+\n+==== Wallet descriptor template ====\n+\n+A ''wallet descriptor template'' is a <tt>SCRIPT</tt> expression.\n+\n+<tt>SCRIPT</tt> expressions:\n+* <tt>sh(SCRIPT)</tt> (top level only): P2SH embed the argument.\n+* <tt>wsh(SCRIPT)</tt> (top level or inside <tt>sh</tt> only): P2WSH embed the argument.\n+* <tt>pkh(KP)</tt> (not inside <tt>tr</tt>): P2PKH output for the given public key.\n+* <tt>wpkh(KP)</tt> (top level or inside <tt>sh</tt> only): P2WPKH output for the given compressed pubkey.\n+* <tt>multi(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script.\n+* <tt>sortedmulti(k,KP_1,KP_2,...,KP_n)</tt> (inside <tt>sh</tt> or <tt>wsh</tt> only): ''k''-of-''n'' multisig script with keys sorted lexicographically in the resulting script.\n+* <tt>tr(KP)</tt> or <tt>tr(KP,TREE)</tt> (top level only): P2TR output with the specified key as internal key, and optionally a tree of script paths.\n+* any valid miniscript template (inside <tt>wsh</tt> or <tt>tr</tt> only).\n+\n+<tt>TREE</tt> expressions:\n+* any <tt>SCRIPT</tt> expression\n+* An open brace <tt>{</tt>, a <tt>TREE</tt> expression, a comma <tt>,</tt>, a <tt>TREE</tt> expression, and a closing brace <tt>}</tt>\n+\n+\n+<tt>KP</tt> expressions (key placeholders) consist of\n+* a single character <tt>@</tt>\n+* followed by a non-negative decimal number, with no leading zeros (except for <tt>@0</tt>)\n+* ''always'' followed by either:\n+** the string  <tt>/**</tt>, or\n+** a string of the form <tt>/<NUM;NUM>/*</tt>, for two distinct decimal numbers <tt>NUM</tt> representing unhardened derivations.\n+\n+TODO: reference BIP-389 for multipath descriptors (not yet merged into the bips repository at time of writing).\n+\n+The <tt>/**</tt> in the placeholder template represents commonly used paths for receive/change addresses, and is equivalent to <tt><0;1>/*</tt>.\n+\n+The placeholder <tt>@i</tt> for some number ''i'' represents the ''i''-th key in the vector of key information items (which must be of size at least ''i + 1'', or the wallet policy is invalid).\n+44\n+\n+Note: while descriptor templates for miniscript are not formally defined in this version of the document (pending standardization) it is straightforward to adapt this approach by adding additional <tt>SCRIPT</tt> expressions.\n+\n+==== Keys information vector ====\n+\n+Each element of the key origin information vector is a <tt>KEY</tt> expression.\n+\n+* Optionally, key origin information, consisting of:\n+** An open bracket <tt>[</tt>\n+** Exactly 8 hex characters for the fingerprint of the master key from which this key is derived from (see [[bip-0032.mediawiki|BIP-32]] for details)\n+** Followed by zero or more <tt>/NUM'</tt> or <tt>/NUM</tt> path elements to indicate hardened or unhardened derivation steps between the fingerprint and the xpub that follows\n+** A closing bracket <tt>]</tt>\n+* Followed by the actual key, which is a serialized extended public key (as defined in [[bip-0032.mediawiki|BIP-32]]).\n+\n+==== Additional rules ====\n+\n+The wallet policy is invalid if any placeholder expression with additional derivation steps is used when the corresponding key information is not an xpub.\n+\n+A wallet policy must have at least one key placeholder and the corresponding key.\n+\n+The key information vector should be ordered so that placeholder <tt>@i</tt> never appear for the first time before an occurrence of <tt>@j</tt>  for some j < i</tt>; for example, the first placeholder is always <tt>@0</tt>, the next one is <tt>@1</tt>, etc.\n+\n+=== Descriptor derivation ===\n+\n+From a wallet descriptor template (and the associated vector of key information items), one can therefore obtain the corresponding multipath descriptor by:\n+\n+* replacing each key placeholder with the corresponding key origin\n+information;\n+* replacing every <tt>/**</tt> with <tt>/<0;1>/*</tt>.\n+\n+For example, the wallet descriptor <tt>pkh(@0/**)</tt> with key information\n+<tt>[\"[d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL\"]</tt>\n+produces the following multipath descriptor:\n+\n+<tt>pkh([d34db33f/44'/0'/0']xpub6ERApfZwUNrhLCkDtcHTcxd75RbzS1ed54G1LkBUHQVHQKqhMkhgbmJbZRkrgZw4koxb5JaHWkY4ALHY2grBGRjaDMzQLcgJvLJuZZvRcEL/<0;1>/*)</tt>\n+\n+=== Implementation guidelines ===\n+\n+Implementations must not necessarily implement all the possible wallet policies defined by this standard, but it is recommended to clearly document any limitation.\n+\n+Implementations can add additional metadata that is stored together with the wallet policy for the purpose of wallet policy registration and later usage. Metadata can be vendor-specific and is out of the scope of this document.\n+\n+Any implementation in a software wallet that allows wallet policies not matching any of the specifications in [[bip-0044.mediawiki|BIP-44]], [[bip-0049.mediawiki|BIP-49]], [[bip-0084.mediawiki|BIP-84]], [[bip-0086.mediawiki|BIP-86]] (especially if involving external cosigners) should put great care into a process for backing up the wallet policy that represents the account. In fact, unlike standard single-signature scenarios, the seed alone is no longer enough to discover wallet policies with existing funds, and the loss of the backup is likely to lead to permanent loss of funds. Unlike the seed, leaking such backups only affects the privacy of the user, but it does not allow the attacker to steal funds.\n+\n+Avoiding key reuse among different wallet accounts is also extremely important, but out of scope for this document.\n+\n+== Examples ==\n+\n+In the examples in this section, the vector of key information items is omitted. See the test vectors below for complete examples.\n+\n+Common single-signature account patterns:\n+* <tt>pkh(@0/**)</tt> (legacy).\n+* <tt>wpkh(@0/**)</tt> (native segwit).\n+* <tt>sh(wpkh(@0/**))</tt> (nested segwit).\n+* <tt>tr(@0/**)</tt> (taproot single-signature account).\n+\n+Common multisignature schemes:\n+* <tt>wsh(multi(2,@0,@1))</tt> - SegWit 2-of-2 multisignature, keys in order.\n+* <tt>sh(sortedmulti(2,@0,@1,@2))</tt> - Legacy 2-of-3 multisignature, sorted keys.\n+\n+Some miniscript policies in <tt>wsh</tt>:\n+* <tt>wsh(and_v(v:pk(@0),or_d(pk(@1),older(12960))))</tt> - Trust-minimized second factor, degrading to a single signature after about 90 days.\n+* <tt>wsh(thresh(3,pk(@0/**),s:pk(@1/**),s:pk(@2/**),sln:older(12960)))</tt> - A 3-of-3 wallet that becomes a 2-of-3 if coins are not spent for about 90 days.\n+* <tt>wsh(or_d(pk(@0),and_v(v:multi(2,@1,@2,@3),older(65535))))</tt> - A singlesig wallet with automatic inheritance to a timelocked 2-of-3 multisig of family members.\n+\n+== Test Vectors ==\n+\n+[[bip-0044.mediawiki|BIP-44]], first account\n+ Descriptor template: pkh(@0)",
      "path": "bip-wallet-policies.mediawiki",
      "position": null,
      "original_position": 254,
      "commit_id": "9adbeccca277e804b3321821e42c1ed0c1ef74ee",
      "original_commit_id": "bb98f8017a883262e03127ab718514abf4a5e5f9",
      "in_reply_to_id": 1227768530,
      "user": {
        "login": "bigspider",
        "id": 6681844,
        "node_id": "MDQ6VXNlcjY2ODE4NDQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6681844?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bigspider",
        "html_url": "https://github.com/bigspider",
        "followers_url": "https://api.github.com/users/bigspider/followers",
        "following_url": "https://api.github.com/users/bigspider/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bigspider/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bigspider/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bigspider/subscriptions",
        "organizations_url": "https://api.github.com/users/bigspider/orgs",
        "repos_url": "https://api.github.com/users/bigspider/repos",
        "events_url": "https://api.github.com/users/bigspider/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bigspider/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Agreed, this ship along with other malleability concerns has unfortunately sailed. Although it would be nice to enforce `'` rather than `h` for hardening in policies at least, @bigspider?\r\n\r\nI agree; Ledger's implementation only allows `'` (choice mostly because it looks better on a small screen).\r\nThe current specs indeed don't mention `h`.\r\n\r\nI'll go over the other comments (and add the failure cases, thanks!) next week.",
      "created_at": "2023-09-07T15:29:48Z",
      "updated_at": "2023-09-07T15:29:48Z",
      "html_url": "https://github.com/bitcoin/bips/pull/1389#discussion_r1318784475",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/comments/1318784475"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bips/pulls/1389"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 254,
      "side": "RIGHT"
    }
  ]
}